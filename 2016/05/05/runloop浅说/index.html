<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="runloop," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1" />






<meta name="description" content="RunLoop基本概念概念:程序的运行循环,通俗的来说就是跑圈.
基本作用（作用重大）
保持程序的持续运行(ios程序为什么能一直活着不会死) 
处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 
节省CPU资源，提高程序性能，有事情就做事情，没事情就休息

重要说明
如果没有Runloop,那么程序一启动">
<meta property="og:type" content="article">
<meta property="og:title" content="runloop理论">
<meta property="og:url" content="https://github.com/icoderRo/2016/05/05/runloop浅说/index.html">
<meta property="og:site_name" content="simonの小📚坊">
<meta property="og:description" content="RunLoop基本概念概念:程序的运行循环,通俗的来说就是跑圈.
基本作用（作用重大）
保持程序的持续运行(ios程序为什么能一直活着不会死) 
处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 
节省CPU资源，提高程序性能，有事情就做事情，没事情就休息

重要说明
如果没有Runloop,那么程序一启动">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/006tNc79gw1f9bxanqbzej30g708vjs8.jpg">
<meta property="og:image" content="http://ww2.sinaimg.cn/large/006y8mN6gw1f9bxfzud7qj30fn0bk0tx.jpg">
<meta property="og:image" content="http://ww4.sinaimg.cn/large/006y8mN6gw1f9bxl6gospj30gd0c4767.jpg">
<meta property="og:updated_time" content="2016-10-31T16:49:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="runloop理论">
<meta name="twitter:description" content="RunLoop基本概念概念:程序的运行循环,通俗的来说就是跑圈.
基本作用（作用重大）
保持程序的持续运行(ios程序为什么能一直活着不会死) 
处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 
节省CPU资源，提高程序性能，有事情就做事情，没事情就休息

重要说明
如果没有Runloop,那么程序一启动">
<meta name="twitter:image" content="http://ww4.sinaimg.cn/large/006tNc79gw1f9bxanqbzej30g708vjs8.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"remove"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://github.com/icoderRo/2016/05/05/runloop浅说/"/>

  <title> runloop理论 | simonの小📚坊 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="images/logo.svg"
             alt="simonの小📚坊"/>
      </a>
    </div>
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">simonの小📚坊</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">始于颜值，陷于才华，忠于人品</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">

      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                runloop理论
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-05T00:00:00+08:00" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="RunLoop基本概念"><a href="#RunLoop基本概念" class="headerlink" title="RunLoop基本概念"></a>RunLoop基本概念</h2><p>概念:程序的运行循环,通俗的来说就是跑圈.</p>
<h3 id="基本作用（作用重大）"><a href="#基本作用（作用重大）" class="headerlink" title="基本作用（作用重大）"></a>基本作用（作用重大）</h3><ul>
<li>保持程序的持续运行(ios程序为什么能一直活着不会死) </li>
<li>处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） </li>
<li>节省CPU资源，提高程序性能，有事情就做事情，没事情就休息</li>
</ul>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><ul>
<li>如果没有Runloop,那么程序一启动就会退出，什么事情都做不了。 </li>
<li>如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行</li>
</ul>
<h3 id="main函数中的Runloop"><a href="#main函数中的Runloop" class="headerlink" title="main函数中的Runloop"></a>main函数中的Runloop</h3><ul>
<li>在UIApplication函数内部就启动了一个Runloop,该函数返回一个int类型的值 </li>
<li>这个默认启动的Runloop是跟主线程相关联的</li>
</ul>
<h3 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h3><ul>
<li>在iOS开发中有两套api来访问Runloop <ul>
<li>第一种:foundation框架【NSRunloop】 </li>
<li>第二种:core foundation框架【CFRunloopRef】 </li>
</ul>
</li>
<li>NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 </li>
<li>NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</li>
</ul>
<h3 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h3><ul>
<li>Runloop和线程的关系：一个Runloop对应着一条唯一的线程 </li>
</ul>
<p><strong>如何让子线程不死</strong></p>
<ul>
<li>给这条子线程开启一个Runloop </li>
<li>Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 </li>
<li>Runloop的生命周期：在第一次获取时创建，在线程结束时销毁 </li>
<li>拿到当前应用程序的主Runloop（主线程对应的Runloop）</li>
</ul>
<p>方法一: NSRunloop</p>
<pre><code>NSRunLoop * runloop1 = [NSRunLoop mainRunLoop];
</code></pre><p>方法二: CFRunLoopRef<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef runloop2 =   CFRunLoopGetMain();</div></pre></td></tr></table></figure></p>
<ul>
<li>注意：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。</li>
</ul>
<h2 id="Runloop运行原理"><a href="#Runloop运行原理" class="headerlink" title="Runloop运行原理"></a>Runloop运行原理</h2><h3 id="苹果官方的运行原理图"><a href="#苹果官方的运行原理图" class="headerlink" title="苹果官方的运行原理图"></a>苹果官方的运行原理图</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79gw1f9bxanqbzej30g708vjs8.jpg" alt=""></p>
<h3 id="Runloop和相关类之间的关系图"><a href="#Runloop和相关类之间的关系图" class="headerlink" title="Runloop和相关类之间的关系图"></a>Runloop和相关类之间的关系图</h3><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gw1f9bxfzud7qj30fn0bk0tx.jpg" alt=""></p>
<h3 id="RunLoop五个相关的类"><a href="#RunLoop五个相关的类" class="headerlink" title="RunLoop五个相关的类"></a>RunLoop五个相关的类</h3><ul>
<li>CFRunloopRef</li>
<li>CFRunloopModeRef【Runloop的运行模式】</li>
<li>CFRunloopSourceRef【Runloop要处理的事件源】</li>
<li>CFRunloopTimerRef【Timer事件】</li>
<li>CFRunloopObserverRef【Runloop的观察者（监听者）】</li>
</ul>
<h4 id="CFRunloopRef"><a href="#CFRunloopRef" class="headerlink" title="CFRunloopRef"></a>CFRunloopRef</h4><ul>
<li>CFRunloopModeRef代表着Runloop的运行模式 </li>
<li>一个Runloop中可以有多个mode,一个mode里面又可以有多个 source/observer/timer等等 </li>
<li>每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode </li>
<li>如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入 </li>
<li>这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响 </li>
<li>系统默认注册了5个mode <ul>
<li>第一种模式: kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 </li>
<li>第二种模式: UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 </li>
<li>第三种模式: UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 </li>
<li>第四种模式: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 </li>
<li>第五种模式: kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode</li>
</ul>
</li>
</ul>
<h4 id="CFRunloopTimerRef"><a href="#CFRunloopTimerRef" class="headerlink" title="CFRunloopTimerRef"></a>CFRunloopTimerRef</h4><ul>
<li>runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就不会参与。一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。 </li>
<li>它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer . </li>
<li>NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，和runloop的运行模式kCFRunLoopDefaultMode<br>有时候需要修改模式,达到类似在后台持续运行的效果,不受外界的影响</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h4 id="CFRunloopSourceRef"><a href="#CFRunloopSourceRef" class="headerlink" title="CFRunloopSourceRef"></a>CFRunloopSourceRef</h4><ul>
<li><p>事件源也就是输入源，有两种分类模式； </p>
<ul>
<li>一种是按照苹果官方文档进行划分的 </li>
<li>另一种是基于函数的调用栈来进行划分的（source0和source1）。 </li>
</ul>
</li>
<li><p>苹果官方文档</p>
<ul>
<li>Port-Based Sources </li>
<li>Custom Input Sources </li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li><p>函数的调用栈</p>
<ul>
<li>Source0：非基于Port的 </li>
<li>Source1：基于Port的</li>
</ul>
</li>
</ul>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><ul>
<li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个runloop监听者</div><div class="line"> CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, </div><div class="line">YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; </div><div class="line">NSLog(@”监听runloop状态改变—%zd”,activity); &#125;); //为runloop添加一个监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, </div><div class="line">kCFRunLoopDefaultMode); CFRelease(observer);</div></pre></td></tr></table></figure>
<ul>
<li>监听的状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; </div><div class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Runloop </div><div class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimer </div><div class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Sources </div><div class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 </div><div class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 </div><div class="line">kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloop </div><div class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变 &#125;;</div></pre></td></tr></table></figure>
<h2 id="RunLoop运行逻辑"><a href="#RunLoop运行逻辑" class="headerlink" title="RunLoop运行逻辑"></a>RunLoop运行逻辑</h2><p><img src="http://ww4.sinaimg.cn/large/006y8mN6gw1f9bxl6gospj30gd0c4767.jpg" alt=""></p>
<ul>
<li>一个线程对应一个runLoop,主线程的runloop是程序一启动,默认就创建一个runloop,创建好了之后就会给它添加一些默认的模式,每个模式里面会有很多的 source /timer/observer ,添加好这些模式后,observer就会监听主线程的runloop,进入runloop后,就开始处理事件,先处理timer,再处理source0,source0处理完之后再处理source1,当把这些所有的事件反复的处理完之后,如果没有事件了,那么runloop就会进入睡眠状态,当用户又触发了新的事件,就会唤醒runloop,唤醒runloop后回到第二步,重新处理新的timer,新的source0,新的source1,处理完后就睡眠,一直反复,当我们把程序关闭或者强退,这个时候observer就会监听都runloop退出了.</li>
</ul>
<ul>
<li><p>observer是监听runloop的状态.</p>
</li>
<li><p>timer / source/<br>CFRunLoopRef创建一个timer必须添加到runloop 才会执行,添加的时候要指定模式 default模式 ,不对程序做任何操作 timer就会后台运行 ,当我进行操作的时候runloop模式就会从默认模式切换到其他模式,假如说我操作scrollerView 它就会从default模式切换到tracking模式<br>而roonloop 同一时刻只能执行一种模式.<br>当在创建timer时指定 Comment 仅仅是个标记,默认和追踪,那么timer就会随着触发的模式不同进行 默认和追踪模式的选择 </p>
</li>
<li><p>Source<br>source一般是不会去操作的,第一种是基于自定义的,第二种是基于端口的,第三种是基于Performselect的通过函数调用栈来对source分类:分为source0 source1 :<br>(1)source0是非基于端口的,是用户自己手动触发的操作,比如触摸滑动等操作.<br>(2)Source1是系统内部的一些端口触发的事件<br>(3)子线程的runloop需要手动创建,需要手动开启</p>
</li>
<li><p>自动释放池<br>第一次创建:是在runloop进入的时候创建 对应的状态 = KCFRunLoopEntry<br>最后一个退出,是在runloop退出的时候 对应的状态 = KCFRunLoopExit </p>
<blockquote>
<p>其他的创建和释放<br>即将进入睡眠的时候,先释放上一次创建的自动释放池,然后再创建一个新的释放池</p>
</blockquote>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/runloop/" rel="tag">#runloop</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/31/封装录音与播放/" rel="next" title="录音与本地播放">
                <i class="fa fa-chevron-left"></i> 录音与本地播放
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/12/netty-socket编解码/" rel="prev" title="基于netty LengthFieldBasedFrameDecoder编解码">
                基于netty LengthFieldBasedFrameDecoder编解码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">simon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"blog-ro"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
