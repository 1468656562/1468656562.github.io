<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Simonの小📚坊</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="嗨, 我是simon">
<meta property="og:type" content="website">
<meta property="og:title" content="Simonの小📚坊">
<meta property="og:url" content="https://github.com/icoderRo/page/2/index.html">
<meta property="og:site_name" content="Simonの小📚坊">
<meta property="og:description" content="嗨, 我是simon">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simonの小📚坊">
<meta name="twitter:description" content="嗨, 我是simon">
  
    <link rel="alternate" href="/atom.xml" title="Simonの小📚坊" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/home.css" >
  

  

  
  
  

</head>



  <body>


  
    <header id="header">

    
      <div id="intrologo" class="intro-logo" style="background-position:center; background-repeat:no-repeat; background-image: url(); background-size: auto 100%;">

      <!-- Support rolling -->  
        
        <section class="awSlider">
          <div class="carousel slide carousel-fade " data-ride="carousel">

            <!-- Wrapper for slides -->
            <div class="carousel-inner">
               
                  
                    <div class="item active">
                  
                    <img id="carousel-img0" src="/css/images/home-bg.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img0 = new Image();
                      var imageTag0 = document.getElementById("carousel-img0");
                      img0.src = imageTag0.src;
                      img0.onload=function(){
                        if (img0.width / img0.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag0.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag0.style.height = document.body.clientHeight + "px";
                          imageTag0.style.marginLeft = -(document.body.clientHeight * img0.width / img0.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img1" src="/css/images/sample.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img1 = new Image();
                      var imageTag1 = document.getElementById("carousel-img1");
                      img1.src = imageTag1.src;
                      img1.onload=function(){
                        if (img1.width / img1.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag1.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag1.style.height = document.body.clientHeight + "px";
                          imageTag1.style.marginLeft = -(document.body.clientHeight * img1.width / img1.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img2" src="https://source.unsplash.com/collection/954550/1024x768">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img2 = new Image();
                      var imageTag2 = document.getElementById("carousel-img2");
                      img2.src = imageTag2.src;
                      img2.onload=function(){
                        if (img2.width / img2.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag2.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag2.style.height = document.body.clientHeight + "px";
                          imageTag2.style.marginLeft = -(document.body.clientHeight * img2.width / img2.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
            </div>

            <!-- Controls -->
            <a class="left carousel-control" href=".carousel" role="button" data-slide="prev">
              <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
              <span class="sr-only">Geri</span>
            </a>
            <a class="right carousel-control" href=".carousel" role="button" data-slide="next">
              <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
              <span class="sr-only">İleri</span>
            </a>
          </div>
        </section>
        <script>
          $('section.awSlider .carousel').carousel({
              pause: '',
              interval: 5000
          });
          var startImage = $('section.awSlider .item.active > img').attr('src');
          $('section.awSlider .carousel').on('slid.bs.carousel', function () {
              var bscn = $(this).find('.item.active > img').attr('src');
              $('section.awSlider > img').attr('src', bscn);
          });
        </script>
      

    
 


    <canvas width="100%" height="100%"></canvas>
    <script>
      var c = document.getElementsByTagName('canvas')[0],
          x = c.getContext('2d'),
          w = window.innerWidth,
          h = window.innerHeight,
          pr = window.devicePixelRatio || 1,
          f = 90,
          q,
          m = Math,
          r = 0,
          u = m.PI*2,
          v = m.cos,
          z = m.random
      c.width = w*pr
      c.height = h*pr
      x.scale(pr, pr)
      x.globalAlpha = 0.6

      
    </script>
    

    
      <div id="homelogo" class="homelogo" style="background: rgba(255,255,255,1);"> 
    

        
          <div class="homelogoback"  style="border: 1px solid #404040;" >
            <h1><a href="#content" id="logo">Simonの小📚坊</a></h1>
            <h3>嗨, 我是simon</h3>
            <h5>Simon</h5>
            <!-- <p><a href="https://github.com/iTimeTraveler" target="_blank">Github</a></p> -->
          </div>
        
    
    </div>
  </div>

  <!-- 自适应主页背景大图 -->
  

 <!-- home_logo_image居中 -->
 
    <script>
        var homelogodiv = document.getElementById("homelogo");
        if (document.all.homelogo.offsetWidth > document.body.clientWidth) {
          homelogodiv.style.width = document.body.clientWidth + "px";
          homelogodiv.style.marginLeft = document.body.clientWidth * -0.5 + "px";
        } else {
          homelogodiv.style.width = homelogodiv.clientWidth  + "px";
          homelogodiv.style.marginLeft = (homelogodiv.clientWidth)  * -0.5 + "px";
        }
    </script>
  

  <div class="intro-navigate">
      <p class="navigater-list">
        
          <a id="beautifont" class="main-nav-link" href="/">Home</a>
        
          <a id="beautifont" class="main-nav-link" href="/archives">Archives</a>
        
          <a id="beautifont" class="main-nav-link" href="/about">About</a>
        
      </p>
  </div>

</header>
  
  <div id="container">
    <div id="wrap">
      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;">
  
    <article id="[post]-IP相关的协议"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/12/24/IP相关的协议/">IP相关的协议(四)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/12/24/IP相关的协议/" class="article-date">
	  <time datetime="2015-12-23T16:00:00.000Z" itemprop="datePublished">2015-12-24</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="IP相关的协议"><a href="#IP相关的协议" class="headerlink" title="IP相关的协议"></a>IP相关的协议</h3><p>IP的目的是让最终目标主机收到数据包, 但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能, 以及数据包在发送过程中异常情况处理的功能。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>我们平常在访问某个网站时, 域名(域名是指为了识别主机名称和组织机构名称的一种具有分层的名称。比如在域名 bnu.edu.cn中，neu是主机名，edu 和 cn 是不同层次下的机构名), 而不是使用IP地址。能够这样做是因为有了DNS。DNS可以将自身具有意义的域名自动转换为具体的IP地址。</p>
<blockquote>
<p>在Windows/Unix中查找域名对应的IP地址可以输入nslookup 域名</p>
</blockquote>
<h5 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h5><p>以访问www.ietf.org为例,此时的DNS查询流程如图所示:<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fib4j1xk4mj30q40kyjvl.jpg" alt=""></p>
<p>解析器为了查询IP地址, 向域名服务器进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回, 如果没有, 则域名服务器再向上一层跟域名服务器进行查询处理。解析器和域名服务器将最新了解到的信息暂时保存在缓存里。这样, 可以减少每次查询时的性能消耗。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>在网络层, 只要确定了IP地址, 就可以向这个目标地址发送IP数据报。在数据链路层, 进行通信时需要了解每个IP地址多对应的MAC地址。ARP是一种解决地址问题得协议,根据目标IP地址为线索,用来定位下一个接收数据分包的网络设备对应的MAC地址。</p>
<h5 id="ARP工作机制"><a href="#ARP工作机制" class="headerlink" title="ARP工作机制"></a>ARP工作机制</h5><p>ARP借助ARP请求与ARP响应两种类型的包确定MAC地址。<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fib53e0qn9j30o40cc768.jpg" alt=""></p>
<p>主机A为了获取主机B的MAC地址, 起初要通过<strong>广播</strong>发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是书, ARP请求包中已经包含了主机B的IP地址。由于广播的包可以被同一个链路上所有的主机或路由器接收, 因此ARP请求包也就会被同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致, 那么这个节点就将自己的MAC地址塞入ARP响应包, 返回给主机A。主机A将获取到的MAC地址缓存一段时间, 以减少ARP包的发送与流量的浪费。</p>
<blockquote>
<p>RARP是将ARP反过来, 从MAC地址定位IP地址的一种协议。<br>代理ARP, 通常ARP包会被路由器隔离, 但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此, 两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p>
</blockquote>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>ICMP的主要功能: 确认IP包是否成功送达目标地址, 通知发送过程当中IP包被废弃的具体原因, 改善网络设置等。因此可以监听网络是否正常、设置是否有误以及设备有何异常等信息。</p>
<p>ICMP的消息大致可以分为两类: 一类是通知出错原因的错误消息, 另一类是用于诊断的查询消息。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fiba4swzfgj30oq0k2413.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fiba6wv959j30la0fwdik.jpg" alt=""></p>
<h5 id="ICMP的主要消息"><a href="#ICMP的主要消息" class="headerlink" title="ICMP的主要消息"></a>ICMP的主要消息</h5><ul>
<li><p>ICMP目标不可达消息(类型3)<br>IP路由器无法将IP数据报发送给目标地址时, 会给发送端主机返回一个目标不可达的ICMP消息, 并在这个消息中显示不可达的具体原因。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fiba9s5aptj30r20k642f.jpg" alt=""></p>
</li>
<li><p>ICMP重定向消息(类型5)<br>如果路由器发现发送端主机使用了次优的路径发送数据, 那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。多数情况下由于这种重定向消息成为引发问题的原因, 所以一般不进行这种设置。</p>
</li>
<li><p>ICMP超时消息(类型11)<br>IP包中有一个字段叫做TTL, 它的值会随着每经过一次路由器就会减1, 减到0该IP包就会被丢弃。此时, IP路由器将会发送一个ICMP超时的消息给发送端主机, 并通知该包已被丢弃。<br>设置IP包生存周期的主要目的, 是为了在路由控制发生循环状况时,避免IP包无休止的在网络上被转发; 此外可以利用TTL控制包的到达范围。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fibah33x2oj30pc0ce0uj.jpg" alt=""> </p>
</li>
<li><p>ICMP回送消息(类型0、8)<br>用于所发送的数据包是否已经成功到达对端的一种消息。可以向对端主机发送回送请求的消息, 也可以接收对端主机发回来的回送应答消息。ping就是利用这个消息实现的。<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fibambvmd6j30pm08wq4p.jpg" alt=""></p>
</li>
</ul>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP实现了自动设置IP地址、统一管理IP地址的分配,也就是说,DHCP实现了即插即用。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fibaq1zzgbj30ro0oodl4.jpg" alt=""> </p>
<h5 id="DHCP工作机制"><a href="#DHCP工作机制" class="headerlink" title="DHCP工作机制"></a>DHCP工作机制</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fibarysrjlj30re0n4dl9.jpg" alt=""></p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>NAT是用于在本地网络中使用私有地址, 在连接到互联网时转而使用全局IP地址的技术。除了可以转换IP地址外, 还可以转换TCP、UDP端口号的NAPT技术, 由此可以实现用一个全局IP地址与多个主机的通信。</p>
<h5 id="NAT工作机制"><a href="#NAT工作机制" class="headerlink" title="NAT工作机制"></a>NAT工作机制</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fibb46tim9j30t00e4gpv.jpg" alt=""><br>在NAT(NAPT)的路由器内部, 有一张自动生成的用来转换地址的表。当私有网络内的多台机器同时与外部进行通信, 仅仅转换IP地址, 全局IP地址可能会出现不够用的情况, 这时采用和端口号一起转换的方式(NAPT)可以解决这个问题。</p>
<h5 id="NAPT工作机制"><a href="#NAPT工作机制" class="headerlink" title="NAPT工作机制"></a>NAPT工作机制</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fibb7buomaj30su0jqn2i.jpg" alt=""><br>转换表在NAT路由器上自动生成, 以TCP为例, 在建立TCP连接的首次握手时的SYN包一经发出, 就会生成这个表。而后收到关闭连接时发出的FIN包的确认应答后就从表中被删除。</p>
<h5 id="NAT-PT"><a href="#NAT-PT" class="headerlink" title="NAT-PT"></a>NAT-PT</h5><p>NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术。让那些只有IPv6地址的主机也能够与IPv4地址的其他主机进行通信。</p>
<h5 id="NAT的潜在问题"><a href="#NAT的潜在问题" class="headerlink" title="NAT的潜在问题"></a>NAT的潜在问题</h5><ul>
<li>无法从NAT的外部向内部服务建立连接</li>
<li>转换表的生成与转换操作都会产生一定开销</li>
<li>通信过程中一旦NAT遇到异常需要重新启动, 所有的TCP连接都会被重置。</li>
</ul>
<blockquote>
<p>解决NAT的潜在问题<br> 1.改用IPv6<br>    2.”NAT穿越”</p>
</blockquote>
<h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p>IP隧道中可以将IPv6的包合成为一个数据, 再追加一个IPv4的首部后, 让IPv4的网络识别。这种在网络层的首部后面继续追加网络层首部的通信方式就叫做”IP隧道”。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fibbnx83jhj30oo0lin1n.jpg" alt=""></p>
<h4 id="显示拥塞通知-ECN"><a href="#显示拥塞通知-ECN" class="headerlink" title="显示拥塞通知(ECN)"></a>显示拥塞通知(ECN)</h4><p>ECN为实现拥塞通知的功能, 将IP首部的TOS字段置换为ENC字段, 并在TCP首部的保留位中追加拥塞窗口减少(CWR)和ECE表示。</p>
<p>ECN的机制概括起来就是在发送包的IP首部中记录路由器是否遇到拥塞, 并在返回包的TCP首部中通知是否发生过拥塞。拥塞检查在网络层(IP)进行, 而拥塞通知则在传输层(TCP)进行。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fibc0b57fkj30qc0hodjy.jpg" alt=""></p>
<p>参考:</p>
<ul>
<li><a href="">图解TCP/IP</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-IP协议"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/12/18/IP协议/">IP协议(三)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/12/18/IP协议/" class="article-date">
	  <time datetime="2015-12-17T16:00:00.000Z" itemprop="datePublished">2015-12-18</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP(IPv4、IPv6)相当于参考模型中的第三层–网络层。</p>
<p>网络层的主要作用是: 实现终端节点之间的通信; 也叫做点对点通信。</p>
<blockquote>
<p>主机: 配置有IP地址, 不进行路由控制<br>路由器: 既配有IP地址, 又具有路由控制能力<br>节点: 主机和路由器的统称</p>
</blockquote>
<p>数据链路层的主要作用是在互连<strong>同一种数据链路</strong>的节点之间进行包的传递。而一旦跨越多种数据链路, 就需要借助网络层。网络层可以跨越不同的数据链路, 在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi7pp3hm37j30qw0c2acf.jpg" alt=""></p>
<p>###IP地址<br>数据链路层的MAC地址是用来标识同一个链路中不同计算机的一种识别码。作为网络层的IP, 也有这种地址信息, 叫做IP地址。IP地址用于在<strong>连接到网络中的所有主机中识别出进行通信的目标地址</strong>, 在TCP/IP通信中所有的主机/路由器都必须设定自己的IP地址, 用IP地址识别主机和路由器。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fi7q2a376oj30oe0aoach.jpg" alt=""></p>
<p>不论主机与哪种数据链路连接, 其IP地址的形式都保持不变, 在网桥/交换机集线器等物理层或数据链路层的数据包转发设备中, 不需要设置IP地址, 因为这些设备只负责将IP包转化为0、1的比特流转发或者数据链路帧的数据部分进行转发, 因而不需要对应IP协议。</p>
<h4 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h4><p>IPv4地址由32位正整数来表示, IP地址在计算机内部以二进制的方式被处理, 为了方便管理, 将32位的IP地址以<strong>每8位一组, 分成4组,每组以.隔开</strong>, 再将每组数转换为十进制数。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7qdef8jzj30nk052dge.jpg" alt=""></p>
<p>将表示成IP地址的数字整体计算, 会得出大约43亿台计算机允许连接到网络。实际上, IP地址不是根据主机台数来配置的, 而是每一台主机上的每一块网卡都得设置IP地址, 通常一块网卡只设置一个IP地址, 一块网卡也可以配置多个IP地址。一台路由器通常都会配置两个以上的网卡, 因此可以设置两个以上的IP地址。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fi7qidno8yj30nm06uwfu.jpg" alt=""></p>
<h4 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h4><p>IP地址由<strong>网络标识(网络地址)</strong>和<strong>主机标识(主机地址)</strong>两部分组成。</p>
<p>网络标识在数据链路的每个段配置不同的值。网络标识必须保证互相连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一个网段内重复出现。因此, 可以通过设置网络地址和主机地址, 在相互连接的整个网络中保证每台主机的IP地址都不会相互重叠, 即IP地址具有了唯一性。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7qvk2oefj30qq0oa78r.jpg" alt=""></p>
<p>如何区分网络标识和主机标识, 有两种类型, 一种是<strong>分类</strong>, 另一种是也是现在主流的方式<strong>子网掩码(网络前缀)</strong></p>
<h5 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h5><p>IP地址分为四个级别, 根据IP地址中的第1位~第4位的比特位对其网络标识和主机标识进行区分, 共分为A、B、C、D四类。                                   </p>
<ul>
<li><strong>A类地址</strong>是首位以”0”开头的地址。从第1位~第8位是网络标识, 后24位是主机标识。</li>
<li><strong>B类地址</strong>是前两位以”10”开头的地址。从第1位~第16位是网络标识, 后16位是主机标识。</li>
<li><strong>C类地址</strong>是前三位以”110”开头的地址。从第1位~第24位是网络标识, 后8位是主机标识。</li>
<li><strong>D类地址</strong>是前四位以”1110”开头的地址。从第1位~第32位是网络标识, 没有主机标识, 常用于多播。</li>
</ul>
<blockquote>
<p>全部为0的主机地址: 代表网络/IP地址不可获知。<br>全部为1的主机地址: 通常用于广播地址。<br>在分配主机地址, 应该去掉这两种情况, 因此C类地址的每个网段最多只能有256-2个主机地址。</p>
</blockquote>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>分类造成浪费? 例如, 在架构B类型的IP网络时, 可以使用的主机标识大约有6万多个, 也就意味着, 一个链路内允许6万多台计算机连接; 实际网络架构中, 不会再同一个链路上连接6万多台计算机, 所以A/B类地址会造成浪费。</p>
<p>通过子网掩码细分出比A、B、C、D分类更细粒度的网络。就是将原来分类中的主机地址部分用作子网地址, 网络地址分为多个物理网络的一种机制。</p>
<p>引入子网以后, 一个IP地址就有了两种识别码, 一种是原来的IP地址本身, 另一个是表示网络部分的子网掩码。 子网掩码用二进制表示的话, 也是一个32位的数字。它对应的IP地址<strong>网络标识</strong>部分的位全部为”1”, 对应IP地址<strong>主机标识</strong>的部分则全部为”0”。由此一个IP地址可以不再受限于自己的类别, 而是可以用这样的子网掩码自由地定位自己的网络标识长度。子网掩码必须是IP地址的首页开始连续为”1”。</p>
<p>子网掩码有两种表示方式, 一种是将IP地址与子网掩码地址分别用两行来表示; 另外一种是在IP地址的后面追加网络地址的位数, 用”/“隔开。</p>
<table>
<thead>
<tr>
<th>地址表示</th>
<th style="text-align:center">十进制            </th>
</tr>
</thead>
<tbody>
<tr>
<td>IP地址</td>
<td style="text-align:center">172.20.100.52    </td>
</tr>
<tr>
<td>子网掩码</td>
<td style="text-align:center">255.255.255.192</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>地址表示</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">位数 </th>
</tr>
</thead>
<tbody>
<tr>
<td>IP地址</td>
<td style="text-align:center">172.20.100.52</td>
<td style="text-align:center">/26</td>
</tr>
</tbody>
</table>
<blockquote>
<p>172.20.0.0/26 与172.20/26是同一个意思, 可以省略后面的”0”<br>CIDR: 采用任意长度分割IP地址的网络标识和主机标识, 也叫无类型域间选路。在CIDR被应用到互联网的初期, 网络内部采用固定长度的子网掩码机制, 采用统一的标注, 就难以架构一个高效的网络结构, 为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。<br>VLSM: 可变长度子网掩码, 可以将网络地址分为主机数500个时子网掩码长度位/23, 主机数位50个时子网掩码长度位/26, 有了CIDR和VLSM技术, 相对缓解了全局IP地址不够用的问题, 但无法改变IPv4的地址绝对数是有限的问题。</p>
</blockquote>
<h4 id="全局地址与私有地址"><a href="#全局地址与私有地址" class="headerlink" title="全局地址与私有地址"></a>全局地址与私有地址</h4><p>随着互联网的迅速普及, IP地址不足的问题日趋显著, 如果一直按照现行的方法采用唯一地址的话(每一台主机/路由器必须配有一个唯一的IP地址), 会有IP地址耗尽的危险。于是出现了一种新的技术。它不要求为每一台主机/路由器分配一个固定的IP地址, 而是在必要的时候为相应数量的设备分配唯一的IP地址。<br>对于那些没有连接网络的独立网络中的主机, 只要保证在这个网络内地址唯一, 可以不用考虑互联网即可配置相应的IP地址。不过让每个独立的网络各自随意配置IP地址也会出现问题(冲突)。于是乎出现了私有的网络IP地址:<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi7tqk4tbdj30my03wt9a.jpg" alt=""></p>
<p>包含在这个范围内的IP地址都属于私有IP, 在此之外的IP地址称为全局IP。</p>
<p>私有IP最早没有计划连接互联网, 只用于互联网之外的独立网络。随着NAT/NAPT(能够互换私有IP和全局IP)技术的诞生, 配有私有地址的主机与配有全局地址的互联网主机实现了通信。</p>
<p>企业内部基本在每个终端上设置私有IP, 在路由器(宽带路由器)/服务器上设置全局IP, 配有私有IP地址的主机通过联网时, 通过NAT进行通信。私有IP地址结合NAT技术已成为现在解决IP地址分配问题的主流方案。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi7tx1p7ftj30q20ggaee.jpg" alt=""></p>
<h3 id="IPv4首部"><a href="#IPv4首部" class="headerlink" title="IPv4首部"></a>IPv4首部</h3><p>通过IP进行通信时, 需要在数据的前面加入IP首部的信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fiazkfelm4j30ny0hmtcy.jpg" alt=""></p>
<ul>
<li>版本(Version)<br>由4比特构成, 表示标识IP首部的版本号, IPv4的版本号即为4, 因此在这个字段上的值也是”4”。</li>
<li>首部长度(IHL: Internet Header Length)<br>由4比特构成, 表明IP首部的大小, 单位为4字节(32比特), 对于没有可选项的IP包, 首部长度则设置为”5”。</li>
<li>区分服务(TOS: Type Of Service)<br>由8比特构成, 用来表明服务质量, 由于实现TOS控制极其复杂, TOS基本没有被投入使用。</li>
<li>总长度(Total Length)<br>表示IP首部与数据部分合起来的总字节数。该字段长16比特。因此IP包的最大长度为65535字节。</li>
<li>标识(ID: Identification)<br>由16比特构成, 用于分片重组。同一个分片的标识值相同, 不同分片的标识值不同。每发送一个IP包, 它的值也逐渐递增。如果ID相同, 但是目标地址、源地址或协议不同的话, 也会被认为是不同的分片。</li>
<li>标志(Flags)<br>由3比特构成, 表示包被分片的相关信息。</li>
</ul>
<table>
<thead>
<tr>
<th>比特</th>
<th style="text-align:center">含义            </th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">未使用。目前必须为0   </td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">指示是否进行分片, 0:可以分片, 1:不能分片</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">包被分片的情况下, 表示是否为最后一个包, 0:最后一个分片的包, 1:分片中段的包</td>
</tr>
</tbody>
</table>
<ul>
<li>片偏移(FO: Fragment Offset)<br>由13比特构成, 用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0。</li>
<li>生存时间(TTL: Time To Live)<br>由8比特构成, 指可以中转多少个路由器的意思, 每经过一个路由器, TTL会减少1, 知道变成0则丢弃该包。<br>为了避免IP包在网络内无限传递。</li>
<li>协议(Protocol)<br>由8比特构成, 表示IP首部的<strong>下一个首部</strong>属于哪个协议。</li>
<li>首部和校验(Header Checksum)<br>由16比特构成, 也叫IP首部校验和,主要用来确保IP数据报不被破坏。该字段只校验数据报的首页, 不校验数据部分。校验和的计算过程, 首先要将该校验和的所有位置设置为0, 然后以16比特为单位划分IP首部, 并用1补数计算所有16位字的和。最后将所得到这个和的1补数赋给首部校验和字段。</li>
<li>源地址(Source Address)<br>由32比特构成, 表示发送端IP地址。</li>
<li>目标地址(Destination Address)<br>由32比特构成, 表示接收端IP地址。</li>
<li>可选项(Options)<br>长度可变, 通常只在进行实验或诊断时使用。该字段包含如下几点信息: 安全级别, 源路径, 路径记录, 时间戳。</li>
<li>填充(Padding)<br>也叫填补物, 在有可选项的情况下, 首部长度可能不是32比特的整数倍。为此, 通过向字段填充为0, 调整首部长度为32比特的整数倍。</li>
<li><p>数据(Data)<br>存入数据。将IP上层协议的首部也作为数据进行处理。</p>
<h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>发送数据包时使用的地址就是网络层的地址, 也就是IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址, 在发送过程中还需要类似”指明路由器或主机”的信息, 以便发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。实现IP通信的主机和路由器都必须持有一张这样的表。<br>路由控制表的形成方式有两种:                         </p>
</li>
<li><p>静态路由控制:管理员手动设置。</p>
</li>
<li>动态路由控制: 路由器与其他路由器相互交换信息时自动刷新。</li>
</ul>
<h4 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h4><p>IP地址的<strong>网络地址</strong>部分用于进行路由控制。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7ug8vnmbj30dc0b9myt.jpg" alt=""><br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址, 在发送IP包时, 首先要确定IP首部中的目标地址, 再从路由控制表中找到与该地址具有相同网络地址的记录, 根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同的网路地址记录, 就选择一个相同位数最多的地址。</p>
<h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>如果一张路由表中包含所有的网络及其子网的信息, 将会造成浪费。这时, 默认路由是不错的选择, 默认路由指路由表中任何一个地址都能与之匹配。<br>默认路由一般标记为0.0.0.0/0或default, 这里的0.0.0.0/0并不是指IP地址是0.0.0.0, 而是后的”/0”, 所以并没有标识IP地址。它只是为了避免人们误认为0.0.0.0是IP地址。有时默认路由也被标记为default, 在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。</p>
<h5 id="主机路由"><a href="#主机路由" class="headerlink" title="主机路由"></a>主机路由</h5><p>“IP地址/32”也被称为主机路由。例如: 192.168.153.15/32就是一种主机路由。它的意思是整个IP地址的所有位都将会参与路由; 进行主机路由, 意味着要基于主机上网卡配置的<strong>IP地址本身(网络地址+ 主机地址)</strong>, 而不是基于该地址的<strong>网络地址</strong>部分进行路由。</p>
<h5 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h5><p>环回地址是在同一台计算机上的<strong>程序之间</strong>进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址局具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时, 数据包不会流向网络。</p>
<h4 id="路由控制表的聚合"><a href="#路由控制表的聚合" class="headerlink" title="路由控制表的聚合"></a>路由控制表的聚合</h4><p>利用网络地址的比特分布可以有效地进行分层配置。对内可以有多个子网掩码, 对外呈现的也是同一个网络的地址。通过路由信息的聚合可以有效的减少路由表的条目。</p>
<p>能够缩小路由表的大小是它的最大优势。路由表越大, 管理它所需要的内存和CPU也就越多, 并且查找路由表的时间也会越长, 导致转发IP数据包的性能下降, 构建大规模、高性能网络需要尽可能消减路由表的大小。</p>
<p>路由聚合可以将已知的路由信息传送给周围其他的路由器, 以达到控制路由信息的目的。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7uvgk5e6j30qk0rawlx.jpg" alt=""></p>
<h3 id="IP分割-构成处理"><a href="#IP分割-构成处理" class="headerlink" title="IP分割/构成处理"></a>IP分割/构成处理</h3><h4 id="数据链路与MTU"><a href="#数据链路与MTU" class="headerlink" title="数据链路与MTU"></a>数据链路与MTU</h4><p>每种数据链路的最大传输单元(MTU)都不尽相同, IP属于数据链路的上一层, 必须不受限与不同的数据链路的MTU大小。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi7v6x73o7j30ra0lk0wc.jpg" alt=""></p>
<h4 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h4><p>任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇见比较大的报文无法一下子发送出去的时候才会进行处理。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fiax7yl2avj30qo0j4wig.jpg" alt=""></p>
<p>由于以太网的默认MTU是1500字节, 因此4342字节的IP数据报无法再一个帧当中发送完成。因此, 路由器将IP数据报划分成了3个分片进行发送。经过分片之后的IP数据报在被重组的时候, 只能有目标主机进行, 路由器只做分片, 但不会进行重组。</p>
<h4 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h4><p>分片机制有它的不足。首先, 路由器的处理负荷加重。随着时代的变迁, 计算机网络的物理传输速度不断上升。这些高速的链路, 对路由器和计算机网络提出了更高的要求。另一方面, 随着人们对网络安全的要求提高, 路由器需要做的其他处理也越来越多, 因此, 只要允许, 是不希望由路由器进行IP数据包的分片处理。</p>
<p>路径MTU: 指的是从发送端主机到接收端主机之间不需要分片时的最大MTU大小。也就是, 路径中存在的所有数据链路中最小的传输单元。</p>
<p>路径MTU发现: 从发送端主机按照MTU的大小, 提前将数据报分片后进行发送。进行路径MTU发现, 就可以避免在路由器上进行分片处理。也可以在TCP中发送更大的包。很多操作系统都已经实现了路径MTU发现的功能。</p>
<p>路径MTU发现的工作原理: 首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1。根据这个标志位, 途中的路由器即使遇到需要分片才能处理的大包, 也不会去分片, 而是将包丢弃。随后, 通过ICMP的不可达消息将数据链路上的MTU的值给发送端主机。获得ICMP通知的MTU值后, 发送端主机将它设置为当前MTU。发送端主机根据当前新设置的MTU对数据报进行分片处理。如此反复, 直到数据报被发送到目标主机后, 没有在收到任何ICMP的回馈, 这样就认为最后一次ICMP通知的MTU值是一个合适的MTU值。MTU值最少可以缓存10分钟, 在这10分钟内使用刚刚得到的MTU, 超过10分钟以后则重新根据链路上的MTU做一次路径MTU发现。</p>
<ul>
<li><p>UDP<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fiayqntum4j30rm0mgn1l.jpg" alt=""></p>
</li>
<li><p>TCP<br><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fiaz65mq0xj30q00nqn1u.jpg" alt=""> </p>
</li>
</ul>
<p>参考:</p>
<ul>
<li><a href="">图解TCP/IP</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-数据链路层"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/12/13/数据链路层/">数据链路层(二)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/12/13/数据链路层/" class="article-date">
	  <time datetime="2015-12-12T16:00:00.000Z" itemprop="datePublished">2015-12-13</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路, 指OSI参考模型中的数据链路层, 有时也指以太网、无线局域网等通信手段。</p>
<p>数据链路层的协议定义了通过通信媒介互连的设备之间的传输规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外, 各个设备之间有时也会通过交换机、网桥中继器等中转数据。</p>
<p>OSI参考模型中数据链路层的相关技术包括MAC寻址(物理寻址)、介质共享、环路检测、虚拟局域网(VLAN)等。数据链路的传输方式有 以太网、无线局域网(WLAN), 点对点协议(PPP)。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址用于识别数据链路中互连的节点, 以太网或FDDI(光纤分布式数据接口)、无线LAN、蓝牙等设备根据相关规范使用MAC地址。</p>
<p>MAC地址长48比特, 在使用网卡的情况下, MAC地址一般都是会烧入ROM中。因此, 任何一个网卡的MAC地址都是唯一的。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7htb4xzcj30p00kmjul.jpg" alt=""></p>
<p>MAC地址中3~24位表示厂商识别码, 每个NIC厂商都有特定唯一的识别数字, 25~48位是厂商内部为识别每个网卡二用, 可以保证全世界不会有相同的MAC地址的网卡<br>IEEE802.3制定MAC地址规范时没有限定数据链路的类型, 即不论哪种数据链路的网络(以太网、FDDI、ATM、无线LAN、蓝牙等), 都不会有相同的MAC地址出现。</p>
<blockquote>
<p>例如一台主机是启动多个虚拟机, 由虚拟软件自己设定MAC地址给多个虚拟网卡, 这就很难保证所生成的MAC地址是唯一的。实际上, 即使MAC地址相同, 只要不是同属于一个数据链路就不会出现问题。</p>
</blockquote>
<h4 id="根据MAC地址转发"><a href="#根据MAC地址转发" class="headerlink" title="根据MAC地址转发"></a>根据MAC地址转发</h4><p>在使用同轴电缆的以太网等介质共享网络中, 同一时间只能有一台主机发送数据, 当连网的主机数量增加时, 通信性能会明显下降。若将集线器/集中器等设备以星型连接, 就出现了一款新的网络设备–交换集线器, 这是一种将非介质共享型网络中所使用的交换机用在以太网中的技术, 交换集线器也叫做以太网交换机。</p>
<p>以太网交换机就是持有多个端口的网桥。根据数据链路层中每个帧的目标MAC地址, 决定从哪个网络接口发送数据。所参考的, 用以记录发送接口的表叫做转发表。</p>
<p>转发表的内容不需要使用者在每个终端或交换机上手工设置, 而是可以自动生成。数据链路层的每个通过点在接到包时, 会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系一一记录到转发表。以某个MAC地址作为源地址的包由某一接口接收, 实质上可以理解为该MAC地址就是该接口的目标。因此也可以说, 以该MAC地址作为目标地址的包, 经由改接口送出即可。这一过程也叫自学过程。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fi7ij78o1qj30q40h0wi7.jpg" alt=""></p>
<p>由于MAC地址没有层次性, 转发表中的入口个数与整个数据链路中所有网络设备的数量有关。当设备数量增加时, 转发表也会随之变大, 检索转发表所用的时间也就越来越长。当连接多个终端时, 有必要将网络分成多个数据链路</p>
<blockquote>
<p>交换机转发方式有两种, 一种叫存储转发, 另一种叫直通转发。</p>
<p>存储转发方式检查以太网数据帧末尾的FCS位后在进行转发, 可以避免发送被破坏的帧或噪声导致的错误帧。</p>
<p>直通转发方式中不需要将整个帧全部接收下来以后再进行转发, 只需要得知目标地址即可开始转发。所以, 具有延迟较短的优势, 但是缺少了校验, 所以会导致有可能发送错误的帧。</p>
</blockquote>
<h4 id="环路检测技术"><a href="#环路检测技术" class="headerlink" title="环路检测技术"></a>环路检测技术</h4><p>通过网桥连接网络时, 一旦出现环路该如何处理? 这与网络的拓扑结构(总线型、环型、星型、混合型)和所使用的网桥种类有直接关系。最坏的情况下, 数据帧会在环路中被一而再再而三地持续转发, 而一旦这种数据帧越积越多将会导致网络瘫痪。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi7ixcwy4jj30lq0go76s.jpg" alt=""></p>
<p>解决网络中的环路问题。具体有生成树与源路由两种方式。</p>
<h5 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h5><p>每个网桥必须在1~10秒内互相交换BPDU包, 从而判断哪些端口使用, 哪些端口没有被使用, 以便消除环路。一旦发生故障, 则自动切换通信线路, 利用那些没有被使用的端口继续进行传输。</p>
<blockquote>
<p>生成树方法有一个弊端, 就是在发生故障切换网络时需要几十秒的时间。为了解决这个问题, 可以利用RSTP的方法, 将发生问题时的恢复时间缩短到几秒以内。</p>
</blockquote>
<h5 id="源路由法"><a href="#源路由法" class="headerlink" title="源路由法"></a>源路由法</h5><p>源路由法最早由IBM提出, 已解决令牌环网络的问题, 该方式可以判断发送数据的源地址是通过哪个网桥实现传输的, 并将帧写入RIF, 网桥则根据这个RIF信息发送帧给目标地址。因此, 及时网桥中出现了环路, 数据帧也不会被反复转发。</p>
<h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>在进行网络管理时候, 经常会遇到分散网络负载、变换部署网络设备的位置的情况; 因此, 有时候不得不修改网络的拓扑结构, 这也就意味着必须进行硬件线路的改造。然而, 如果采用带有VLAN技术的网桥, 就不用实际修改网络布线, 只需要修改网络的结构即可。VLAN技术附加到网桥/2层交换机上, 就可以切断所有VLAN之间的通信。相比于一般的网桥/2层交换机, VLAN可以过滤多余的包, 提高网络的承载效率。</p>
<h4 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h4><table>
<thead>
<tr>
<th>数据链路名称</th>
<th style="text-align:center">介质传输速率</th>
<th style="text-align:right">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>以太网</td>
<td style="text-align:center">10    Mbps~1000Gbps</td>
<td style="text-align:right">LAN、MAN</td>
</tr>
<tr>
<td>蓝牙</td>
<td style="text-align:center">5.5Mbps~150Mbps</td>
<td style="text-align:right">LAN</td>
</tr>
<tr>
<td>光纤通道</td>
<td style="text-align:center">133Mbps~4Gbps</td>
<td style="text-align:right">SAN</td>
</tr>
<tr>
<td>FDDI</td>
<td style="text-align:center">100Mbps</td>
<td style="text-align:right">LAN、MAN</td>
</tr>
<tr>
<td>IEEE1394</td>
<td style="text-align:center">100Mbps~800Mbps</td>
<td style="text-align:right">面向家庭</td>
</tr>
<tr>
<td>HtPPI</td>
<td style="text-align:center">800Mbps、1.6Gbps</td>
<td style="text-align:right">两台计算机之间的连接</td>
</tr>
<tr>
<td>令牌环</td>
<td style="text-align:center">4Mbps、16Mbps</td>
<td style="text-align:right">LAN</td>
</tr>
<tr>
<td>ATM</td>
<td style="text-align:center">25Mbps、155Mbps、622Mbps、2.4GHz</td>
<td style="text-align:right">LAN ~WAN</td>
</tr>
</tbody>
</table>
<p>参考:</p>
<ul>
<li><a href="">图解TCP/IP</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-TCP:IP协议分层模型"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/11/28/TCP:IP协议分层模型/">TCP/IP协议分层模型(一)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/11/28/TCP:IP协议分层模型/" class="article-date">
	  <time datetime="2015-11-27T16:00:00.000Z" itemprop="datePublished">2015-11-28</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="TCP-IP协议分层模型"><a href="#TCP-IP协议分层模型" class="headerlink" title="TCP/IP协议分层模型"></a>TCP/IP协议分层模型</h2><p>TCP/IP是目前计算机网络中使用最为广泛的协议;下面介绍一下TCP/IP协议分层模型。</p>
<h4 id="1-TCP-IP与OSI参考模型"><a href="#1-TCP-IP与OSI参考模型" class="headerlink" title="1.TCP/IP与OSI参考模型"></a>1.TCP/IP与OSI参考模型</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi6m4o06c8j30ku0kujub.jpg" alt=""></p>
<h5 id="物理层-硬件"><a href="#物理层-硬件" class="headerlink" title="物理层(硬件)"></a>物理层(硬件)</h5><p>物理层: 负责0、1比特流与电压的高低、灯的闪灭之间的呼唤。对应TCP/IP分层模型中的硬件层;这种硬件相当于<code>以太网</code>或<code>电话线路</code>等物理设备。</p>
<h5 id="数据链路层-网卡层"><a href="#数据链路层-网卡层" class="headerlink" title="数据链路层(网卡层)"></a>数据链路层(网卡层)</h5><p>网络接口层利用以太网中的数据链路层进行通信, 属于接口层。也就是说, 把它当做是让网卡(NIC)起作用的驱动程序; 驱动程序是在操作系统与硬件之间起桥梁作用的软件,也就是说, 想要使用这些硬件, 需要安装对应的驱动软件。</p>
<blockquote>
<p>现在很多计算机的操作系统中已经内置安装好了对应的网卡驱动程序, 可以实现即插即拔。</p>
</blockquote>
<h5 id="网络层-互联网层"><a href="#网络层-互联网层" class="headerlink" title="网络层(互联网层)"></a>网络层(互联网层)</h5><p>网络层使用IP协议, IP协议基于IP地址转发分包数据。就是将分组数据包发送到目的主机, 通过互联网层, 可以抽象甚至忽略网络结构的细节(忽略更底层的网络结构)。<br>连接互联网的所有主机跟路由器都必须实现IP的功能; 网桥、中继器、集线器不一定要实现TCP/TP功能。</p>
<blockquote>
<ul>
<li>IP是跨越网络来传送数据包, 使整个互联网都能收到数据的协议; IP协议使用IP地址作为主机的标识。通过IP, 相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信, 它不具备重发的机制(TCP控制重发), 属于非可靠性传输协议。</li>
<li>ICMP协议规定：目的主机必须返回ICMP回送应答消息(ACK)给发送主机。如果源主机在一定时间内收到应答，则认为主机可达。(ping 用的就是ICMP协议)。</li>
<li>ARP 从分组数据包中的IP地址中解析出MAC地址的一种协议。</li>
</ul>
</blockquote>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层最主要的功能就是能够让<code>应用程序</code>之间实现通信。计算机内部通常运行着多个程序, 基于端口号区分哪些程序与哪些程序在进行通信,传输侧有两个代表性的协议TCP/UPD。</p>
<blockquote>
<ul>
<li>TCP 是一种面向有连接的可靠的传输层的协议。它可以保证两端主机的通信可达。TCP能够正确处理在传输过程中的丢包、传输顺序乱掉的异常的情况, 还能够有效的利用带宽, 缓解网络的拥堵。</li>
<li>UDP 是一种面向无连接的不可靠的传输层协议。UDP不会关注对端是否接收到了数据, 常用于多播、广播通信以及视频通信等多媒体领域(UDP + RTP/RTCP/RTMP)</li>
</ul>
</blockquote>
<h5 id="应用层-会话层以上的分层"><a href="#应用层-会话层以上的分层" class="headerlink" title="应用层(会话层以上的分层)"></a>应用层(会话层以上的分层)</h5><p>TCP/IP分层中, 将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。文件传输(FTP), 远程登录(TENNET/SSH), 网络管理(SNMP)</p>
<h4 id="2-网络构成要素"><a href="#2-网络构成要素" class="headerlink" title="2.网络构成要素"></a>2.网络构成要素</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fi6mvb6huzj30u40ji0x2.jpg" alt=""></p>
<h5 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h5><p>任一计算机联网时, 都必须要使用网卡(NIC)/LAN卡/网络适配器。很多计算机都内置了LAN端口, 说明计算机在出厂设置中就具备了以太网的端口。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi6n1y5igjj30ke08uq44.jpg" alt=""></p>
<h5 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h5><p>中继器(Repeater)是在物理层面上延长网络的设备。由电缆传过来的电信号/光信号经由中继器的波形调整和放大再传给另一个电缆。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi6n4daoa2j30qc0butaq.jpg" alt=""></p>
<p>通过中继器而进行的网络延长, 其距离也并非可以无限扩大; 例如一个10Mbps的以太网最多可以用4个中继器分段连接, 而一个100Mbps的以太网则对多只能连接两个中继器。</p>
<blockquote>
<p>有些中继器可以提供多个端口服务, 这种中继器被称为中继集线器/集线器/Hub。因此, 集线器也可以看作是多个中继器, 每个端口都可以成为一个中继器。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fi6n905ifxj30ro07qgnb.jpg" alt=""></p>
</blockquote>
<h5 id="网桥-2层交换机"><a href="#网桥-2层交换机" class="headerlink" title="网桥/2层交换机"></a>网桥/2层交换机</h5><p>网桥能够识别数据链路中的数据帧, 并将这些数据帧临时存储于内存, 再重新生成信号作为一个全新的帧转发给相连的另一个网段, 由于能够存储这些数据帧, 网桥能够连接传输速率完全不同的数据链路, 并且不限制连接网段的个数。<br>数据链路的数据帧中有一个数据位叫做FCS, 用以校验数据是否正确送到目的地。网桥通过检查这个域中的值, 将那些损坏的数据丢弃, 从而避免发送给其他网段。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi6nigswu6j30q60bugnw.jpg" alt=""></p>
<blockquote>
<p>以太网中使用的交换集线器, 基本也属于网桥的一种, 交换集线器中连接电缆的每个端口都能提供类似网桥的功能。</p>
</blockquote>
<h5 id="路由器-3层交换机"><a href="#路由器-3层交换机" class="headerlink" title="路由器/3层交换机"></a>路由器/3层交换机</h5><p>路由器是在网络层面上连接两个网络、并对分组数据报文进行转发的设备。网桥是根据MAC地址进行处理, 而路由器/3层交换机则是根据IP地址进行处理的。因此, TCP/IP中网络层的地址就成为了IP地址。</p>
<p>路由器可以连接不同的数据链路。例如连接两个以太网, 或者连接一个以太网与一个FDDI。家/办公室使用的宽带路由器也是路由器的一种。路由器还有分担网络负责的作用, 甚至具有网络安全的功能。<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fi6npqutmqj30ra0a276d.jpg" alt=""></p>
<h5 id="4-7层交换机"><a href="#4-7层交换机" class="headerlink" title="4~7层交换机"></a>4~7层交换机</h5><p>4~7层交换机负责处理从传输层到应用层的数据。以TCP等协议的传输层及其上面的应用层为基础, 分析收发数据, 并对其进行特定的处理。4~7层交换机的可以进行带宽控制, 优先处理对实时性要求较高的通信请求, 放缓处理像邮件或数据转发等稍有延迟也并无大碍的通信请求。负载均衡器、广域网加速器、防火墙等都是是4~7层交换机的一中。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fi6nqrg0vaj30l40923zp.jpg" alt=""></p>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p>网关负责处理传输层到应用层的数据进行转换和转发的设备。与4~7层交换机一样都是处理传输层及以上的数据, 但是网关不仅转发数据还负责对数据进行<strong>转换</strong>,通常会使用一个表示层或应用层网关, 在两个不能直接进行通信的协议之间进行翻译, 实现两端的通信。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fi6nx1wg8mj30pc094403.jpg" alt=""></p>
<blockquote>
<p>代理服务器可以控制网络流量和安全, 属于网关的一种</p>
</blockquote>
<p>参考:</p>
<ul>
<li><a href="">图解TCP/IP</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-谁动了我的奶酪"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/11/23/谁动了我的奶酪/">谁动了我的奶酪</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/11/23/谁动了我的奶酪/" class="article-date">
	  <time datetime="2015-11-22T16:00:00.000Z" itemprop="datePublished">2015-11-23</time>
	</a>

      
    <a class="article-category-link" href="/categories/阅读/">阅读</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h3><p>临出发,想起老大赠送的一本书,<strong>《谁动了我的奶酪》</strong>, 于是乎悄然翻起了这本书…</p>
<p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f92l4z7bh0j20jg0r476p.jpg" alt=""></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>《谁动了我的奶酪》写的是个可爱的寓言故事,每页都配有主人翁滑稽可爱个性鲜明的漫画形象。书中主要讲述4个“人物”：两只小老鼠“嗅嗅”、“匆匆”和两个小矮人“哼哼”、“唧唧”。他们生活在一个迷宫里,奶酪是他们要追寻的东西。有一天,他们同时发现了一个储量丰富的奶酪仓库,便在其周围构筑起自己的幸福生活。很久之后的某天,奶酪突然不见了！这个突如其来的变化使他们的心态暴露无疑：嗅嗅,匆匆随变化而动,立刻穿上始终挂在脖子上的鞋子,开始出去再寻找,并很快就找到了更新鲜更丰富的奶酪；两个小矮人哼哼和唧唧面对变化却犹豫不决,烦恼丛生,始终无法接受奶酪已经消失的残酷现实.经过激烈的思想斗争,唧唧终于冲破了思想的束缚,穿上久置不用的跑鞋,重新进入漆黑的迷宫,并最终找到了更多更好的奶酪,而哼哼却仍在对苍天的追问中郁郁寡欢……<br><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f92merin9uj20fw0ivacv.jpg" alt=""></p>
<h3 id="留言墙"><a href="#留言墙" class="headerlink" title="留言墙"></a>留言墙</h3><p>在这本书中，有很多的至理名言，也有很多发人深思的地方，把他们摘抄下来，时常警醒懒惰的自己：</p>
<ul>
<li><p>如果不改变，就会被淘汰<br><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f92lmzwj3qj209x0euwgk.jpg" alt=""></p>
</li>
<li><p>经常闻闻你的奶酪，你就会知道它什么时候开始变质<br><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f92mfp9dcij209s0epmzb.jpg" alt=""></p>
</li>
<li><p>当你客服了自己的恐惧时，你就会感到轻松自在<br><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f92mghf4mij209z0f3tax.jpg" alt=""></p>
</li>
<li><p>在发现奶酪之前，想象正在享受奶酪，会帮自己找到新的奶酪<br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f92mh5voh6j209x0f0dhq.jpg" alt=""></p>
</li>
<li><p>越早放弃旧的奶酪，就越早发现新的奶酪<br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f92mhr471oj20a10estap.jpg" alt=""></p>
</li>
<li><p>在迷宫中搜索比停留在没有奶酪的地方更安全<br><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f92mi1vwn7j209z0f140n.jpg" alt=""></p>
</li>
<li><p>抛弃旧的观念, 才能找到新的奶酪<br><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f92mijquxfj20a40ey768.jpg" alt=""></p>
</li>
<li><p>只要相信自己能够找到并且享用新的奶酪,你就会改变自己的行为<br><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f92mjjvysbj20a10f0dhv.jpg" alt=""></p>
</li>
<li><p>及早注意细小的变化，这会有助于你适应即将来临的大变化<br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f92mkocnotj20a20f1wgc.jpg" alt=""></p>
</li>
</ul>
<h3 id="小悟"><a href="#小悟" class="headerlink" title="小悟"></a>小悟</h3><p>当我们在为自己的事业,生活做出选择时,必须充分地热爱自己喜欢干的事,热爱才会努力去钻研,努力钻研必会有作为;选择自己有能力干的事,选择一经确定,就要弃而不舍地去奋斗,从一点一滴做起,从最小的事做起,努力做到最好,在这个过程中增长才干,树立信心。久而久之,必定会有所作为,有所发展,有所创造！</p>
<p>我们要记住：别人仍会不断地拿走你的“奶酪”，所以我们要做好迅速改变的准备，不断地去适应变化、享受变化。</p>
<p>《谁动了我的奶酪》告诉我一个最简单的应对方法,那就是把跑鞋挂在脖子上,时刻准备穿上它,在千变万化的世界里奔跑追寻,去追寻其他更新鲜的奶酪……</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f92mov6iihj20g50itq5x.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/寓言故事/">寓言故事</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-3D轮播图"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/09/24/3D轮播图/">3D轮播图</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/09/24/3D轮播图/" class="article-date">
	  <time datetime="2015-09-23T16:00:00.000Z" itemprop="datePublished">2015-09-24</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在开发一些项目的首页,或者需要信息展示类界面的时候,往往需要用到轮播图效果. 常见的轮播图都是以2D的形式, 平面展示, 对于3D旋转的的轮播图, 又应该如何实现.</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1f95v7bv7dzj308g04rweq.jpg" alt=""></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>2D轮播图</p>
<ul>
<li>一种是利用collectionView实现无限滚动,因为collectionView本身存在着复用的问题,所以不用担心内存的消耗问题.</li>
<li>另外一种就是基于scrollView来实现, 比如我们现在有5张图片.最简单的就是我们直接创建5+2个，也就是7个imageView.而我们的存放顺序为，图片5，图片1、图片2、图片3、图片4、图片5、图片1。默认显示第2张（图片1,一直向右滑动到第6张（图片5),再向右滑动显示第7张（图片1）显示完成后,将UIScrollView的contentOffset设置到第2个imageView上（图片1,这时候便可继续向右滑动实现循环的效果;同理，向左滑动时,滑动到第1张（图片5）后,将UIScrollView的contentOffset设置到第6个imageView上（图片5),这样便可以继续向左滑动实现循环效果.</li>
</ul>
</li>
<li><p>3D轮播图</p>
<ul>
<li><p>首先, 3D翻转效果, 我们会想到可能会与动画相关, 这种轮播图的切换有点类似转场动画(CATransition), 我们去查一下CATransition相关资料, 发现其type有一个<strong>cube</strong>属性有3D翻滚的效果.接下来, 直接上代码看看.</p>
<p>  <img src="http://ww1.sinaimg.cn/large/006y8lVagw1f95vtsso7fj30fr09aq3w.jpg" alt=""></p>
</li>
</ul>
</li>
</ul>
<h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><ul>
<li>创建一个imageView, 用来装载图片, 实现图片的3D翻转, 就是给当前这个imageView添加3D动画后.在将里面的image给替换.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIImageView *)imageV</div><div class="line">&#123;</div><div class="line">    if (!_imageV) &#123;</div><div class="line">        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, Width, Height)];</div><div class="line">        imageView.backgroundColor = [UIColor lightGrayColor];</div><div class="line">        imageView.userInteractionEnabled = YES;</div><div class="line">        _imageV = imageView;</div><div class="line">        [self addSubview:_imageV];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _imageV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置imageView的默认图片为第一张图, 并给当前视图添加向左和向右轻扫的手势.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">        </div><div class="line">UISwipeGestureRecognizer *rightRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromRight)];</div><div class="line">[rightRe setDirection:UISwipeGestureRecognizerDirectionLeft];</div><div class="line">        </div><div class="line">UISwipeGestureRecognizer *leftRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromLeft)];</div><div class="line">[leftRe setDirection:UISwipeGestureRecognizerDirectionRight];</div><div class="line">        </div><div class="line">[self.imageV addGestureRecognizer:rightRe];</div><div class="line">[self.imageV addGestureRecognizer:leftRe];</div></pre></td></tr></table></figure>
<ul>
<li>添加pageControl, 用以显示当前图片的index</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (UIPageControl *)pageControl</div><div class="line">&#123;</div><div class="line">    if (!_pageControl) &#123;</div><div class="line">        UIPageControl *pageControl = [[UIPageControl alloc] init];</div><div class="line">        pageControl.numberOfPages = self.imagArr.count;</div><div class="line">        CGSize size = [pageControl sizeForNumberOfPages:self.imagArr.count];</div><div class="line">        pageControl.frame = CGRectMake(0, 0, size.width, size.height);</div><div class="line">        pageControl.center = CGPointMake(self.center.x, Height-10);</div><div class="line">        pageControl.currentPageIndicatorTintColor = [UIColor whiteColor];</div><div class="line">        pageControl.pageIndicatorTintColor = [UIColor grayColor];</div><div class="line">        _pageControl = pageControl;</div><div class="line">        [self addSubview:_pageControl];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _pageControl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加定时器, 让imageView按照一定的节奏, 自动轮播.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSTimer *)timer</div><div class="line">&#123;</div><div class="line">    if (!_timer) &#123;</div><div class="line">        _timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(swipFromRight) userInfo:nil repeats:YES];</div><div class="line">        [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _timer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>NSRunLoopCommonModes: 不受当前线程的影响.</p>
</blockquote>
<ul>
<li>实现监听方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (void)swipFromRight</div><div class="line">&#123;</div><div class="line">    self.currentPage++;</div><div class="line">    if (self.currentPage &gt;= self.imagArr.count) self.currentPage = 0;</div><div class="line">    self.pageControl.currentPage = self.currentPage;</div><div class="line">    </div><div class="line">    self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">    </div><div class="line">    CATransition *transition = [[CATransition alloc] init];</div><div class="line">    transition.type = @&quot;cube&quot;;</div><div class="line">    transition.subtype = kCATransitionFromRight;</div><div class="line">    transition.duration = 1.5;</div><div class="line">    transition.delegate = self;</div><div class="line">    [self.imageV.layer addAnimation:transition forKey:nil];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swipFromLeft</div><div class="line">&#123;</div><div class="line">    self.currentPage--;</div><div class="line">    if (self.currentPage &lt; 0) self.currentPage = self.imagArr.count -1;</div><div class="line">    self.pageControl.currentPage = self.currentPage;</div><div class="line">    </div><div class="line">    self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">    </div><div class="line">    CATransition *transition2 = [[CATransition alloc] init];</div><div class="line">    transition2.type = @&quot;cube&quot;;</div><div class="line">    transition2.subtype = kCATransitionFromLeft;</div><div class="line">    transition2.duration = 1.5;</div><div class="line">    transition2.delegate = self;</div><div class="line">    [self.imageV.layer addAnimation:transition2 forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>核心动画, 都是添加到视图的layer上.</p>
</blockquote>
<p>这样之后, 还会有问题, 例如:3秒切换一张图片, 当2.9秒的时候, 手动切换了新的图片, 在0.1秒后, 定时器又会帮我们自动切换一张新的图片. 我们想做到, 当手动切换图片后, 仍然需要等待3秒, 定时器才会自动切换下一张图片.我们监听CAAnimationDelegate方法:<strong>animationDidStart:</strong> 和<strong>animationDidStop:</strong></p>
<blockquote>
<p>CAAnimation在分类中定义了代理方法,是给NSObject添加的分类,所以任何对象,成为CAAnimation的代理,都可以。</p>
</blockquote>
<ul>
<li>动画开始时候调用animationDidStart:, 禁用交互</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)animationDidStart:(CAAnimation *)anim</div><div class="line">&#123;</div><div class="line">    if (self.timer) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.imageV.userInteractionEnabled = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>动画停止的时候调用animationDidStop:, 开启交互, 重置timer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    if (self.timer) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">        </div><div class="line">        [self timer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.imageV.userInteractionEnabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从外部传入需要浏览的图片数组, 设置frame即可.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LCBannerView *banerV = [[LCBannerView alloc] initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width, 180) imageArray:@[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]];</div><div class="line">[self.view addSubview:banerV];</div></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface LCBannerView : UIView</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame imageArray:(NSArray *)imageArray;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line">#import &quot;LCBannerView.h&quot;</div><div class="line"></div><div class="line">#define Width self.frame.size.width</div><div class="line">#define Height self.frame.size.height</div><div class="line"></div><div class="line">@interface LCBannerView ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) UIImageView *imageV;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSArray *imagArr;</div><div class="line"></div><div class="line">@property (nonatomic, weak) UIPageControl *pageControl;</div><div class="line"></div><div class="line">@property (nonatomic, assign) NSInteger currentPage;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LCBannerView</div><div class="line">#pragma mark -lazy</div><div class="line">- (UIImageView *)imageV</div><div class="line">&#123;</div><div class="line">    if (!_imageV) &#123;</div><div class="line">        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, Width, Height)];</div><div class="line">        imageView.backgroundColor = [UIColor lightGrayColor];</div><div class="line">        imageView.userInteractionEnabled = YES;</div><div class="line">        _imageV = imageView;</div><div class="line">        [self addSubview:_imageV];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _imageV;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSTimer *)timer</div><div class="line">&#123;</div><div class="line">    if (!_timer) &#123;</div><div class="line">        _timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(swipFromRight) userInfo:nil repeats:YES];</div><div class="line">        [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _timer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UIPageControl *)pageControl</div><div class="line">&#123;</div><div class="line">    if (!_pageControl) &#123;</div><div class="line">        UIPageControl *pageControl = [[UIPageControl alloc] init];</div><div class="line">        pageControl.numberOfPages = self.imagArr.count;</div><div class="line">        CGSize size = [pageControl sizeForNumberOfPages:self.imagArr.count];</div><div class="line">        pageControl.frame = CGRectMake(0, 0, size.width, size.height);</div><div class="line">        pageControl.center = CGPointMake(self.center.x, Height-10);</div><div class="line">        pageControl.currentPageIndicatorTintColor = [UIColor whiteColor];</div><div class="line">        pageControl.pageIndicatorTintColor = [UIColor grayColor];</div><div class="line">        _pageControl = pageControl;</div><div class="line">        [self addSubview:_pageControl];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return _pageControl;</div><div class="line">&#125;</div><div class="line">#pragma mark -lifeCycle</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame imageArray:(NSArray *)imageArray</div><div class="line">&#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        self.currentPage = 0;</div><div class="line">        self.imagArr = imageArray;</div><div class="line">        self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">        </div><div class="line">        UISwipeGestureRecognizer *rightRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromRight)];</div><div class="line">        [rightRe setDirection:UISwipeGestureRecognizerDirectionLeft];</div><div class="line">        </div><div class="line">        UISwipeGestureRecognizer *leftRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromLeft)];</div><div class="line">        [leftRe setDirection:UISwipeGestureRecognizerDirectionRight];</div><div class="line">        </div><div class="line">        [self.imageV addGestureRecognizer:rightRe];</div><div class="line">        [self.imageV addGestureRecognizer:leftRe];</div><div class="line">        </div><div class="line">        [self timer];</div><div class="line">        [self pageControl];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swipFromRight</div><div class="line">&#123;</div><div class="line">    self.currentPage++;</div><div class="line">    if (self.currentPage &gt;= self.imagArr.count) self.currentPage = 0;</div><div class="line">    self.pageControl.currentPage = self.currentPage;</div><div class="line">    </div><div class="line">    self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">    </div><div class="line">    CATransition *transition = [[CATransition alloc] init];</div><div class="line">    transition.type = @&quot;cube&quot;;</div><div class="line">    transition.subtype = kCATransitionFromRight;</div><div class="line">    transition.duration = 1.5;</div><div class="line">    transition.delegate = self;</div><div class="line">    [self.imageV.layer addAnimation:transition forKey:nil];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)swipFromLeft</div><div class="line">&#123;</div><div class="line">    self.currentPage--;</div><div class="line">    if (self.currentPage &lt; 0) self.currentPage = self.imagArr.count -1;</div><div class="line">    self.pageControl.currentPage = self.currentPage;</div><div class="line">    </div><div class="line">    self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]];</div><div class="line">    </div><div class="line">    CATransition *transition2 = [[CATransition alloc] init];</div><div class="line">    transition2.type = @&quot;cube&quot;;</div><div class="line">    transition2.subtype = kCATransitionFromLeft;</div><div class="line">    transition2.duration = 1.5;</div><div class="line">    transition2.delegate = self;</div><div class="line">    [self.imageV.layer addAnimation:transition2 forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark -CAAnimationDelegate</div><div class="line">- (void)animationDidStart:(CAAnimation *)anim</div><div class="line">&#123;</div><div class="line">    if (self.timer) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.imageV.userInteractionEnabled = NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    if (self.timer) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">        </div><div class="line">        [self timer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.imageV.userInteractionEnabled = YES;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>可以提供更多的属性和方式,例如:利用KVC可以设置currentPageIndicatorTintColor为图片等. 可以提供网络图片,和监听imageView的点击.可以将”cube”替换成”fade”效果等等,有需要的看官可以自行封装.<br>代码不多, demo就不发了.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animation/">animation</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-封装tabBar"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/07/10/封装tabBar/">封装 tabBar</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/07/10/封装tabBar/" class="article-date">
	  <time datetime="2015-07-09T16:00:00.000Z" itemprop="datePublished">2015-07-10</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h3 id="自定义TabBarController"><a href="#自定义TabBarController" class="headerlink" title="自定义TabBarController"></a>自定义TabBarController</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">自定义继承于UITabBarController</div><div class="line">利用KVC 替换系统的tabBar</div><div class="line">利用appearance 全局统一设置UITabBarItem</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self setValue:[[LCTabBar alloc] init] forKeyPath:@&quot;tabBar&quot;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];</div><div class="line"> normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor]; normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:12];</div><div class="line"></div><div class="line"> NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];</div><div class="line">  selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];</div><div class="line">   </div><div class="line">UITabBarItem *item = [UITabBarItem appearance];</div><div class="line"> [item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];</div><div class="line"> [item setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];</div></pre></td></tr></table></figure>
<h3 id="自定义tabBar"><a href="#自定义tabBar" class="headerlink" title="自定义tabBar"></a>自定义tabBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">自定义继承于UITabBar</div><div class="line">初始化</div><div class="line">布局</div></pre></td></tr></table></figure>
<h4 id="中间有线条的tabBar"><a href="#中间有线条的tabBar" class="headerlink" title="中间有线条的tabBar"></a>中间有线条的tabBar</h4><p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f94iwf1y9ij30m305m3z5.jpg" alt=""></p>
<p>解决方案: 布局子控件地方, 将中间按钮 bringSubviewToFront</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)layoutSubviews</div><div class="line">&#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    </div><div class="line">    CGFloat width = self.width;</div><div class="line">    CGFloat height = self.height;</div><div class="line">    </div><div class="line">    self.plusButton.center = CGPointMake(width * 0.5, height * 0.5);</div><div class="line">    self.plusButton.y = -20;</div><div class="line">    </div><div class="line">    int index = 0;</div><div class="line">    </div><div class="line">    CGFloat tabBarButtonW = width / 5;</div><div class="line">    CGFloat tabBarButtonH = height;</div><div class="line">    CGFloat tabBarButtonY = 0;</div><div class="line"></div><div class="line">    for (UIView *tabBarButton in self.subviews) &#123;</div><div class="line">        if (![NSStringFromClass(tabBarButton.class) isEqualToString:@&quot;UITabBarButton&quot;]) continue;</div><div class="line">        </div><div class="line">        </div><div class="line">        CGFloat tabBarButtonX = index * tabBarButtonW;</div><div class="line">        if (index &gt;= 2) &#123;</div><div class="line">            tabBarButtonX += tabBarButtonW;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        tabBarButton.frame = CGRectMake(tabBarButtonX, tabBarButtonY, tabBarButtonW, tabBarButtonH);</div><div class="line">        </div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [self bringSubviewToFront:self.plusButton];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="中间按钮-超出tabBar的范围不能响应点击事件"><a href="#中间按钮-超出tabBar的范围不能响应点击事件" class="headerlink" title="中间按钮 超出tabBar的范围不能响应点击事件"></a>中间按钮 超出tabBar的范围不能响应点击事件</h4><p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1f94ixfcnyjj30m607cjsb.jpg" alt=""></p>
<p>解决方案: 重写系统的hitTest方法, 不了解的看官可以去查查事件传递和响应者链条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    </div><div class="line">    if (self.isHidden == NO) &#123; // 当前界面 tabBar显示</div><div class="line">        </div><div class="line">        CGPoint newPoint = [self convertPoint:point toView:self.plusButton];</div><div class="line">        </div><div class="line">        if ( [self.plusButton pointInside:newPoint withEvent:event]) &#123; // 点 属于按钮范围</div><div class="line">            return self.plusButton;</div><div class="line">            </div><div class="line">        &#125;else&#123;</div><div class="line">            return [super hitTest:point withEvent:event];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return [super hitTest:point withEvent:event];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>当然也可以去除tabBar上的线条 , 设置ShadowImage属性, 导航栏同理<br>[self.tabBarController.tabBar setBackgroundImage:[UIImage new]];<br>[self.tabBarController.tabBar setShadowImage:[UIImage new]];</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="[post]-runloop浅说"  class="article article-type-[post]" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2015/05/05/runloop浅说/">runloop理论</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2015/05/05/runloop浅说/" class="article-date">
	  <time datetime="2015-05-04T16:00:00.000Z" itemprop="datePublished">2015-05-05</time>
	</a>

      
    <a class="article-category-link" href="/categories/iOS/">iOS</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="RunLoop基本概念"><a href="#RunLoop基本概念" class="headerlink" title="RunLoop基本概念"></a>RunLoop基本概念</h2><p>概念:程序的运行循环,通俗的来说就是跑圈.</p>
<h3 id="基本作用（作用重大）"><a href="#基本作用（作用重大）" class="headerlink" title="基本作用（作用重大）"></a>基本作用（作用重大）</h3><ul>
<li>保持程序的持续运行(ios程序为什么能一直活着不会死) </li>
<li>处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） </li>
<li>节省CPU资源，提高程序性能，有事情就做事情，没事情就休息</li>
</ul>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><ul>
<li>如果没有Runloop,那么程序一启动就会退出，什么事情都做不了。 </li>
<li>如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行</li>
</ul>
<h3 id="main函数中的Runloop"><a href="#main函数中的Runloop" class="headerlink" title="main函数中的Runloop"></a>main函数中的Runloop</h3><ul>
<li>在UIApplication函数内部就启动了一个Runloop,该函数返回一个int类型的值 </li>
<li>这个默认启动的Runloop是跟主线程相关联的</li>
</ul>
<h3 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h3><ul>
<li>在iOS开发中有两套api来访问Runloop <ul>
<li>第一种:foundation框架【NSRunloop】 </li>
<li>第二种:core foundation框架【CFRunloopRef】 </li>
</ul>
</li>
<li>NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 </li>
<li>NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</li>
</ul>
<h3 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h3><ul>
<li>Runloop和线程的关系：一个Runloop对应着一条唯一的线程 </li>
</ul>
<p><strong>如何让子线程不死</strong></p>
<ul>
<li>给这条子线程开启一个Runloop </li>
<li>Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 </li>
<li>Runloop的生命周期：在第一次获取时创建，在线程结束时销毁 </li>
<li>拿到当前应用程序的主Runloop（主线程对应的Runloop）</li>
</ul>
<p>方法一: NSRunloop</p>
<pre><code>NSRunLoop * runloop1 = [NSRunLoop mainRunLoop];
</code></pre><p>方法二: CFRunLoopRef<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFRunLoopRef runloop2 =   CFRunLoopGetMain();</div></pre></td></tr></table></figure></p>
<ul>
<li>注意：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。</li>
</ul>
<h2 id="Runloop运行原理"><a href="#Runloop运行原理" class="headerlink" title="Runloop运行原理"></a>Runloop运行原理</h2><h3 id="苹果官方的运行原理图"><a href="#苹果官方的运行原理图" class="headerlink" title="苹果官方的运行原理图"></a>苹果官方的运行原理图</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79gw1f9bxanqbzej30g708vjs8.jpg" alt=""></p>
<h3 id="Runloop和相关类之间的关系图"><a href="#Runloop和相关类之间的关系图" class="headerlink" title="Runloop和相关类之间的关系图"></a>Runloop和相关类之间的关系图</h3><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gw1f9bxfzud7qj30fn0bk0tx.jpg" alt=""></p>
<h3 id="RunLoop五个相关的类"><a href="#RunLoop五个相关的类" class="headerlink" title="RunLoop五个相关的类"></a>RunLoop五个相关的类</h3><ul>
<li>CFRunloopRef</li>
<li>CFRunloopModeRef【Runloop的运行模式】</li>
<li>CFRunloopSourceRef【Runloop要处理的事件源】</li>
<li>CFRunloopTimerRef【Timer事件】</li>
<li>CFRunloopObserverRef【Runloop的观察者（监听者）】</li>
</ul>
<h4 id="CFRunloopRef"><a href="#CFRunloopRef" class="headerlink" title="CFRunloopRef"></a>CFRunloopRef</h4><ul>
<li>CFRunloopModeRef代表着Runloop的运行模式 </li>
<li>一个Runloop中可以有多个mode,一个mode里面又可以有多个 source/observer/timer等等 </li>
<li>每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode </li>
<li>如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入 </li>
<li>这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响 </li>
<li>系统默认注册了5个mode <ul>
<li>第一种模式: kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 </li>
<li>第二种模式: UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 </li>
<li>第三种模式: UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 </li>
<li>第四种模式: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 </li>
<li>第五种模式: kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode</li>
</ul>
</li>
</ul>
<h4 id="CFRunloopTimerRef"><a href="#CFRunloopTimerRef" class="headerlink" title="CFRunloopTimerRef"></a>CFRunloopTimerRef</h4><ul>
<li>runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就不会参与。一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。 </li>
<li>它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer . </li>
<li>NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，和runloop的运行模式kCFRunLoopDefaultMode<br>有时候需要修改模式,达到类似在后台持续运行的效果,不受外界的影响</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h4 id="CFRunloopSourceRef"><a href="#CFRunloopSourceRef" class="headerlink" title="CFRunloopSourceRef"></a>CFRunloopSourceRef</h4><ul>
<li><p>事件源也就是输入源，有两种分类模式； </p>
<ul>
<li>一种是按照苹果官方文档进行划分的 </li>
<li>另一种是基于函数的调用栈来进行划分的（source0和source1）。 </li>
</ul>
</li>
<li><p>苹果官方文档</p>
<ul>
<li>Port-Based Sources </li>
<li>Custom Input Sources </li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li><p>函数的调用栈</p>
<ul>
<li>Source0：非基于Port的 </li>
<li>Source1：基于Port的</li>
</ul>
</li>
</ul>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><ul>
<li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个runloop监听者</div><div class="line"> CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, </div><div class="line">YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; </div><div class="line">NSLog(@”监听runloop状态改变—%zd”,activity); &#125;); //为runloop添加一个监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, </div><div class="line">kCFRunLoopDefaultMode); CFRelease(observer);</div></pre></td></tr></table></figure>
<ul>
<li>监听的状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; </div><div class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Runloop </div><div class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimer </div><div class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Sources </div><div class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 </div><div class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 </div><div class="line">kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloop </div><div class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变 &#125;;</div></pre></td></tr></table></figure>
<h2 id="RunLoop运行逻辑"><a href="#RunLoop运行逻辑" class="headerlink" title="RunLoop运行逻辑"></a>RunLoop运行逻辑</h2><p><img src="http://ww4.sinaimg.cn/large/006y8mN6gw1f9bxl6gospj30gd0c4767.jpg" alt=""></p>
<ul>
<li>一个线程对应一个runLoop,主线程的runloop是程序一启动,默认就创建一个runloop,创建好了之后就会给它添加一些默认的模式,每个模式里面会有很多的 source /timer/observer ,添加好这些模式后,observer就会监听主线程的runloop,进入runloop后,就开始处理事件,先处理timer,再处理source0,source0处理完之后再处理source1,当把这些所有的事件反复的处理完之后,如果没有事件了,那么runloop就会进入睡眠状态,当用户又触发了新的事件,就会唤醒runloop,唤醒runloop后回到第二步,重新处理新的timer,新的source0,新的source1,处理完后就睡眠,一直反复,当我们把程序关闭或者强退,这个时候observer就会监听都runloop退出了.</li>
</ul>
<ul>
<li><p>observer是监听runloop的状态.</p>
</li>
<li><p>timer / source/<br>CFRunLoopRef创建一个timer必须添加到runloop 才会执行,添加的时候要指定模式 default模式 ,不对程序做任何操作 timer就会后台运行 ,当我进行操作的时候runloop模式就会从默认模式切换到其他模式,假如说我操作scrollerView 它就会从default模式切换到tracking模式<br>而roonloop 同一时刻只能执行一种模式.<br>当在创建timer时指定 Comment 仅仅是个标记,默认和追踪,那么timer就会随着触发的模式不同进行 默认和追踪模式的选择 </p>
</li>
<li><p>Source<br>source一般是不会去操作的,第一种是基于自定义的,第二种是基于端口的,第三种是基于Performselect的通过函数调用栈来对source分类:分为source0 source1 :<br>(1)source0是非基于端口的,是用户自己手动触发的操作,比如触摸滑动等操作.<br>(2)Source1是系统内部的一些端口触发的事件<br>(3)子线程的runloop需要手动创建,需要手动开启</p>
</li>
<li><p>自动释放池<br>第一次创建:是在runloop进入的时候创建 对应的状态 = KCFRunLoopEntry<br>最后一个退出,是在runloop退出的时候 对应的状态 = KCFRunLoopExit </p>
<blockquote>
<p>其他的创建和释放<br>即将进入睡眠的时候,先释放上一次创建的自动释放池,然后再创建一个新的释放池</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runloop/">runloop</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
      </div>
      
        <div align="center" style="margin-top: 30px;"><hr class="hr" style="margin:0px; height:3px;"></div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2014 - 2017 Simonの小📚坊 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>


  <script src="/js/home.js"></script>










	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Simonの小📚坊
          </div>
          <div class="panel-body">
            Copyright © 2017 Simon All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
</body>
</html>