<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1" />






<meta name="description" content="layout: ‘[post]’title: Realm-Swift3.0date: 2017-1-20tags:

数据库categories: iOS

##Realm-Swift3.0
简介Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScr">
<meta property="og:type" content="article">
<meta property="og:title" content="simonの小📚坊">
<meta property="og:url" content="https://github.com/icoderRo/2017/06/26/RealmSwift/index.html">
<meta property="og:site_name" content="simonの小📚坊">
<meta property="og:description" content="layout: ‘[post]’title: Realm-Swift3.0date: 2017-1-20tags:

数据库categories: iOS

##Realm-Swift3.0
简介Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScr">
<meta property="og:image" content="https://ww3.sinaimg.cn/large/006tKfTcgy1fimyuw95jdj30g7083ta2.jpg">
<meta property="og:updated_time" content="2017-08-17T11:55:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="simonの小📚坊">
<meta name="twitter:description" content="layout: ‘[post]’title: Realm-Swift3.0date: 2017-1-20tags:

数据库categories: iOS

##Realm-Swift3.0
简介Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScr">
<meta name="twitter:image" content="https://ww3.sinaimg.cn/large/006tKfTcgy1fimyuw95jdj30g7083ta2.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"display":"remove"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://github.com/icoderRo/2017/06/26/RealmSwift/"/>

  <title>  | simonの小📚坊 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  

  <div class="container one-collumn  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  
    <div class="site-meta-headline">
      <a>
        <img class="custom-logo-image" src="images/logo.svg"
             alt="simonの小📚坊"/>
      </a>
    </div>
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">simonの小📚坊</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">始于颜值，陷于才华，忠于人品</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">

      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-06-26T22:09:18+08:00" content="2017-06-26">
              2017-06-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/26/RealmSwift/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/26/RealmSwift/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>layout: ‘[post]’<br>title: Realm-Swift3.0<br>date: 2017-1-20<br>tags:</p>
<ul>
<li>数据库<br>categories: iOS</li>
</ul>
<p>##Realm-Swift3.0<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fimyuw95jdj30g7083ta2.jpg" alt=""></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScript、Swift、Xamarin平台</p>
<p>Realm的优点在官方上有很多的说明, 略举两点:</p>
<p><strong>1.易上手</strong>:想比于Core Data 和SQLite, Realm的学习成本相对来说会比较低, 毫不夸张的说, 把官方的文档和Demo看完一遍, 就可以快速的上手开发功能。</p>
<p><strong>2.可视化</strong>: Realm提供了一个轻量级的数据库查看工具, 在App Store中下载<code>Realm Browser</code>, 相比于SQLite, 你可能需要去下载付费或者破解版的Navicat、SQL Manager等软件会方便很多, 借助于<code>Realm Browser</code>调试Realm数据库很便捷。</p>
<ul>
<li>使用模拟器进行调试<ul>
<li>通过执行<code>realm.configuration.fileURL</code>打印出Realm数据库的地址, Finder中跳转进对应的路径, 用<code>Realm Browser</code>打开对应的.realm文件就可以看到数据啦。</li>
</ul>
</li>
<li>使用真机调试<ul>
<li>Xcode-&gt;Window-&gt;Devices,然后找到对应的设备与项目,导出xcappdata文件后,显示包内容进入Documents,使用<code>Realm Browser</code>打开.realm文件即可.</li>
</ul>
</li>
</ul>
<h4 id="Xcode插件"><a href="#Xcode插件" class="headerlink" title="Xcode插件"></a>Xcode插件</h4><p>Realm的Xcode插件令 Realm 模型的创建更加方便.gitHub下载一个Demo<a href="https://github.com/realm/realm-cocoa">传送门</a>, 找到里面的Plugin目录下的RealmPlugin.xcodeproj并进行编译，重启 Xcode之后插件即可生效。<br><code>需要配图</code>:</p>
<h4 id="纯SWift版的安装"><a href="#纯SWift版的安装" class="headerlink" title="纯SWift版的安装"></a>纯SWift版的安装</h4><ul>
<li>使用 Realm 构建应用的基本要求：iOS 8 及其以上版本, macOS 10.9 及其以上版本，此外 Realm 支持 tvOS 和 watchOS 的所有版本。</li>
<li>需要使用 Xcode 8.0 或者以后的版本。Realm Swift 2.3.0 是最后一个支持 Swift 2.x 及 Xcode 7.3 的版本。</li>
<li>方法1:Dynamic Framework<ul>
<li>下载<a href="https://realm.io/cn/docs/swift/latest/#section-2" target="_blank" rel="external">Realm的最新版</a>本并解压。</li>
<li>前往您 Xcode 工程的”General”设置页。前往适合您项目的 Swift 版本目录，从其中的 ios文件夹中，拖拽<code>RealmSwift.framework</code> 和<code>Realm.framework</code>到”Embedded Binaries”选项中，确认Copy items if needed被选中（除非您的项目中需要在多个平台中使用 Realm），并点击Finish。</li>
<li>在您的单元测试目标的”Build Settings”中，添加RealmSwift.framework的上级目录到您的”Framework Search Paths”中。</li>
<li>如果您打算在您的 iOS、tcOS 或者 watchOS 工程中使用 Realm，请在您的 app 目标的“Build Phases”中创建一个新的”Run Script Phase”，并在文本框中写入<code>bash &quot;${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/Realm.framework/strip-frameworks.sh&quot;</code>因为要绕过这个APP商店提交的bug，这一步在打包二进制发布版本时是必须。</li>
</ul>
</li>
<li>方法2:Carthage<ul>
<li><a href="https://github.com/Carthage/Carthage#installing-carthage">安装 Carthage 0.17.0 或者更高版本</a></li>
<li>在Carthage 中添加github <code>realm/realm-cocoa</code></li>
<li>运行 <code>carthage update</code></li>
<li>从 Carthage/Build/ 目录下对应平台文件夹中，将 <code>RealmSwift.framework</code> 和 <code>Realm.framework</code> 拖曳到您 Xcode 工程”General”设置项的”Linked Frameworks and Libraries”选项卡中</li>
<li>iOS/tvOS/watchOS: 在您应用目标的<strong>Build Phases</strong>设置选项卡中，点击“+”按钮并选择“New Run Script Phase”。在新建的Run Script中，填写:<code>/usr/local/bin/carthage copy-frameworks</code> 在<strong>Input Files</strong>内添加您想要使用的框架路径，例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```               </div><div class="line">$(SRCROOT)/Carthage/Build/iOS/RealmSwift.framework</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>方法3:CocoaPods</p>
<ul>
<li>运行 <code>pod repo update</code>，以确保 CocoaPods 能够获取到 Realm 的最新版本</li>
<li>在Podfile中，添加use_frameworks!和pod ‘RealmSwift’ 到您的主要和测试目标</li>
<li><p>如果您使用的是 Xcode 8，那么将下面代码复制到您的 Podfile 底部，以便在必要的时候更新 Swift 的版本：</p>
<figure class="highlight plain"><figcaption><span>do |target|</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    target.build_configurations.each do |config|</div><div class="line">      config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.0&apos;</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
<li><p>在终端运行 pod install,采用 CocoaPods 生成的 .xcworkspace 来运行工程！</p>
</li>
<li>注意:我这边选用CocoaPods的方式安装, 安装的时间还是需要比较多的, <strong>如果发现pod search RealmSwift版本比较低, 先升级一下pod索引库</strong></li>
</ul>
</li>
</ul>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><h5 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h5><ul>
<li>Realm 支持以下的属性类型：Bool、Int8、Int16、Int32、Int64、Double、Float、String、Date以及Data。</li>
<li>也可以使用 List<object> 和 Object 来建立诸如一对多、一对一之类的关系模型，此外 Object 的子类也支持此功能。</object></li>
</ul>
<h5 id="数据模型-Object"><a href="#数据模型-Object" class="headerlink" title="数据模型(Object)"></a>数据模型(Object)</h5><ul>
<li>Realm数据模型是基于标准Swift类来进行定义的, 通过简单的集成<strong>Object</strong>或者其子类, 就可以创建一个新的Realm数据模型对象, 可以给Realm模型添加方法和协议等, 用法和swift中的其他对象类似</li>
<li><p>Realm 模型的属性需要设置为dynamic var特性，以便其能够被数据库底层数据所访问。<strong>List</strong> 和 <strong>RealmOptional</strong> 不能被设为动态属性，因为泛型属性不能在 Objective‑C 运行时中被识别，而 dynamic 属性会被用于进行动态调度。此外这两个类型应当始终声明为 let</p>
</li>
<li><p>为对象的类型列表添加目标类型的属性，或者List，就可以创建数据关系(relationship)和嵌套数据结构(nested data structure)。</p>
</li>
</ul>
<h5 id="关系-Relationships"><a href="#关系-Relationships" class="headerlink" title="关系(Relationships)"></a>关系(Relationships)</h5><ul>
<li><strong>Object</strong> 能够借助Object以及List属性和另一个Object建立联系, List的接口和Array非常类似, 能够通过索引下表进行访问, 不同之处在于, <strong>List中只能存放简单的Object子类的类型</strong></li>
</ul>
<h5 id="事务-Transactions"><a href="#事务-Transactions" class="headerlink" title="事务(Transactions)"></a>事务(Transactions)</h5><ul>
<li><p>Realm 写入操作是<em>同步以及阻塞的</em>，并不会异步运行。如果线程 A 开始了一个写入操作，接着在线程 A 结束之前，线程 B 又对同一个 Realm 数据库开始了写入操作，那么线程 A 必须在线程 B 的写入操作进行之前，完成自己的写入操作，并将事务提交。写入操作总会在 beginWrite() 操作进行的时候自动刷新，因此重复写入 (overlapping write) 并不会产生竞争条件。</p>
</li>
<li><p>由于写入事务像其余硬盘读写操作一样，会出现失败的情况，因此 Realm.write() 以及 Realm.commitWrite() 可以加上 throws标记。因此你可以处理和恢复诸如硬盘空间溢出之类的错误。此外，其他的错误都无法进行恢复。</p>
<h5 id="结果集-Results"><a href="#结果集-Results" class="headerlink" title="结果集(Results)"></a>结果集(Results)</h5></li>
<li>通过查询操作，Realm 将会返回包含 Object 集合的 Results 实例。Results 的表现和 Array 十分相似，并且包含在 Results 中的对象能够通过索引下标进行访问。 </li>
<li>所有的查询在 Realm 中都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。</li>
<li>查询结果并不是数据的拷贝：修改查询结果会直接修改硬盘上的数据。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><ul>
<li>默认配置的 Realm 数据库<br>通过调用 Realm() 来初始化以及访问我们的 realm 变量。这个方法将会返回一个 Realm 对象，并指向您应用的 Documents (iOS) 或者 Application Support (OS X)文件夹下的一个名为“default.realm”的文件<figure class="highlight plain"><figcaption><span>realm = try? Realm()```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 配置Realm</div><div class="line">通过Realm.Configuration您可以配置诸如 Realm 文件在何处存储之类的信息。</div><div class="line">配置同时也可以在每次您需要使用 Realm 实例的时候传递给Realm(configuration: config)，或者可以通过 Realm.Configuration.defaultConfiguration = config 来为默认的 Realm 数据库进行配置</div></pre></td></tr></table></figure></li>
</ul>
<p>func configRealmWithUser(_ username:String) {</p>
<pre><code>var config = Realm.Configuration()

config.fileURL = config.fileURL?.deletingLastPathComponent()
        .appendingPathComponent(&quot;\(username).realm&quot;)

Realm.Configuration.defaultConfiguration = config
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 使用方式</div><div class="line"></div><div class="line">``` </div><div class="line">configRealmWithUser(&quot;simon&quot;)</div><div class="line">let realm = try! Realm()</div></pre></td></tr></table></figure>
<ul>
<li>内存数据库<br>通常情况下，Realm 数据库是存储在硬盘中的，但是您能够通过设置 inMemoryIdentifier 而不是设置Realm.Configuration 中的 fileURL 属性，以创建一个完全在内存中运行的数据库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: &quot;MyInMemoryRealm&quot;))</div></pre></td></tr></table></figure>
<blockquote>
<p>内存数据库在每次程序运行期间都不会保存数据。但是，这不会妨碍到 Realm 的其他功能，包括查询、关系以及线程安全。 假如您需要灵活的数据读写但又不想储存数据的话，那么内存数据库对您来说一定是一个不错的选择。</p>
<p>内存数据库会在临时文件夹中创建多个文件，用来协调处理诸如跨进程通知之类的事务。 实际上没有任何的数据会被写入到这些文件当中，除非操作系统由于内存过满需要清除磁盘上的多余空间。</p>
<p>注意： 当所有具备特定标识符的Realm 内存数据库实例超出可用范围，但是却没有被引用的话，那么<em> Realm 内存数据库中的所有数据都会被删除</em>。我们建议您在应用的生命周期内，保持对 Realm 内存数据库的强引用。（对于存储在硬盘当中的 Realm 数据库而言，这并不是必须的操作。）</p>
</blockquote>
<h5 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h5><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person: Object &#123;</div><div class="line">    </div><div class="line">    dynamic var name = &quot;&quot;</div><div class="line">    dynamic var age = 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog: Object &#123;</div><div class="line">    dynamic var id = 0</div><div class="line">    dynamic var name = &quot;&quot;</div><div class="line">    dynamic var age = 0</div><div class="line">    </div><div class="line">    override static func primaryKey() -&gt; String? &#123;</div><div class="line">        return &quot;id&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><ul>
<li>以对象的形式创建: 此创建方式, 如果有设置主键, 则不能创建相同的主键</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let mydog = Dog()</div><div class="line">mydog.name = &quot;aa&quot;</div><div class="line">mydog.age = 20</div><div class="line">mydog.id = 5</div></pre></td></tr></table></figure>
<ul>
<li>以数组的形式创建: 如果主键相同,则会覆盖之前的数据, 没有设置主键, 则update只能为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">realm.create(Dog.self,</div><div class="line">			   value: [6, &quot;sssssss&quot;, 747],</div><div class="line">			   update: true)</div></pre></td></tr></table></figure>
<ul>
<li>以字典的形式创建: 如果主键相同,则会覆盖之前的数据, 没有设置主键, 则update只能为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">realm.create(Dog.self,</div><div class="line">				value: [&quot;id&quot;:6, &quot;name&quot;: &quot;sada&quot;, &quot;age&quot;:77],</div><div class="line">				update: true)</div></pre></td></tr></table></figure>
<ul>
<li>复合模型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 基础模型</div><div class="line">class Animal: Object &#123;</div><div class="line">  dynamic var age = 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 包含有 Animal 的模型</div><div class="line">class Duck: Object &#123;</div><div class="line">  dynamic var animal: Animal? = nil</div><div class="line">  dynamic var name = &quot;&quot;</div><div class="line">&#125;</div><div class="line">class Frog: Object &#123;</div><div class="line">  dynamic var animal: Animal? = nil</div><div class="line">  dynamic var dateProp = NSDate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 用法</div><div class="line">let duck = Duck(value: [ &quot;animal&quot;: [ &quot;age&quot;: 3 ], &quot;name&quot;: &quot;Gustav&quot; ])</div></pre></td></tr></table></figure>
<ul>
<li>Data 类型存储(本地图片为例)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class DogPortrait:Object &#123;</div><div class="line">    dynamic var data:Data?</div><div class="line">&#125;</div><div class="line"></div><div class="line">let imageURL =  Bundle.main.url(forResource: &quot;sssss.png&quot;, withExtension: nil)!</div><div class="line">let imageData = try! Data(contentsOf: imageURL)</div><div class="line"></div><div class="line">let portrait = DogPortrait()</div><div class="line">portrait.data = imageData</div><div class="line"></div><div class="line">try! realm.write &#123;</div><div class="line">	realm.add(portrait)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 查询</div><div class="line">let portraits = realm.objects(DogPortrait.self)</div><div class="line">let imgData = portraits[0].data</div></pre></td></tr></table></figure>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><ul>
<li>Realm无法直接限制查询数量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let dogs = try! Realm().objects(Dog.self)</div></pre></td></tr></table></figure>
<ul>
<li>需要查询限制数量, 可以借助for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in 0..&lt;5 &#123;</div><div class="line">    let dog = dogs[i]</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Realm为何无法限制查询数量？</strong></p>
<p>通常查询数据库数据时，我们可以在sql语句中添加一些限制语句（比如rownum，limit，top等）来限制返回的结果集的行数。<br>但我们使用Realm会发现，它没有这种分页功能，感觉不管查什么都是把所有的结果都捞出来。比如我们只要User表的前10条数据，那么做法是先查询出所有的User数据，再从结果集中取出前10条数据。<br>有人可能会担心，如果数据库中数据非常多，那每次都这么查不会影响性能吗？<br>其实大可放心，由于Realm都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。不像通常数据库，查询后，查询结果是从数据库拷贝一份出来放在内存中的。而Realm的查询结果应该说是数据库数据的引用，就算你查出来，如果不用也不会占用什么内存。</p>
</blockquote>
<ul>
<li>可以通过Predicate条件查询特定数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let results1 = realm.objects(Dog.self)</div><div class="line"></div><div class="line">let results = realm.objects(Dog.self).filter(NSPredicate(format: &quot;name contains &apos;A&apos;&quot;))</div><div class="line">        </div><div class="line">let result2 = results.filter(&quot;age &gt; 18&quot;)</div><div class="line"></div><div class="line">let results3 = realm.objects(Dog.self).filter(NSPredicate(format: &quot;name contains &apos;A&apos;&quot;)).filter(&quot;age &gt; 16&quot;).sorted(byKeyPath: &quot;age&quot;) // 升序</div></pre></td></tr></table></figure>
<blockquote>
<p>1.NSPredicate：</p>
<p>比较操作数(comparison operand)可以是属性名称或者某个常量，但至少有一个操作数必须是属性名称；<br>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!=, 以及 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 属性类型的比较，比如说 age == 45；<br>相等比较 ==以及!=，比如说Results<employee>().filter(“company == %@”, company)<br>比较操作符 == and != 支持布尔属性；<br>对于 NSString 和 NSData 属性来说，我们支持 ==、!=、BEGINSWITH、CONTAINS 以及 ENDSWITH 操作符，比如说 name CONTAINS ‘Ja’；<br>字符串支持忽略大小写的比较方式，比如说 name CONTAINS[c] ‘Ja’ ，注意到其中字符的大小写将被忽略；<br>Realm 支持以下复合操作符：“AND”、“OR” 以及 “NOT”。比如说 name BEGINSWITH ‘J’ AND age &gt;= 32；<br>包含操作符 IN，比如说 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；<br>==、!=支持与 nil 比较，比如说 Results<company>().filter(“ceo == nil”)。注意到这只适用于有关系的对象，这里 ceo 是 Company 模型的一个属性。<br>ANY 比较，比如说 ANY student.age &lt; 21<br>注意，虽然我们不支持复合表达式类型(aggregate expression type)，但是我们支持对对象的值使用 BETWEEN 操作符类型。比如说，Results<person>.filter(“age BETWEEN %@”, [42, 43]])。</person></company></employee></p>
<p>2.排序:</p>
<p>sorted(byKeyPath:) 以及 sorted(byProperty:) 不支持将多个属性用作排序基准，此外也不能链式调用（只有最后一个 sorted 会被调用）。如果要按多个属性进行排序的话，请使用 sorted(by:) 方法，然后向其中传递多个 SortDescriptor 对象</p>
</blockquote>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><ul>
<li>直接更新内容, 在写入事务中通过设置某个对象的属性从而完成对象的更新操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mydog.name = &quot;aa&quot;</div><div class="line">mydog.age = 20</div></pre></td></tr></table></figure>
<ul>
<li>通过主键更新, 数据模型中设置了主键的话，可以使用Realm().add(_:update:)来更新对象，或者当对象不存在时插入新的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let mydog = Dog()</div><div class="line">mydog.name = &quot;aa&quot;</div><div class="line">mydog.age = 20</div><div class="line">mydog.id = 5</div><div class="line"></div><div class="line">try! realm.write &#123;</div><div class="line">  realm.add(mydog, update: true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>键值编码<br><strong>Object</strong>、<strong>Result</strong> 以及 List都遵守键值编码(KVC）机制, 适用于大量更新数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">try? realm.write &#123;</div><div class="line">	results.first?.setValue(&quot;33&quot;, forKeyPath: &quot;age&quot;)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>删除数据库中的所有数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let realm = try! Realm()</div><div class="line">try? realm.write &#123;</div><div class="line">	realm.deleteAll()</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>删除某条数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let realm = try! Realm()    </div><div class="line">let results  = realm.objects(Dog.self).filter(&quot;age = 33&quot;)</div><div class="line"></div><div class="line">realm.beginWrite()</div><div class="line">realm.delete(dog)</div><div class="line">try? realm.commitWrite()</div></pre></td></tr></table></figure>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>Realm 模型的属性需要设置为dynamic var特性，以便其能够被数据库底层数据所访问。<br>List 和 RealmOptional 不能被设为动态属性，因为泛型属性不能在 Objective‑C 运行时中被识别, List 和 RealmOptional应该用let修饰</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>非可选值形式</th>
<th>可选值形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bool</td>
<td>dynamic var value = false</td>
<td>let value = RealmOptional<bool>()</bool></td>
</tr>
<tr>
<td>Int</td>
<td>dynamic var value = 0</td>
<td>let value = RealmOptional<int>()</int></td>
</tr>
<tr>
<td>Float</td>
<td>dynamic var value: Float = 0.0</td>
<td>let value = RealmOptional<float>()</float></td>
</tr>
<tr>
<td>Double</td>
<td>dynamic var value: Double = 0.0</td>
<td>let value = RealmOptional<double>()</double></td>
</tr>
<tr>
<td>String</td>
<td>dynamic var value = “”</td>
<td>dynamic var value: String? = nil</td>
</tr>
<tr>
<td>Data</td>
<td>dynamic var value = NSData()</td>
<td>dynamic var value: NSData? = nil</td>
</tr>
<tr>
<td>Date</td>
<td>dynamic var value = NSDate()</td>
<td>dynamic var value: NSDate? = nil</td>
</tr>
<tr>
<td>Object</td>
<td>n/a: 必须是可选值</td>
<td>dynamic var value: Class?</td>
</tr>
<tr>
<td>List</td>
<td>let value = List<class>()</class></td>
<td>n/a: 必须是非可选值</td>
</tr>
<tr>
<td>LinkingObjects</td>
<td>let value = LinkingObjects(fromType: Class.self, property: “property”)</td>
<td>n/a: 必须是非可选值</td>
</tr>
</tbody>
</table>
<ul>
<li>索引属性<br>重写 Object.indexedProperties() 方法可以为数据模型中需要添加索引的属性建立索引;Realm 支持字符串、整数、布尔值以及 NSDate 属性作为索引;<br>对属性进行索引可以减少插入操作的性能耗费，加快比较检索的速度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override static func indexedProperties() -&gt; [String] &#123;</div><div class="line">	return [&quot;id&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>主键<br>重写 Object.primaryKey() 可以设置模型的主键。声明主键之后，对象将允许进行查询，并且更新速度更加高效，而这也会要求每个对象保持唯一性。 一旦带有主键的对象被添加到 Realm 之后，该对象的<strong>主键将不可修改</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override static func primaryKey() -&gt; String? &#123;</div><div class="line">	return &quot;id&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>忽略属性<br>重写 Object.ignoredProperties() 可以防止 Realm 存储数据模型的某个属性。Realm 将不会干涉这些属性的常规操作，它们将由成员变量(ivar)提供支持，并且您能够轻易重写它们的 setter 和 getter。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dynamic var tmpID = 0</div><div class="line">var name: String &#123; // 只读属性将被自动忽略</div><div class="line">	return &quot;ignoredProperties&quot;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">override static func ignoredProperties() -&gt; [String] &#123;</div><div class="line">	return [&quot;tmpID&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可空属性 <strong>String</strong>、<strong>NSDate</strong> 以及 <strong>NSData</strong> 属性通过标准的 Swift 语法声明为可空类型或者非空类型; 声明可空的数值类型可以使用<strong>RealmOptional</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Person: Object &#123;</div><div class="line">	// 可选的字符串属性，默认为 nil</div><div class="line">    dynamic var name: String? = nil</div><div class="line"></div><div class="line">    // 可选的 int 属性，默认为 nil</div><div class="line">    // RealmOption 属性应该始终声明为常量</div><div class="line">    // 因为目前直接给这个属性进行赋值并不会起任何作用</div><div class="line">    let age = RealmOptional&lt;Int&gt;()</div><div class="line">&#125;</div><div class="line"></div><div class="line">let realm = try? Realm()</div><div class="line">var objc: optionObjc?</div><div class="line">try? realm?.write &#123;</div><div class="line">objc =  realm?.create(optionObjc.self, value: [&quot;sx&quot;, 12], update: false)</div><div class="line">  // 读取或者修改 `RealmOptional` 可以通过 `value` 属性实现</div><div class="line">	objc?.age.value = 20 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul>
<li>对一关系:对于多对一或一对一的关系, 只需要声明一个Object子类类型的属性即可:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Dog: Object &#123;</div><div class="line">    dynamic var id = 0</div><div class="line">    dynamic var name = &quot;&quot;</div><div class="line">    dynamic var age = 0</div><div class="line">    dynamic var owner: Person? // 可选</div><div class="line">&#125;</div><div class="line"></div><div class="line">let dog = Dog()</div><div class="line">let person = Person()</div><div class="line">dog.owner = person</div></pre></td></tr></table></figure>
<ul>
<li>对多关系:通过 List 类型的属性您可以定义一个对多关系。List中可以包含简单类型的Object，其接口与可变的Array非常类似。<strong>注意使用let</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person: Object &#123;</div><div class="line">    </div><div class="line">    dynamic var name = &quot;&quot;</div><div class="line">    dynamic var age = 0</div><div class="line">    let dogs = List&lt;Dog&gt;()</div><div class="line">&#125;</div><div class="line"></div><div class="line">let results = try?Realm().objects(Dog.self).filter(&quot;age &gt; 18&quot;)</div><div class="line">	let person = Person()</div><div class="line">	person.dogs.append((results?.first)!)</div><div class="line">	person.dogs.append((results?.last)!)</div><div class="line">        </div><div class="line">try? Realm().write &#123;</div><div class="line">	try? Realm().add(person)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>反向关系<br>Realm 提供了<strong>链接对象 (linking objects)</strong> 属性来表示反向关系</li>
</ul>
<blockquote>
<p>例如，一个 Dog 对象可以拥有一个名为 owners 的链接对象属性，这个属性中包含了某些 Person 对象，而这些 Person 对象在其 dogs 属性中包含了这一个确定的 Dog 对象。您可以将 owners 属性设置为 LinkingObjects 类型，然后指定其关系，说明其当中包含了 Person 对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Dog: Object &#123;</div><div class="line">    dynamic var name = &quot;&quot;</div><div class="line">    dynamic var age = 0</div><div class="line">     </div><div class="line">    // Realm 并不会存储这个属性，因为这个属性只定义了 getter</div><div class="line">    // 定义“owners”，和 Person.dogs 建立反向关系</div><div class="line">    let owners = LinkingObjects(fromType: Person.self, property: &quot;dogs&quot;)</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">func RealmBackLink() &#123;</div><div class="line">	let realm = try! Realm()</div><div class="line">	let dog1 = Dog()</div><div class="line">	dog1.name = &quot;ssssx&quot;</div><div class="line">	dog1.age = 22</div><div class="line">        </div><div class="line">	let owner = Person()</div><div class="line">	owner.dogs.append(dog1)</div><div class="line">        </div><div class="line">	try! realm.write &#123; // 只需存储person即可</div><div class="line">		realm.add(owner)</div><div class="line">	&#125;</div><div class="line">	let dogs = realm.objects(Dog.self)</div><div class="line">	let ownerName = dogs.first?.owners.map&#123;$0.name&#125;</div><div class="line">        print(ownerName)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>需要注意的一件事情就是不能让多个线程都持有同一个 Realm 对象的 实例 。如果多个线程需要访问同一个对象，那么它们分别会获取自己所需要的实例（否则在一个线程上发生的更改就会造成其他线程得到不完整或者不一致的数据）</p>
<ul>
<li>跨线程传递实例<br>Object 的未管理实例（unmanaged) 可以安全地跨线程传递, 管理实例皆受到线程的限制(Realm、Object、Results 或者 List), 这意味着它们只能够在被创建的线程上使用。Realm 提供了一个机制，通过以下三个步骤来保证受到线程限制的实例能够安全传递:<ul>
<li>通过受到线程限制的对象来构造一个 ThreadSafeReference</li>
<li>将此 ThreadSafeReference 传递给目标线程或者队列</li>
<li>通过在目标 Realm 上调用 Realm.resolve(_:) 来解析此引用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let person = Person(name: &quot;Jane&quot;)</div><div class="line">try! realm.write &#123;</div><div class="line">  realm.add(person)</div><div class="line">&#125;</div><div class="line">let personRef = ThreadSafeReference(to: person)</div><div class="line">DispatchQueue(label: &quot;background&quot;).async &#123;</div><div class="line">  autoreleasepool &#123;</div><div class="line">    let realm = try! Realm()</div><div class="line">    guard let person = realm.resolve(personRef) else &#123;</div><div class="line">      return // person 已被删除</div><div class="line">    &#125;</div><div class="line">    try! realm.write &#123;</div><div class="line">      person.name = &quot;Jane Doe&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>ThreadSafeReference对象最多只能够解析一次;ThreadSafeReference 解析失败的话，将会导致 Realm 的原始版本被锁死，直到引用被释放为止。因此，ThreadSafeReference 的生命周期应该很短(加上autoreleasepool)。</p>
</blockquote>
<ul>
<li>这些类型的某些属性和方法可以在任意线程中进行访问</li>
</ul>
<blockquote>
<p>Realm: 所有的属性、类方法和构造器；all properties, class methods, and initializers</p>
<p>Object: isInvalidated、objectSchema、realm，以及所有的类方法和构造器；<br>Results: objectClassName 和 realm</p>
<p>List: isInvalidated、objectClassName 和 realm。</p>
</blockquote>
<ul>
<li>跨线程使用数据库<br>在不同的线程中使用同一个 Realm 文件, 需要在每一个线程初始化一个新的Realm 实例, 只要指定的配置是相同的，那么所有的 Realm 实例都将会指向硬盘上的同一个文件。</li>
</ul>
<blockquote>
<p>暂时不支持共享Realm实例</p>
<p>当写入大量数据的时候，在一个单独事务中通过批量执行多次数据修改操作是非常高效的。事务也可以使用 Grand Central Dispatch(GCD) 在后台运行，以防止阻塞主线程。 Realm 对象并不是线程安全的，并且它也不能够跨线程共享，<strong>因此要为每一个要执行读取或者写入操作的线程或者 dispatch 队列创建一个 Realm 实例</strong>。 这里有一个在后台队列中插入百万数据的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">DispatchQueue(label: &quot;background&quot;).async &#123;</div><div class="line">  autoreleasepool &#123;</div><div class="line">    // 在这个线程中获取 Realm 和表实例</div><div class="line">    let realm = try! Realm()</div><div class="line"></div><div class="line">    // 通过开启写入操作将写入闭包分成多个微小部分</div><div class="line">    for idx1 in 0..&lt;1000 &#123;</div><div class="line">      realm.beginWrite()</div><div class="line"></div><div class="line">      // 通过字典插入行，忽略属性次序</div><div class="line">      for idx2 in 0..&lt;1000 &#123;</div><div class="line">        realm.create(Person.self, value: [</div><div class="line">          &quot;name&quot;: &quot;\(idx1)&quot;,</div><div class="line">          &quot;birthdate&quot;: Date(timeIntervalSince1970: TimeInterval(idx2))</div><div class="line">        ])</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 提交写入事务以确保数据在其他线程可用</div><div class="line">      try! realm.commitWrite()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h4><p>Realm 没有提供对 JSON 的直接支持，但可以使用 NSJSONSerialization.JSONObjectWithData(_:options:) 的输出完成从 JSON 中添加 Object 的操作。 由此所产生的 KVC 兼容的对象可以使用创建和更新对象的 标准 API 来添加/更新 Object。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 表示城市的一个 Realm 对象</div><div class="line">class City: Object &#123;</div><div class="line">  dynamic var city = &quot;&quot;</div><div class="line">  dynamic var id = 0</div><div class="line">  // 其它空余的属性…</div><div class="line">&#125;</div><div class="line"></div><div class="line">let data = &quot;&#123;\&quot;name\&quot;: \&quot;San Francisco\&quot;, \&quot;cityId\&quot;: 123&#125;&quot;.data(using: .utf8)!</div><div class="line">let realm = try! Realm()</div><div class="line"></div><div class="line">// 从包含 JSON 的 NSData 中插入数据</div><div class="line">try! realm.write &#123;</div><div class="line">  let json = try! JSONSerialization.jsonObject(with: data, options: [])</div><div class="line">  realm.create(City.self, value: json, update: true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在 JSON 中包含了嵌套的对象或者数组的话，这些数据都将被自动映射到对一以及对多关系——参见嵌套对象 一节获取详情。</p>
<p>当使用这种方法在 Realm 中插入或者更新 JSON 数据的时候，<strong>要注意 Realm 需要确保 JSON 的属性名和类型能够与 Object 属性完全匹配</strong>。例如：</p>
<ul>
<li>float 属性应当使用 float 进行初始化——您也可以选择 NSNumbers。</li>
<li>NSDate 和 NSData 属性无法从字符串进行自动推断，而应该在传递给 Realm().create(_:value:update:) 之前转换为适当的类型。</li>
<li>如果 JSON 中的属性是 null (例如：NSNull) 提供给了一个必需属性的话，那么会抛出异常。<br>如果某个必需属性在插入操作中没有提供的话，那么会抛出异常。</li>
<li>Realm 将会忽略 JSON 中没有以 Object 定义的任何属性。</li>
</ul>
<p>如果 JSON 模式和 Realm 对象无法完全一致的话，推荐使用第三方的模型映射框架<br>。</p>
</blockquote>
<h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><ul>
<li>Realm通知 通知闭包-可以在整个 Realm 数据库上进行注册。当相关 Realm 的写操作事务被提交之后，无论这个事务发生在何种线程或者何种进程之中，这个通知处理闭包都将会被触发：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let realm  = try? Realm()</div><div class="line">print(realm?.configuration.fileURL as Any)</div><div class="line">let token = realm?.addNotificationBlock(&#123; (note, realm) in</div><div class="line">	print(note, realm)</div><div class="line">&#125;)</div><div class="line">        </div><div class="line">        </div><div class="line">try? realm?.write &#123;</div><div class="line">	realm?.create(Dog.self, value: [&quot;id&quot;:1, &quot;name&quot;: &quot;xssx&quot;], update: true) // 执行通知闭包</div><div class="line">&#125;</div><div class="line">        </div><div class="line">token?.stop() // 关闭通知</div><div class="line">        </div><div class="line">try? realm?.write &#123;</div><div class="line">	realm?.create(Dog.self, value: [&quot;name&quot;: &quot;stopxssx&quot;], update: true)// 不执行通知闭包</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>集合通知<br>集合通知是异步触发的，首先它会在初始化的时候触发，随后当某个写入事务改变了集合中的所有或者某个对象的时候，通知都会再次触发。<br>所有的CRUD都会传递到通知闭包当中的 RealmCollectionChange(枚举) 参数访问到。这个对象当中包含了受 deletions、insertions 和 modifications 状态所影响的索引信息, 其定义如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum RealmCollectionChange&lt;T&gt; &#123;</div><div class="line">    case initial(T) // 初始化会执行</div><div class="line">    case update(T, deletions: [Int], insertions: [Int], modifications: [Int])</div><div class="line">    case error(Error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果处理集合中的对象的属性发生更改, 都可以监听的到<strong>修改 (modifications)</strong> 的通知, 当<strong>对一关系和对多关系</strong> 发生变化时也会触发这个状态变化，但是对于 <strong>反向关系</strong> 来说则不会触发这个变化。</p>
<p>以tableView为例子,监听数据源的改变, 做出相应更改, 当然可以重写数据源的set方法, 但如果数据源里的某一个数据里的属性发生了更改, 是无法监听的到, 当然可以结合KVO,但这样一来就相对复杂了; so集合通知还是挺实用的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">class Dog: Object &#123;</div><div class="line">  dynamic var name = &quot;&quot;</div><div class="line">  dynamic var age = 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Person: Object &#123;</div><div class="line">  dynamic var name = &quot;&quot;</div><div class="line">  let dogs = List&lt;Dog&gt;()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ViewController: UITableViewController &#123;</div><div class="line">  var notificationToken: NotificationToken? = nil</div><div class="line"></div><div class="line">  override func viewDidLoad() &#123;</div><div class="line">    super.viewDidLoad()</div><div class="line">    let realm = try! Realm()</div><div class="line">    </div><div class="line">    // 对results的监听</div><div class="line">    let results = realm.objects(Person).filter(&quot;age &gt; 5&quot;)</div><div class="line"></div><div class="line">    // 观察 Results 通知</div><div class="line">    notificationToken = results.addNotificationBlock &#123; [weak self] (changes: RealmCollectionChange) in</div><div class="line">      guard let tableView = self?.tableView else &#123; return &#125;</div><div class="line">      switch changes &#123;</div><div class="line">      case .initial:</div><div class="line">        // Results 现在已经填充完毕，可以不需要阻塞 UI 就可以被访问</div><div class="line">        tableView.reloadData()</div><div class="line">        break</div><div class="line">      case .update(_, let deletions, let insertions, let modifications):</div><div class="line">        // Query results have changed, so apply them to the UITableView</div><div class="line">        tableView.beginUpdates()</div><div class="line">        tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;),</div><div class="line">                           with: .automatic)</div><div class="line">        tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;),</div><div class="line">                           with: .automatic)</div><div class="line">        tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;), </div><div class="line">                           with: .automatic)</div><div class="line">        tableView.endUpdates()</div><div class="line">        break</div><div class="line">      case .error(let error):</div><div class="line">        // 如果在后台工作线程中打开 Realm 文件，则会发生错误</div><div class="line">        fatalError(&quot;\(error)&quot;)</div><div class="line">        break</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  deinit &#123;</div><div class="line">    notificationToken?.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对象通知<ul>
<li>Realm 支持对象级别的通知。在特定的 Realm 对象上进行通知的注册，这样就可以在此对象被删除时、或者该对象所管理的属性值被修改时获取相应的通知。</li>
<li>只有由 Realm 数据库所管理的对象才能够进行通知注册。</li>
<li>这个通知处理闭包将包含有 ObjectChange 枚举值，表示是否有对象被删除、是否有对象的属性值发生了改变，以及是否有错误发生。</li>
<li><strong>对象被删除的话</strong>，那么这个通知闭包将会带着 ObjectChange.deleted 的参数被调用。这个闭包将不会被再次调用。</li>
<li><strong>对象的属性发生了变更的话</strong>，那么这个闭包将会带着 ObjectChange.change 的参数被调用。这个枚举将会包含有 PropertyChange 类型的数组。每个数组值都包含有被修改的属性名(以字符串的形式提供)、修改前的属性值以及当前的属性值。</li>
<li><strong>有错误发生</strong>，那么这个闭包将会带有 ObjectChange.error 的参数被调用。这个闭包将不会被再次调用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public enum ObjectChange &#123;</div><div class="line">    case error(_: NSError)</div><div class="line">    case change(_: [PropertyChange])</div><div class="line">    case deleted</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class StepCounter: Object &#123;</div><div class="line">  dynamic var steps = 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">let stepCounter = StepCounter()</div><div class="line">let realm = try! Realm()</div><div class="line">try! realm.write &#123;</div><div class="line">    realm.add(stepCounter)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var token : NotificationToken?</div><div class="line">token = stepCounter.addNotificationBlock &#123; change in</div><div class="line">    switch change &#123; // 监听对象</div><div class="line">    case .change(let properties):</div><div class="line">        for property in properties &#123;</div><div class="line">            if property.name == &quot;steps&quot; &amp;&amp; property.newValue as! Int &gt; 1000 &#123;</div><div class="line">                token = nil</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    case .error(let error):</div><div class="line">    case .deleted:</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>界面驱动更新<br>Realm 的通知总是以异步的方式进行传递，因此这些操作永远不会阻塞主 UI 线程，也不会导致应用卡顿。如果需要在主线程同步传递, 并立即更新在UI上, 就可以使用<strong>界面驱动更新 (Interface-Driven writes)。</strong></li>
</ul>
<blockquote>
<p>案例: 假设用户需要向表视图当中插入一个项目。理想状况下，UI 将会将这个操作用动画表现出来，然后当用户完成动作的时候立即启动相应的操作。</p>
<p>然而，此插入操作的 Realm 变更通知将会延时一段时间才进行传递，它会先将一个对象添加到表视图背后所关联的集合当中，随后再尝试去在 UI 当中插入一个新的项目。这种双重插入将会导致 UI 与后台数据之间的数据不一致，而这往往会导致应用崩溃！💥NSInternalInconsistencyException💥</p>
<p>借助 Realm.commitWrite(withoutNotifying:)，这样在执行界面驱动更新的时候，通过传递通知闭包的通知令牌的方式，这样就不会对变更操作执行二次响应。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">token = collection.addNotificationBlock &#123; changes in</div><div class="line">  switch changes &#123;</div><div class="line">  case .initial:</div><div class="line">    tableView.reloadData()</div><div class="line">    break</div><div class="line">  case .update(_, let deletions, let insertions, let modifications):</div><div class="line">    tableView.beginUpdates()</div><div class="line">    tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;),</div><div class="line">                         with: .automatic)</div><div class="line">    tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;),</div><div class="line">                         with: .automatic)</div><div class="line">    tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;),</div><div class="line">                         with: .automatic)</div><div class="line">    tableView.endUpdates()</div><div class="line">    break</div><div class="line">  case .error(let error):</div><div class="line">    break</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func insertItem() throws &#123;</div><div class="line"> // 在主线程中执行</div><div class="line">  collection.realm!.beginWrite()</div><div class="line">  collection.insert(Item(), at: 0)</div><div class="line">  tableView.insertRows(at: [IndexPath(row: 0, section: 0)], with: .automatic)</div><div class="line">  </div><div class="line">  // 确保不会重复执行</div><div class="line">  collection.realm!.commitWrite(withoutNotifying: [token])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h5><p>如果修改了数据模型, 例如新增属性, 就需要进行数据的迁移</p>
<ul>
<li>简单说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/* Realm.Configuration(fileURL: &lt;#T##URL?#&gt;,</div><div class="line"> inMemoryIdentifier: &lt;#T##String?#&gt;,</div><div class="line">  syncConfiguration: &lt;#T##SyncConfiguration?#&gt;, </div><div class="line">  encryptionKey: &lt;#T##Data?#&gt;,</div><div class="line">  readOnly: &lt;#T##Bool#&gt;, </div><div class="line">  schemaVersion: &lt;#T##UInt64#&gt;,</div><div class="line">  migrationBlock: &lt;#T##MigrationBlock?##MigrationBlock?##(Migration, UInt64) -&gt; Void#&gt;,</div><div class="line">  deleteRealmIfMigrationNeeded: &lt;#T##Bool#&gt;,</div><div class="line">  shouldCompactOnLaunch: &lt;#T##((Int, Int) -&gt; Bool)?##((Int, Int) -&gt; Bool)?##(Int, Int) -&gt; Bool#&gt;,</div><div class="line">  objectTypes: &lt;#T##[Object.Type]?#&gt;)</div><div class="line">*/</div><div class="line"></div><div class="line">func configRealmWithUser(_ username:String) &#123;   </div><div class="line">	var config = Realm.Configuration()      </div><div class="line">	config.fileURL = 	config.fileURL?.deletingLastPathComponent()</div><div class="line">            .appendingPathComponent(&quot;\(username).realm&quot;)</div><div class="line">//      config.syncConfiguration = </div><div class="line">//      config.migrationBlock = </div><div class="line">//      config.schemaVersion = </div><div class="line">//  ... </div><div class="line">      </div><div class="line">	Realm.Configuration.defaultConfiguration = config</div><div class="line">&#125;</div><div class="line"></div><div class="line">或:参数的个数任意组合的block形式</div><div class="line">let config = Realm.Configuration(</div><div class="line">	schemaVersion: 1, migrationBlock: &#123; (migration, oldSchemaVersion) in</div><div class="line">	if (oldSchemaVersion &lt; 1) &#123;</div><div class="line">	// 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Realm.Configuration.defaultConfiguration = config</div></pre></td></tr></table></figure>
<ul>
<li>值的更新</li>
</ul>
<blockquote>
<p>在迁移闭包中，我们能够调用Migration().enumerateObjects(ofType: <em>:</em>:) 来枚举特定类型的每个 Object 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 Object 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在 application(application:didFinishLaunchingWithOptions:) 中进行配置</div><div class="line"></div><div class="line">Realm.Configuration.defaultConfiguration = Realm.Configuration(</div><div class="line">  schemaVersion: 1,</div><div class="line">  migrationBlock: &#123; migration, oldSchemaVersion in</div><div class="line">    if (oldSchemaVersion &lt; 1) &#123;</div><div class="line">      // enumerateObjects(ofType:_:) 方法遍历了存储在 Realm 文件中的每一个“Person”对象</div><div class="line">      migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</div><div class="line">        // 将名字进行合并，存放在 fullName 域中</div><div class="line">        let firstName = oldObject![&quot;firstName&quot;] as! String</div><div class="line">        let lastName = oldObject![&quot;lastName&quot;] as! String</div><div class="line">        newObject![&quot;fullName&quot;] = &quot;\(firstName) \(lastName)&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<ul>
<li>属性的重命名</li>
</ul>
<blockquote>
<p>在迁移过程中对类中某个属性进行重命名操作，比起拷贝值和保留关系来说要更为高效。</p>
<p>要在迁移过程中对某个属性就进行重命名的话，请确保您的新模型当中的这个属性是一个全新的名字，它的名字不能和原有模型当中的名字重合。</p>
<p>如果新的属性拥有不同的可空性或者索引设置的话，这些配置会在重命名操作期间生效。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 在 application(application:didFinishLaunchingWithOptions:) 当中使用</div><div class="line"></div><div class="line">Realm.Configuration.defaultConfiguration = Realm.Configuration(</div><div class="line">  schemaVersion: 1,</div><div class="line">  migrationBlock: &#123; migration, oldSchemaVersion in</div><div class="line">    // 我们目前还没有迁移任何东西，因此 oldSchemaVersion == 0</div><div class="line">    if (oldSchemaVersion &lt; 1) &#123;</div><div class="line">      // 重命名操作应该在调用 `enumerateObjects(ofType: _:)` 之外完成</div><div class="line">      migration.renameProperty(onType: Person.className(), from: &quot;yearsSinceBirth&quot;, to: &quot;age&quot;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<ul>
<li>多个版本的控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Realm.Configuration.defaultConfiguration = Realm.Configuration(</div><div class="line">  schemaVersion: 2,</div><div class="line">  migrationBlock: &#123; migration, oldSchemaVersion in</div><div class="line">    // enumerateObjects:block: 遍历了存储在 Realm 文件中的每一个“Person”对象</div><div class="line">    migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in</div><div class="line">      // 只有当 Realm 数据库的架构版本为 0 的时候，才添加 “fullName” 属性</div><div class="line">      if oldSchemaVersion &lt; 1 &#123;</div><div class="line">        let firstName = oldObject![&quot;firstName&quot;] as! String</div><div class="line">        let lastName = oldObject![&quot;lastName&quot;] as! String</div><div class="line">        newObject![&quot;fullName&quot;] = &quot;\(firstName) \(lastName)&quot;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 只有当 Realm 数据库的架构版本为 0 或者 1 的时候，才添加“email”属性</div><div class="line">      if oldSchemaVersion &lt; 2 &#123;</div><div class="line">          newObject![&quot;email&quot;] = &quot;&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">// Realm 数据库会自动执行此数据迁移，然后成功进行访问</div><div class="line">let realm = try! Realm()</div></pre></td></tr></table></figure>
<h5 id="数据库加密"><a href="#数据库加密" class="headerlink" title="数据库加密"></a>数据库加密</h5><ul>
<li>Realm 支持在创建 Realm 数据库时采用64位的密钥对数据库文件进行 AES-256+SHA2 加密。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 产生随机密钥</div><div class="line">var key = Data(count: 64)</div><div class="line">_ = key.withUnsafeMutableBytes &#123; bytes in</div><div class="line">  SecRandomCopyBytes(kSecRandomDefault, 64, bytes)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打开加密文件</div><div class="line">let config = Realm.Configuration(encryptionKey: key)</div><div class="line">do &#123;</div><div class="line">  let realm = try Realm(configuration: config)</div><div class="line">  // 和往常一样使用 Realm 即可</div><div class="line">  let dogs = realm.objects(Dog).filter(&quot;name contains &apos;Fido&apos;&quot;)</div><div class="line">&#125; catch let error as NSError &#123;</div><div class="line">  // 如果密钥错误，`error` 会提示数据库不可访问</div><div class="line">  fatalError(&quot;Error opening realm: \(error)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这样硬盘上的数据都能都采用AES-256来进行加密和解密，并用 SHA-2 HMAC 来进行验证。 每次您要获取一个 Realm 实例时，您都需要提供一次相同的密钥。</p>
</blockquote>
<ul>
<li>密钥并将其安全地存放到钥匙串当中，然后用其加密 Realm。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import Security</div><div class="line"></div><div class="line">func getKey() -&gt; NSData &#123;</div><div class="line">	// 标识符</div><div class="line">	let keychainIdentifier = &quot;io.Realm.EncryptionExampleKey&quot;</div><div class="line">	let keychainIdentifierData = keychainIdentifier.data(using: String.Encoding.utf8, allowLossyConversion: false)!</div><div class="line"></div><div class="line">	// 检测是否存在钥匙串</div><div class="line">	var query: [NSString: AnyObject] = [</div><div class="line">		kSecClass: kSecClassKey,</div><div class="line">		kSecAttrApplicationTag: keychainIdentifierData as AnyObject,</div><div class="line">		kSecAttrKeySizeInBits: 512 as AnyObject,</div><div class="line">		kSecReturnData: true as AnyObject</div><div class="line">	]</div><div class="line">	</div><div class="line">	var dataTypeRef: AnyObject?</div><div class="line">	var status = withUnsafeMutablePointer(to: &amp;dataTypeRef) &#123; SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0)) &#125;</div><div class="line">	if status == errSecSuccess &#123; // 找到就返回</div><div class="line">		return dataTypeRef as! NSData</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 没有找到就新建一个</div><div class="line">	let keyData = NSMutableData(length: 64)!</div><div class="line">	let result = SecRandomCopyBytes(kSecRandomDefault, 64, keyData.mutableBytes.bindMemory(to: UInt8.self, capacity: 64))</div><div class="line">	assert(result == 0, &quot;Failed to get random bytes&quot;)</div><div class="line"></div><div class="line">	// 存储钥匙串</div><div class="line">	query = [</div><div class="line">		kSecClass: kSecClassKey,</div><div class="line">		kSecAttrApplicationTag: keychainIdentifierData as AnyObject,</div><div class="line">		kSecAttrKeySizeInBits: 512 as AnyObject,</div><div class="line">		kSecValueData: keyData</div><div class="line">	]</div><div class="line"></div><div class="line">	status = SecItemAdd(query as CFDictionary, nil)</div><div class="line">	assert(status == errSecSuccess, &quot;Failed to insert the new key in the keychain&quot;)</div><div class="line">	return keyData</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 添加</div><div class="line">autoreleasepool &#123;</div><div class="line">	let configuration = Realm.Configuration(encryptionKey: getKey() as Data)</div><div class="line">	let realm = try! Realm(configuration: configuration)</div><div class="line"></div><div class="line">	// Add an object</div><div class="line">	try! realm.write &#123;</div><div class="line">		let dog = Dog()</div><div class="line">		dog.name = &quot;xxxx&quot;</div><div class="line">		realm.add(dog)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 查询</div><div class="line">autoreleasepool &#123;</div><div class="line">	let configuration = Realm.Configuration(encryptionKey: getKey() as Data)</div><div class="line">	let realm = try! Realm(configuration: configuration)</div><div class="line">	if let dogName = realm.objects(Dog.self).first?.name &#123;</div><div class="line">	print(dogName)</div><div class="line">	  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>加密过的 Realm 只会带来很少的额外资源占用（通常最多只会比平常慢10%）。</p>
<p>Realm 的加密 API 目前支持 iOS、OS X 以及 WatchKit 平台，但 不支持 watchOS 平台，因为 Realm 加密机制使用的 <mach mach.h=""> 以及 <mach exc.h=""> API 被标记为__WATCHOS_PROHIBITED` 了。</mach></mach></p>
</blockquote>
<h5 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h5><blockquote>
<p>Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：</p>
<p>（1）类名称的长度最大只能存储 57 个 UTF8 字符。</p>
<p>（2）属性名称的长度最大只能支持 63 个 UTF8 字符。</p>
<p>（3）NSData 以及 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。</p>
<p>（4）对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。</p>
</blockquote>
<p>#### </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/03/Xcode8新特性/" rel="next" title="Xcode8新特性">
                <i class="fa fa-chevron-left"></i> Xcode8新特性
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/08/数据链路层/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/06/26/RealmSwift/"
           data-title="" data-url="https://github.com/icoderRo/2017/06/26/RealmSwift/">
      </div>
    
  </div>


        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">simon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"blog-ro"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
