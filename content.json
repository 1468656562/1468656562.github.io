{"meta":{"title":"simon小📚坊","subtitle":"脚踏实地,仰望星空","description":"嗨, 我是simon","author":"Mr.Simon","url":"https://github.com/icoderRo"},"pages":[{"title":"tags","date":"2016-10-07T12:07:13.000Z","updated":"2016-10-07T10:07:23.000Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/icoderRo/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-10-07T12:07:13.000Z","updated":"2016-10-07T10:10:26.000Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/icoderRo/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"漫谈iOS App架构 MV“X”","slug":"漫谈iOS App MVX架构 ","date":"2017-03-14T16:00:00.000Z","updated":"2017-08-27T10:15:05.000Z","comments":true,"path":"2017/03/15/漫谈iOS App MVX架构 /","link":"","permalink":"https://github.com/icoderRo/2017/03/15/漫谈iOS App MVX架构 /","excerpt":"前言当我们在开发iOS应用程序的时候, 随着业务的不断添加, 对应代码模块之间的复杂度与耦合也随之的增加, 不断的提升着开发的复杂度与维护的高成本, 为了能提高开发和维护的效率, 甚至于是测试的效率, 设计符合当前业务模式的架构是非常有必要的。MVC是经典的设计模式, 但是C的职责太大, 随着业务的发展, C俨然成为代码聚集的重灾区, 伴随着便是为了解决这一问题而诞生的MVCS、MVP、MVVM、VIP、VIPER等模式, 然而万变不离其宗, 最终的设计都离不开MVC这个根基。 MVC模式传统的MVC经典的MVC, View是并没有任何的界限, 三个模块之间是有非常强的耦合, 极大的降低了三者的复用性与可测试性, 并不适合作为iOS应用层的架构。","text":"前言当我们在开发iOS应用程序的时候, 随着业务的不断添加, 对应代码模块之间的复杂度与耦合也随之的增加, 不断的提升着开发的复杂度与维护的高成本, 为了能提高开发和维护的效率, 甚至于是测试的效率, 设计符合当前业务模式的架构是非常有必要的。MVC是经典的设计模式, 但是C的职责太大, 随着业务的发展, C俨然成为代码聚集的重灾区, 伴随着便是为了解决这一问题而诞生的MVCS、MVP、MVVM、VIP、VIPER等模式, 然而万变不离其宗, 最终的设计都离不开MVC这个根基。 MVC模式传统的MVC经典的MVC, View是并没有任何的界限, 三个模块之间是有非常强的耦合, 极大的降低了三者的复用性与可测试性, 并不适合作为iOS应用层的架构。 推荐的MVC苹果希望的MVC的模式, 由Controller充当View与Model之间的协调器, View和model之间并没有直接的联系。在这种模式下, View和model的可复用性与测试性得到极大的提高, 由于Controller作为iOS应用层的入口并且所有View与Model之间协调的代码都集中于此, 势必会造成Controller的严重拥堵, 因此MVC也被称呼Massive View Controller。 实际的MVC在Cocoa的MVC模式中, Controller管理着View的生命周期, Controller中拥有着View与Model, 并且负责更新View与Model, Controller中会承担一切的代理或者数据源, 同时还负责一些网络请求的发起/取消等任务。View中也拥有着Model, View的最大的任务就是向Controller传递用户的事件。Model可以分为胖Model和瘦Model, 不管哪种model, 其最终都是为了将数据直接应用到View上。 示例 - View “talk is cheap. show me the code” – Linus Torvalds 正向流程在iOS中, Controller作为最小单元, 通常来说所有视图展示逻辑与交互的逻辑都需要借助于Controller(Window除外), 所以入口必然是Controller, 在Controller中初始化View与获取Model后将二者关联 初始化View, 后续View的生命周期将有Controller管理 123456/// Controllerfileprivate lazy var mvcView: MVCView = &#123; [unowned self] in let mvcView = MVCView(frame: self.view.bounds) self.view.addSubview(mvcView) return mvcView&#125;() 获取Model 12345/// Controllerfileprivate lazy var mvcModel: MVCModel = &#123; let mvcModel = MVCModel() return mvcModel&#125;() 关联View与Model, 数据将展示在View上 12345678/// Controllerfunc changeName() &#123; let index = arc4random() % 9 let model = MVCModel() model.name = \"simon\" + \"\\(index)\" mvcView.model = model&#125; 反向流程View接收来自用户的事件, 将事件传递给Controller, Controller通知Model更改数据。 View接收用户事件, 并将事件传递给Controller 123456/// Viewextension MVCView &#123; @objc fileprivate func clickName() &#123; clickNameClosure?() &#125;&#125; Controller接受到事件, 并更新Model 1234/// Controller mvcView.clickNameClosure = &#123;[weak self] in self?.changeName()&#125; 胖Model: 胖Model包含了部分弱业务逻辑。胖Model可以减轻Controller对于弱业务逻辑的负担(强业务逻辑任就交给Controller)，Controller从胖Model这里拿到数据之后，不需要做额外的操作/只做非常少的操作，就能够将数据直接应用在View上。 瘦Model: 瘦Model只负责业务数据的表达，无论强/弱业务都交给Controller去处理。瘦Model需要配套各种工具类或方法来对弱业务做抽象，强业务依旧交给Controller 从开发的速度来讲, Cocoa的MVC是最好的架构方案 MVP模式在MVP的模式中引入了一个Presenter来协调View与Model之间的关联, Persenter中拥有View与Model, 并处理来自View的事件。View只提供接口, 并负责将事件传递给Presenter。model负责将自己提供给Persenter。Controller作为展示的入口, 负责组装三者的关系与路由, 也可以将Controller看做是View的一部分。 示例 - View正向流程与MVC相似, 入口为Controller, Controller中负责获取Model、初始化View与Presenter, 将View于Model绑定与Persenter 初始化View与Persenter 1234567891011/// Controllerfileprivate lazy var mvpView: MVPView = &#123;[unowned self] in let mvpView = MVPView(frame: self.view.bounds) self.view.addSubview(mvpView) return mvpView&#125;()fileprivate lazy var presenter: Presenter = &#123; let presenter = Presenter() return presenter &#125;() 获取Model 12345/// Controllerfileprivate lazy var mvpModel: MVPModel = &#123; let mvpModel = MVPModel() return mvpModel&#125;() 关联Presenter 123/// Controller presenter.mvpView = mvpView presenter.mvpModel = mvpModel Presenter操作Model, 更新View的展示 123456789/// Controllerpresenter.setName()presenter:func setName() &#123; let index = arc4random() % 9 mvpModel?.name = \"simon\" + \"\\(index)\" mvpView?.setName(mvpModel?.name)&#125; 反向流程View接收来自用户的事件, 将事件传递给Persenter, Persenter通知Model更改数据。 View接收用户事件, 并将事件传递给Presenter 12345678/// View@objc fileprivate func clickName() &#123; clickNameClosure?()&#125; @objc fileprivate func clickText() &#123; delegate?.mvpView?(self, didClickText: \"simon\")&#125; Presenter接收到事件, 并更新Model 12345678910111213141516171819202122/// PresentermvpView?.delegate = self as MVPViewDelegate mvpView?.clickNameClosure = &#123;[weak self] in self?.setName()&#125;extension Presenter: MVPViewDelegate &#123; func setName() &#123; let index = arc4random() % 9 mvpModel?.name = \"simon\" + \"\\(index)\" mvpView?.setName(mvpModel?.name) &#125; func mvpView(_ mvpView: MVPView, didClickText text: String) &#123; mvpModel?.name = text self.mvpView?.setName(text) &#125;&#125; 思考MVP模式会增加一定量代码量, 在业务逻辑复杂, 规模较大的场景下Presenter也很容易成为代码聚集的重灾区, 相对的此模式下代码的可测性良好, 任务也比较均摊。 以上基于PV(Passive View) MVP。顾名思义, PV是一个被动的View, View中的操作由Presenter来操作。 与之对应的是SoC(Supervising Controller) MVP, 此模式主要是为了降低Presenter的复杂度, 将数据绑定和格式化等简单的UI处理逻辑转移到View中。 MVVM模式MVVM是MV“X”系列中最新的模式, 对于MVVM的使用, 颇具争议。被误解的MVC和被神化的MVVM在MVVM模式中引入了一个ViewModel来协调处理View与Model之间的联系。 MVVM中View中, 除了子View, 只拥有ViewModel, 并负责绑定ViewModel。ViewModel中拥有Model, 负责更新Model。Controller与MVP模式中类似, 负责组装三者的关系与路由。 示例 - View正向流程与MVC、MVVM相似, 入口为Controller, Controller中负责初始化ViewModel与View, 获取model, 关联三者 初始化View与ViewModel 123456789101112/// Controllerfileprivate lazy var mvvmView: MVVMView = &#123; [unowned self] in let mvvmView = MVVMView(frame: self.view.bounds) self.view.addSubview(mvvmView) return mvvmView&#125;()fileprivate lazy var mvvmVM: MVVMViewModel = &#123; let mvvmVM = MVVMViewModel() return mvvmVM&#125;() 获取model 1234567/// Controllerfileprivate lazy var mvvmModel: MVVMModel = &#123; let mvvmModel = MVVMModel() mvvmModel.name = \"simon Init\" return mvvmModel&#125;() 关联彼此 1234/// ControllermvvmView.mvvmVM = mvvmVM // 绑定mvvmVM.mvvmModel = mvvmModel View中绑定ViewModel 123456789101112131415/// Viewvar mvvmVM: MVVMViewModel? &#123; didSet &#123; mvvmVM?.addObserver(self, forKeyPath: \"name\", options: [.new, .initial], context: nil) &#125;&#125; override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if keyPath == \"name\" &#123; let name = change?[.newKey] as? String setName(name) &#125;&#125; 反向流程View接收来自用户的事件, 将事件传递给ViewModel, ViewModel通知Model更改数据。 View接收用户事件, 并将事件传递给ViewModel 12345/// ViewModel@objc fileprivate func clickName() &#123; mvvmVM?.clickName()&#125; ViewModel接收到事件, 并更新Model与ViewModel的Name, 由于监听了ViewModel的Name属性, 所以View的视图也会随之跟着更改 12345678910/// ViewModelextension MVVMViewModel &#123; func clickName() &#123; let index = arc4random() % 9 let mvvmModel = MVVMModel() mvvmModel.name = \"simon\" + \"\\(index)\" self.mvvmModel = mvvmModel &#125;&#125; 思考1在示例中, MVVM的任务均摊非常合理, 可测试性也非常的高; 但是MVVM的View需要设置绑定ViewModel来更新状态, 而MVP中的View只需要监听Presenter的事件。 示例 - TableView此tableView中并未使用双向绑定, 是笔者觉得在不引入RxSwift的基础上, 比较合适的划分。ViewModel中拥有Model, 并负责与Cell视图的数据关联。Controller作为入口, 负责初始化View与ViewModel, 并成为代理与数据源和提供路由。 正向流程 初始化TableView与ViewModel 12345678910111213/// Controllerfileprivate lazy var mvvmVM: MVVMVM = &#123;return $0&#125;(MVVMVM()) fileprivate lazy var tableView: UITableView = &#123;[unowned self] in let tableView = UITableView(frame: self.view.bounds) tableView.delegate = self tableView.dataSource = self tableView.backgroundColor = .yellow tableView.rowHeight = 70 tableView.register(UINib(nibName: \"MVVMCell\", bundle: nil), forCellReuseIdentifier: \"cellId\") return tableView&#125;() Controller成为数据源与代理, 并让ViewModel与Cell绑定 123456789101112131415161718/// Controllerextension MVVMController: UITableViewDelegate, UITableViewDataSource &#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return mvvmVM.models.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: \"cellId\") mvvmVM.setCell(cell!, indexPath.row) return cell! &#125; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; &#125;&#125; 获取Model 123456789101112131415/// ViewModelextension MVVMVM &#123; func loadData() &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123; for i in 0..&lt;20 &#123; let model = MVVMModel() model.name = \"simon\" + \"\\(i)\" self.models.append(model) &#125; self.reloadData?() &#125; &#125;&#125; 通知TableView刷新 12345/// ControllermvvmVM.reloadData = &#123;[weak self] in self?.tableView.reloadData()&#125; 反向流程 Cell接收用户的事件, 传递给ViewMode 12345/// Cell@IBAction func clickName(_ sender: UIButton) &#123; clickNameClosure?(index)&#125; ViewMode更新Model 12345678/// ViewModelcell.clickNameClosure = &#123;[weak self] index in let model = self?.models[index] model?.name = \"test test..\" self?.reloadData?()&#125; 通知TableView刷新 12345/// ControllermvvmVM.reloadData = &#123;[weak self] in self?.tableView.reloadData()&#125; 思考2在示例中, Controller负责代理与数据源和路由。ViewModel负责加工Model, 绑定Cell。从方便开发的角度看, 假设代理和数据源交给ViewModel去处理, 当cell发出跳转至下一控制器, 需要ViewModel通知当前的Controller去执行相应的操作, 与其这样需要中转, 不如让Controller直接去处理。从职责明确的角度看, 需要将数据源与代理交由ViewModel接管。 在MVVM有一个核心就是双向绑定, 实现双向绑定需要引入更多复杂的框架: 基于KVO的绑定库如 RZDataBinding 和 SwiftBond 函数响应式编程，ReactiveCocoa、RxSwift等 函数响应式编程的学习曲线相对比较陡峭, 在团队中推广需要一定的时间。 数据的绑定会使得Bug很难被调试,开发者需要非常清楚整个函数调用的流程, 如果是引入的框架处了问题, 那更是地狱级的惨状。 大量数据的绑定肯定需要花费更多的内存 总结没有最好的架构, 只有最合适的架构。应用层架构的选择需要根据公司的业务特点、开发者的能力等, 视具体情况具体分析。假设业务逻辑比较单一,并不需要单元测试, 选择Cocoa的MVC模式开发就是非常好的选择; 假设你的业务逻辑比较复杂, 那么采用MVVM, 甚至于VIPER模式(笔者没实际用过, 可以确定的是, 各模块间的逻辑会相对复杂, 代码量也会加倍的递增)都是非常合适的。这总结貌似有点多余, 感受确是如此。 引用示例Demo iOS 架构模式","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://github.com/icoderRo/tags/架构/"}]},{"title":"Realm-Swift3.0","slug":"RealmSwift","date":"2017-01-19T16:00:00.000Z","updated":"2017-08-17T14:45:09.000Z","comments":true,"path":"2017/01/20/RealmSwift/","link":"","permalink":"https://github.com/icoderRo/2017/01/20/RealmSwift/","excerpt":"Realm-Swift3.0 简介Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScript、Swift、Xamarin平台 Realm的优点在官方上有很多的说明, 略举两点: 1.易上手:想比于Core Data 和SQLite, Realm的学习成本相对来说会比较低, 毫不夸张的说, 把官方的文档和Demo看完一遍, 就可以快速的上手开发功能。 2.可视化: Realm提供了一个轻量级的数据库查看工具, 在App Store中下载Realm Browser, 相比于SQLite, 你可能需要去下载付费或者破解版的Navicat、SQL Manager等软件会方便很多, 借助于Realm Browser调试Realm数据库很便捷。 使用模拟器进行调试 通过执行realm.configuration.fileURL打印出Realm数据库的地址, Finder中跳转进对应的路径, 用Realm Browser打开对应的.realm文件就可以看到数据啦。 使用真机调试 Xcode-&gt;Window-&gt;Devices,然后找到对应的设备与项目,导出xcappdata文件后,显示包内容进入Documents,使用Realm Browser打开.realm文件即可.","text":"Realm-Swift3.0 简介Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite,支持Java、Objective-C、JavaScript、Swift、Xamarin平台 Realm的优点在官方上有很多的说明, 略举两点: 1.易上手:想比于Core Data 和SQLite, Realm的学习成本相对来说会比较低, 毫不夸张的说, 把官方的文档和Demo看完一遍, 就可以快速的上手开发功能。 2.可视化: Realm提供了一个轻量级的数据库查看工具, 在App Store中下载Realm Browser, 相比于SQLite, 你可能需要去下载付费或者破解版的Navicat、SQL Manager等软件会方便很多, 借助于Realm Browser调试Realm数据库很便捷。 使用模拟器进行调试 通过执行realm.configuration.fileURL打印出Realm数据库的地址, Finder中跳转进对应的路径, 用Realm Browser打开对应的.realm文件就可以看到数据啦。 使用真机调试 Xcode-&gt;Window-&gt;Devices,然后找到对应的设备与项目,导出xcappdata文件后,显示包内容进入Documents,使用Realm Browser打开.realm文件即可. Xcode插件Realm的Xcode插件令 Realm 模型的创建更加方便.gitHub下载一个Demo传送门, 找到里面的Plugin目录下的RealmPlugin.xcodeproj并进行编译，重启 Xcode之后插件即可生效。 纯SWift版的安装 使用 Realm 构建应用的基本要求：iOS 8 及其以上版本, macOS 10.9 及其以上版本，此外 Realm 支持 tvOS 和 watchOS 的所有版本。 需要使用 Xcode 8.0 或者以后的版本。Realm Swift 2.3.0 是最后一个支持 Swift 2.x 及 Xcode 7.3 的版本。 方法1:Dynamic Framework 下载Realm的最新版本并解压。 前往您 Xcode 工程的”General”设置页。前往适合您项目的 Swift 版本目录，从其中的 ios文件夹中，拖拽RealmSwift.framework 和Realm.framework到”Embedded Binaries”选项中，确认Copy items if needed被选中（除非您的项目中需要在多个平台中使用 Realm），并点击Finish。 在您的单元测试目标的”Build Settings”中，添加RealmSwift.framework的上级目录到您的”Framework Search Paths”中。 如果您打算在您的 iOS、tcOS 或者 watchOS 工程中使用 Realm，请在您的 app 目标的“Build Phases”中创建一个新的”Run Script Phase”，并在文本框中写入bash &quot;${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/Realm.framework/strip-frameworks.sh&quot;因为要绕过这个APP商店提交的bug，这一步在打包二进制发布版本时是必须。 方法2:Carthage 安装 Carthage 0.17.0 或者更高版本 在Carthage 中添加github realm/realm-cocoa 运行 carthage update 从 Carthage/Build/ 目录下对应平台文件夹中，将 RealmSwift.framework 和 Realm.framework 拖曳到您 Xcode 工程General设置项的Linked Frameworks and Libraries选项卡中 iOS/tvOS/watchOS: 在您应用目标的Build Phases设置选项卡中，点击“+”按钮并选择“New Run Script Phase”。在新建的Run Script中，填写:/usr/local/bin/carthage copy-frameworks 在Input Files内添加您想要使用的框架路径，例如: 1$(SRCROOT)/Carthage/Build/iOS/RealmSwift.framework 方法3:CocoaPods 运行 pod repo update，以确保 CocoaPods 能够获取到 Realm 的最新版本 在Podfile中，添加use_frameworks!和pod ‘RealmSwift’ 到您的主要和测试目标 如果您使用的是 Xcode 8，那么将下面代码复制到您的 Podfile 底部，以便在必要的时候更新 Swift 的版本： 123456 installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['SWIFT_VERSION'] = '3.0' end endend 在终端运行 pod install,采用 CocoaPods 生成的 .xcworkspace 来运行工程！ 注意:我这边选用CocoaPods的方式安装, 安装的时间还是需要比较多的, 如果发现pod search RealmSwift版本比较低, 先升级一下pod索引库 术语支持的类型 Realm 支持以下的属性类型：Bool、Int8、Int16、Int32、Int64、Double、Float、String、Date以及Data。 也可以使用 List 和 Object 来建立诸如一对多、一对一之类的关系模型，此外 Object 的子类也支持此功能。 数据模型(Object) Realm数据模型是基于标准Swift类来进行定义的, 通过简单的集成Object或者其子类, 就可以创建一个新的Realm数据模型对象, 可以给Realm模型添加方法和协议等, 用法和swift中的其他对象类似 Realm 模型的属性需要设置为dynamic var特性，以便其能够被数据库底层数据所访问。List 和 RealmOptional 不能被设为动态属性，因为泛型属性不能在 Objective‑C 运行时中被识别，而 dynamic 属性会被用于进行动态调度。此外这两个类型应当始终声明为 let 为对象的类型列表添加目标类型的属性，或者List，就可以创建数据关系(relationship)和嵌套数据结构(nested data structure)。 关系(Relationships) Object 能够借助Object以及List属性和另一个Object建立联系, List的接口和Array非常类似, 能够通过索引下表进行访问, 不同之处在于, List中只能存放简单的Object子类的类型 事务(Transactions) Realm 写入操作是同步以及阻塞的，并不会异步运行。如果线程 A 开始了一个写入操作，接着在线程 A 结束之前，线程 B 又对同一个 Realm 数据库开始了写入操作，那么线程 A 必须在线程 B 的写入操作进行之前，完成自己的写入操作，并将事务提交。写入操作总会在 beginWrite() 操作进行的时候自动刷新，因此重复写入 (overlapping write) 并不会产生竞争条件。 由于写入事务像其余硬盘读写操作一样，会出现失败的情况，因此 Realm.write() 以及 Realm.commitWrite() 可以加上 throws标记。因此你可以处理和恢复诸如硬盘空间溢出之类的错误。此外，其他的错误都无法进行恢复。 结果集(Results) 通过查询操作，Realm 将会返回包含 Object 集合的 Results 实例。Results 的表现和 Array 十分相似，并且包含在 Results 中的对象能够通过索引下标进行访问。 所有的查询在 Realm 中都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。 查询结果并不是数据的拷贝：修改查询结果会直接修改硬盘上的数据。 使用创建数据库 默认配置的 Realm 数据库通过调用 Realm() 来初始化以及访问我们的 realm 变量。这个方法将会返回一个 Realm 对象，并指向您应用的 Documents (iOS) 或者 Application Support (OS X)文件夹下的一个名为“default.realm”的文件 1let realm = try? Realm() 配置Realm通过Realm.Configuration您可以配置诸如 Realm 文件在何处存储之类的信息。配置同时也可以在每次您需要使用 Realm 实例的时候传递给Realm(configuration: config)，或者可以通过 Realm.Configuration.defaultConfiguration = config 来为默认的 Realm 数据库进行配置 123456789func configRealmWithUser(_ username:String) &#123; var config = Realm.Configuration() config.fileURL = config.fileURL?.deletingLastPathComponent() .appendingPathComponent(\"\\(username).realm\") Realm.Configuration.defaultConfiguration = config &#125; 使用方式 12configRealmWithUser(\"simon\")let realm = try! Realm() 内存数据库通常情况下，Realm 数据库是存储在硬盘中的，但是您能够通过设置 inMemoryIdentifier 而不是设置Realm.Configuration 中的 fileURL 属性，以创建一个完全在内存中运行的数据库。 1let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: \"MyInMemoryRealm\")) 内存数据库在每次程序运行期间都不会保存数据。但是，这不会妨碍到 Realm 的其他功能，包括查询、关系以及线程安全。 假如您需要灵活的数据读写但又不想储存数据的话，那么内存数据库对您来说一定是一个不错的选择。 内存数据库会在临时文件夹中创建多个文件，用来协调处理诸如跨进程通知之类的事务。 实际上没有任何的数据会被写入到这些文件当中，除非操作系统由于内存过满需要清除磁盘上的多余空间。 注意： 当所有具备特定标识符的Realm 内存数据库实例超出可用范围，但是却没有被引用的话，那么 Realm 内存数据库中的所有数据都会被删除。我们建议您在应用的生命周期内，保持对 Realm 内存数据库的强引用。（对于存储在硬盘当中的 Realm 数据库而言，这并不是必须的操作。） CRUD对象123456789101112131415class Person: Object &#123; dynamic var name = \"\" dynamic var age = 0&#125;class Dog: Object &#123; dynamic var id = 0 dynamic var name = \"\" dynamic var age = 0 override static func primaryKey() -&gt; String? &#123; return \"id\" &#125;&#125; 新增 以对象的形式创建: 此创建方式, 如果有设置主键, 则不能创建相同的主键 1234let mydog = Dog()mydog.name = \"aa\"mydog.age = 20mydog.id = 5 以数组的形式创建: 如果主键相同,则会覆盖之前的数据, 没有设置主键, 则update只能为false 123realm.create(Dog.self, value: [6, \"sssssss\", 747], update: true) 以字典的形式创建: 如果主键相同,则会覆盖之前的数据, 没有设置主键, 则update只能为false 123realm.create(Dog.self, value: [\"id\":6, \"name\": \"sada\", \"age\":77], update: true) 复合模型 1234567891011121314151617// 基础模型class Animal: Object &#123; dynamic var age = 0&#125;// 包含有 Animal 的模型class Duck: Object &#123; dynamic var animal: Animal? = nil dynamic var name = \"\"&#125;class Frog: Object &#123; dynamic var animal: Animal? = nil dynamic var dateProp = NSDate()&#125;// 用法let duck = Duck(value: [ \"animal\": [ \"age\": 3 ], \"name\": \"Gustav\" ]) Data 类型存储(本地图片为例) 1234567891011121314151617class DogPortrait:Object &#123; dynamic var data:Data?&#125;let imageURL = Bundle.main.url(forResource: \"sssss.png\", withExtension: nil)!let imageData = try! Data(contentsOf: imageURL)let portrait = DogPortrait()portrait.data = imageDatatry! realm.write &#123; realm.add(portrait)&#125;// 查询let portraits = realm.objects(DogPortrait.self)let imgData = portraits[0].data 查询 Realm无法直接限制查询数量。 1let dogs = try! Realm().objects(Dog.self) 需要查询限制数量, 可以借助for循环 1234for i in 0..&lt;5 &#123; let dog = dogs[i] // ...&#125; Realm为何无法限制查询数量？ 通常查询数据库数据时，我们可以在sql语句中添加一些限制语句（比如rownum，limit，top等）来限制返回的结果集的行数。但我们使用Realm会发现，它没有这种分页功能，感觉不管查什么都是把所有的结果都捞出来。比如我们只要User表的前10条数据，那么做法是先查询出所有的User数据，再从结果集中取出前10条数据。有人可能会担心，如果数据库中数据非常多，那每次都这么查不会影响性能吗？其实大可放心，由于Realm都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。不像通常数据库，查询后，查询结果是从数据库拷贝一份出来放在内存中的。而Realm的查询结果应该说是数据库数据的引用，就算你查出来，如果不用也不会占用什么内存。 可以通过Predicate条件查询特定数据 1234567let results1 = realm.objects(Dog.self)let results = realm.objects(Dog.self).filter(NSPredicate(format: \"name contains 'A'\")) let result2 = results.filter(\"age &gt; 18\")let results3 = realm.objects(Dog.self).filter(NSPredicate(format: \"name contains 'A'\")).filter(\"age &gt; 16\").sorted(byKeyPath: \"age\") // 升序 1.NSPredicate： 比较操作数(comparison operand)可以是属性名称或者某个常量，但至少有一个操作数必须是属性名称；比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!=, 以及 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 属性类型的比较，比如说 age == 45；相等比较 ==以及!=，比如说Results().filter(“company == %@”, company)比较操作符 == and != 支持布尔属性；对于 NSString 和 NSData 属性来说，我们支持 ==、!=、BEGINSWITH、CONTAINS 以及 ENDSWITH 操作符，比如说 name CONTAINS ‘Ja’；字符串支持忽略大小写的比较方式，比如说 name CONTAINS[c] ‘Ja’ ，注意到其中字符的大小写将被忽略；Realm 支持以下复合操作符：“AND”、“OR” 以及 “NOT”。比如说 name BEGINSWITH ‘J’ AND age &gt;= 32；包含操作符 IN，比如说 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；==、!=支持与 nil 比较，比如说 Results().filter(“ceo == nil”)。注意到这只适用于有关系的对象，这里 ceo 是 Company 模型的一个属性。ANY 比较，比如说 ANY student.age &lt; 21注意，虽然我们不支持复合表达式类型(aggregate expression type)，但是我们支持对对象的值使用 BETWEEN 操作符类型。比如说，Results.filter(“age BETWEEN %@”, [42, 43]])。 2.排序: sorted(byKeyPath:) 以及 sorted(byProperty:) 不支持将多个属性用作排序基准，此外也不能链式调用（只有最后一个 sorted 会被调用）。如果要按多个属性进行排序的话，请使用 sorted(by:) 方法，然后向其中传递多个 SortDescriptor 对象 修改 直接更新内容, 在写入事务中通过设置某个对象的属性从而完成对象的更新操作 12mydog.name = \"aa\"mydog.age = 20 通过主键更新, 数据模型中设置了主键的话，可以使用Realm().add(_:update:)来更新对象，或者当对象不存在时插入新的对象。 12345678let mydog = Dog()mydog.name = \"aa\"mydog.age = 20mydog.id = 5try! realm.write &#123; realm.add(mydog, update: true)&#125; 键值编码Object、Result 以及 List都遵守键值编码(KVC）机制, 适用于大量更新数据 123try? realm.write &#123; results.first?.setValue(\"33\", forKeyPath: \"age\") &#125; 删除 删除数据库中的所有数据 1234let realm = try! Realm()try? realm.write &#123; realm.deleteAll() &#125; 删除某条数据 123456let realm = try! Realm() let results = realm.objects(Dog.self).filter(\"age = 33\")realm.beginWrite()realm.delete(dog)try? realm.commitWrite() 属性Realm 模型的属性需要设置为dynamic var特性，以便其能够被数据库底层数据所访问。List 和 RealmOptional 不能被设为动态属性，因为泛型属性不能在 Objective‑C 运行时中被识别, List 和 RealmOptional应该用let修饰 类型 非可选值形式 可选值形式 Bool dynamic var value = false let value = RealmOptional() Int dynamic var value = 0 let value = RealmOptional() Float dynamic var value: Float = 0.0 let value = RealmOptional() Double dynamic var value: Double = 0.0 let value = RealmOptional() String dynamic var value = “” dynamic var value: String? = nil Data dynamic var value = NSData() dynamic var value: NSData? = nil Date dynamic var value = NSDate() dynamic var value: NSDate? = nil Object n/a: 必须是可选值 dynamic var value: Class? List let value = List() n/a: 必须是非可选值 LinkingObjects let value = LinkingObjects(fromType: Class.self, property: “property”) n/a: 必须是非可选值 索引属性重写 Object.indexedProperties() 方法可以为数据模型中需要添加索引的属性建立索引;Realm 支持字符串、整数、布尔值以及 NSDate 属性作为索引;对属性进行索引可以减少插入操作的性能耗费，加快比较检索的速度。 123override static func indexedProperties() -&gt; [String] &#123; return [\"id\"]&#125; 主键重写 Object.primaryKey() 可以设置模型的主键。声明主键之后，对象将允许进行查询，并且更新速度更加高效，而这也会要求每个对象保持唯一性。 一旦带有主键的对象被添加到 Realm 之后，该对象的主键将不可修改。 123override static func primaryKey() -&gt; String? &#123; return \"id\"&#125; 忽略属性重写 Object.ignoredProperties() 可以防止 Realm 存储数据模型的某个属性。Realm 将不会干涉这些属性的常规操作，它们将由成员变量(ivar)提供支持，并且您能够轻易重写它们的 setter 和 getter。 12345678dynamic var tmpID = 0var name: String &#123; // 只读属性将被自动忽略 return \"ignoredProperties\"&#125; override static func ignoredProperties() -&gt; [String] &#123; return [\"tmpID\"]&#125; 可空属性 String、NSDate 以及 NSData 属性通过标准的 Swift 语法声明为可空类型或者非空类型; 声明可空的数值类型可以使用RealmOptional。 1234567891011121314151617class Person: Object &#123; // 可选的字符串属性，默认为 nil dynamic var name: String? = nil // 可选的 int 属性，默认为 nil // RealmOption 属性应该始终声明为常量 // 因为目前直接给这个属性进行赋值并不会起任何作用 let age = RealmOptional&lt;Int&gt;()&#125;let realm = try? Realm()var objc: optionObjc?try? realm?.write &#123;objc = realm?.create(optionObjc.self, value: [\"sx\", 12], update: false) // 读取或者修改 `RealmOptional` 可以通过 `value` 属性实现 objc?.age.value = 20 &#125; 关系 对一关系:对于多对一或一对一的关系, 只需要声明一个Object子类类型的属性即可: 12345678910class Dog: Object &#123; dynamic var id = 0 dynamic var name = \"\" dynamic var age = 0 dynamic var owner: Person? // 可选&#125;let dog = Dog()let person = Person()dog.owner = person 对多关系:通过 List 类型的属性您可以定义一个对多关系。List中可以包含简单类型的Object，其接口与可变的Array非常类似。注意使用let 123456789101112131415class Person: Object &#123; dynamic var name = \"\" dynamic var age = 0 let dogs = List&lt;Dog&gt;()&#125;let results = try?Realm().objects(Dog.self).filter(\"age &gt; 18\") let person = Person() person.dogs.append((results?.first)!) person.dogs.append((results?.last)!) try? Realm().write &#123; try? Realm().add(person)&#125; 反向关系Realm 提供了链接对象 (linking objects) 属性来表示反向关系 例如，一个 Dog 对象可以拥有一个名为 owners 的链接对象属性，这个属性中包含了某些 Person 对象，而这些 Person 对象在其 dogs 属性中包含了这一个确定的 Dog 对象。您可以将 owners 属性设置为 LinkingObjects 类型，然后指定其关系，说明其当中包含了 Person 对象。 123456789101112131415161718192021222324252627class Dog: Object &#123; dynamic var name = \"\" dynamic var age = 0 // Realm 并不会存储这个属性，因为这个属性只定义了 getter // 定义“owners”，和 Person.dogs 建立反向关系 let owners = LinkingObjects(fromType: Person.self, property: \"dogs\") &#125;func RealmBackLink() &#123; let realm = try! Realm() let dog1 = Dog() dog1.name = \"ssssx\" dog1.age = 22 let owner = Person() owner.dogs.append(dog1) try! realm.write &#123; // 只需存储person即可 realm.add(owner) &#125; let dogs = realm.objects(Dog.self) let ownerName = dogs.first?.owners.map&#123;$0.name&#125; print(ownerName)&#125; 多线程需要注意的一件事情就是不能让多个线程都持有同一个 Realm 对象的 实例 。如果多个线程需要访问同一个对象，那么它们分别会获取自己所需要的实例（否则在一个线程上发生的更改就会造成其他线程得到不完整或者不一致的数据） 跨线程传递实例Object 的未管理实例（unmanaged) 可以安全地跨线程传递, 管理实例皆受到线程的限制(Realm、Object、Results 或者 List), 这意味着它们只能够在被创建的线程上使用。Realm 提供了一个机制，通过以下三个步骤来保证受到线程限制的实例能够安全传递: 通过受到线程限制的对象来构造一个 ThreadSafeReference 将此 ThreadSafeReference 传递给目标线程或者队列 通过在目标 Realm 上调用 Realm.resolve(_:) 来解析此引用 12345678910111213141516let person = Person(name: \"Jane\")try! realm.write &#123; realm.add(person)&#125;let personRef = ThreadSafeReference(to: person)DispatchQueue(label: \"background\").async &#123; autoreleasepool &#123; let realm = try! Realm() guard let person = realm.resolve(personRef) else &#123; return // person 已被删除 &#125; try! realm.write &#123; person.name = \"Jane Doe\" &#125; &#125;&#125; ThreadSafeReference对象最多只能够解析一次;ThreadSafeReference 解析失败的话，将会导致 Realm 的原始版本被锁死，直到引用被释放为止。因此，ThreadSafeReference 的生命周期应该很短(加上autoreleasepool)。 这些类型的某些属性和方法可以在任意线程中进行访问 Realm: 所有的属性、类方法和构造器；all properties, class methods, and initializers Object: isInvalidated、objectSchema、realm，以及所有的类方法和构造器；Results: objectClassName 和 realm List: isInvalidated、objectClassName 和 realm。 跨线程使用数据库在不同的线程中使用同一个 Realm 文件, 需要在每一个线程初始化一个新的Realm 实例, 只要指定的配置是相同的，那么所有的 Realm 实例都将会指向硬盘上的同一个文件。 暂时不支持共享Realm实例 当写入大量数据的时候，在一个单独事务中通过批量执行多次数据修改操作是非常高效的。事务也可以使用 Grand Central Dispatch(GCD) 在后台运行，以防止阻塞主线程。 Realm 对象并不是线程安全的，并且它也不能够跨线程共享，因此要为每一个要执行读取或者写入操作的线程或者 dispatch 队列创建一个 Realm 实例。 这里有一个在后台队列中插入百万数据的例子： 12345678910111213141516171819202122DispatchQueue(label: \"background\").async &#123; autoreleasepool &#123; // 在这个线程中获取 Realm 和表实例 let realm = try! Realm() // 通过开启写入操作将写入闭包分成多个微小部分 for idx1 in 0..&lt;1000 &#123; realm.beginWrite() // 通过字典插入行，忽略属性次序 for idx2 in 0..&lt;1000 &#123; realm.create(Person.self, value: [ \"name\": \"\\(idx1)\", \"birthdate\": Date(timeIntervalSince1970: TimeInterval(idx2)) ]) &#125; // 提交写入事务以确保数据在其他线程可用 try! realm.commitWrite() &#125; &#125;&#125; JsonRealm 没有提供对 JSON 的直接支持，但可以使用 NSJSONSerialization.JSONObjectWithData(_:options:) 的输出完成从 JSON 中添加 Object 的操作。 由此所产生的 KVC 兼容的对象可以使用创建和更新对象的 标准 API 来添加/更新 Object。 123456789101112131415// 表示城市的一个 Realm 对象class City: Object &#123; dynamic var city = \"\" dynamic var id = 0 // 其它空余的属性…&#125;let data = \"&#123;\\\"name\\\": \\\"San Francisco\\\", \\\"cityId\\\": 123&#125;\".data(using: .utf8)!let realm = try! Realm()// 从包含 JSON 的 NSData 中插入数据try! realm.write &#123; let json = try! JSONSerialization.jsonObject(with: data, options: []) realm.create(City.self, value: json, update: true)&#125; 如果在 JSON 中包含了嵌套的对象或者数组的话，这些数据都将被自动映射到对一以及对多关系——参见嵌套对象 一节获取详情。 当使用这种方法在 Realm 中插入或者更新 JSON 数据的时候，要注意 Realm 需要确保 JSON 的属性名和类型能够与 Object 属性完全匹配。例如： float 属性应当使用 float 进行初始化——您也可以选择 NSNumbers。 NSDate 和 NSData 属性无法从字符串进行自动推断，而应该在传递给 Realm().create(_:value:update:) 之前转换为适当的类型。 如果 JSON 中的属性是 null (例如：NSNull) 提供给了一个必需属性的话，那么会抛出异常。如果某个必需属性在插入操作中没有提供的话，那么会抛出异常。 Realm 将会忽略 JSON 中没有以 Object 定义的任何属性。 如果 JSON 模式和 Realm 对象无法完全一致的话，推荐使用第三方的模型映射框架。 通知 Realm通知 通知闭包-可以在整个 Realm 数据库上进行注册。当相关 Realm 的写操作事务被提交之后，无论这个事务发生在何种线程或者何种进程之中，这个通知处理闭包都将会被触发： 12345678910111213141516let realm = try? Realm()print(realm?.configuration.fileURL as Any)let token = realm?.addNotificationBlock(&#123; (note, realm) in print(note, realm)&#125;) try? realm?.write &#123; realm?.create(Dog.self, value: [\"id\":1, \"name\": \"xssx\"], update: true) // 执行通知闭包&#125; token?.stop() // 关闭通知 try? realm?.write &#123; realm?.create(Dog.self, value: [\"name\": \"stopxssx\"], update: true)// 不执行通知闭包&#125; 集合通知集合通知是异步触发的，首先它会在初始化的时候触发，随后当某个写入事务改变了集合中的所有或者某个对象的时候，通知都会再次触发。所有的CRUD都会传递到通知闭包当中的 RealmCollectionChange(枚举) 参数访问到。这个对象当中包含了受 deletions、insertions 和 modifications 状态所影响的索引信息, 其定义如下: 12345public enum RealmCollectionChange&lt;T&gt; &#123; case initial(T) // 初始化会执行 case update(T, deletions: [Int], insertions: [Int], modifications: [Int]) case error(Error)&#125; 如果处理集合中的对象的属性发生更改, 都可以监听的到修改 (modifications) 的通知, 当对一关系和对多关系 发生变化时也会触发这个状态变化，但是对于 反向关系 来说则不会触发这个变化。 以tableView为例子,监听数据源的改变, 做出相应更改, 当然可以重写数据源的set方法, 但如果数据源里的某一个数据里的属性发生了更改, 是无法监听的到, 当然可以结合KVO,但这样一来就相对复杂了; so集合通知还是挺实用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Dog: Object &#123; dynamic var name = \"\" dynamic var age = 0&#125;class Person: Object &#123; dynamic var name = \"\" let dogs = List&lt;Dog&gt;()&#125;class ViewController: UITableViewController &#123; var notificationToken: NotificationToken? = nil override func viewDidLoad() &#123; super.viewDidLoad() let realm = try! Realm() // 对results的监听 let results = realm.objects(Person).filter(\"age &gt; 5\") // 观察 Results 通知 notificationToken = results.addNotificationBlock &#123; [weak self] (changes: RealmCollectionChange) in guard let tableView = self?.tableView else &#123; return &#125; switch changes &#123; case .initial: // Results 现在已经填充完毕，可以不需要阻塞 UI 就可以被访问 tableView.reloadData() break case .update(_, let deletions, let insertions, let modifications): // Query results have changed, so apply them to the UITableView tableView.beginUpdates() tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;), with: .automatic) tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.endUpdates() break case .error(let error): // 如果在后台工作线程中打开 Realm 文件，则会发生错误 fatalError(\"\\(error)\") break &#125; &#125; &#125; deinit &#123; notificationToken?.stop() &#125;&#125; 对象通知 Realm 支持对象级别的通知。在特定的 Realm 对象上进行通知的注册，这样就可以在此对象被删除时、或者该对象所管理的属性值被修改时获取相应的通知。 只有由 Realm 数据库所管理的对象才能够进行通知注册。 这个通知处理闭包将包含有 ObjectChange 枚举值，表示是否有对象被删除、是否有对象的属性值发生了改变，以及是否有错误发生。 对象被删除的话，那么这个通知闭包将会带着 ObjectChange.deleted 的参数被调用。这个闭包将不会被再次调用。 对象的属性发生了变更的话，那么这个闭包将会带着 ObjectChange.change 的参数被调用。这个枚举将会包含有 PropertyChange 类型的数组。每个数组值都包含有被修改的属性名(以字符串的形式提供)、修改前的属性值以及当前的属性值。 有错误发生，那么这个闭包将会带有 ObjectChange.error 的参数被调用。这个闭包将不会被再次调用。 12345public enum ObjectChange &#123; case error(_: NSError) case change(_: [PropertyChange]) case deleted&#125; 1234567891011121314151617181920212223class StepCounter: Object &#123; dynamic var steps = 0&#125;let stepCounter = StepCounter()let realm = try! Realm()try! realm.write &#123; realm.add(stepCounter)&#125;var token : NotificationToken?token = stepCounter.addNotificationBlock &#123; change in switch change &#123; // 监听对象 case .change(let properties): for property in properties &#123; if property.name == \"steps\" &amp;&amp; property.newValue as! Int &gt; 1000 &#123; token = nil &#125; &#125; case .error(let error): case .deleted: &#125;&#125; 界面驱动更新Realm 的通知总是以异步的方式进行传递，因此这些操作永远不会阻塞主 UI 线程，也不会导致应用卡顿。如果需要在主线程同步传递, 并立即更新在UI上, 就可以使用界面驱动更新 (Interface-Driven writes)。 案例: 假设用户需要向表视图当中插入一个项目。理想状况下，UI 将会将这个操作用动画表现出来，然后当用户完成动作的时候立即启动相应的操作。 然而，此插入操作的 Realm 变更通知将会延时一段时间才进行传递，它会先将一个对象添加到表视图背后所关联的集合当中，随后再尝试去在 UI 当中插入一个新的项目。这种双重插入将会导致 UI 与后台数据之间的数据不一致，而这往往会导致应用崩溃！💥NSInternalInconsistencyException💥 借助 Realm.commitWrite(withoutNotifying:)，这样在执行界面驱动更新的时候，通过传递通知闭包的通知令牌的方式，这样就不会对变更操作执行二次响应。 1234567891011121314151617181920212223242526272829token = collection.addNotificationBlock &#123; changes in switch changes &#123; case .initial: tableView.reloadData() break case .update(_, let deletions, let insertions, let modifications): tableView.beginUpdates() tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;), with: .automatic) tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.endUpdates() break case .error(let error): break &#125;&#125;func insertItem() throws &#123; // 在主线程中执行 collection.realm!.beginWrite() collection.insert(Item(), at: 0) tableView.insertRows(at: [IndexPath(row: 0, section: 0)], with: .automatic) // 确保不会重复执行 collection.realm!.commitWrite(withoutNotifying: [token])&#125; 数据库迁移如果修改了数据模型, 例如新增属性, 就需要进行数据的迁移 简单说明 123456789101112131415161718192021222324252627282930313233/* Realm.Configuration(fileURL: &lt;#T##URL?#&gt;, inMemoryIdentifier: &lt;#T##String?#&gt;, syncConfiguration: &lt;#T##SyncConfiguration?#&gt;, encryptionKey: &lt;#T##Data?#&gt;, readOnly: &lt;#T##Bool#&gt;, schemaVersion: &lt;#T##UInt64#&gt;, migrationBlock: &lt;#T##MigrationBlock?##MigrationBlock?##(Migration, UInt64) -&gt; Void#&gt;, deleteRealmIfMigrationNeeded: &lt;#T##Bool#&gt;, shouldCompactOnLaunch: &lt;#T##((Int, Int) -&gt; Bool)?##((Int, Int) -&gt; Bool)?##(Int, Int) -&gt; Bool#&gt;, objectTypes: &lt;#T##[Object.Type]?#&gt;)*/func configRealmWithUser(_ username:String) &#123; var config = Realm.Configuration() config.fileURL = config.fileURL?.deletingLastPathComponent() .appendingPathComponent(\"\\(username).realm\")// config.syncConfiguration = // config.migrationBlock = // config.schemaVersion = // ... Realm.Configuration.defaultConfiguration = config&#125;或:参数的个数任意组合的block形式let config = Realm.Configuration( schemaVersion: 1, migrationBlock: &#123; (migration, oldSchemaVersion) in if (oldSchemaVersion &lt; 1) &#123; // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构 &#125;&#125;)Realm.Configuration.defaultConfiguration = config 值的更新 在迁移闭包中，我们能够调用Migration().enumerateObjects(ofType: ::) 来枚举特定类型的每个 Object 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 Object 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问： 123456789101112131415// 在 application(application:didFinishLaunchingWithOptions:) 中进行配置Realm.Configuration.defaultConfiguration = Realm.Configuration( schemaVersion: 1, migrationBlock: &#123; migration, oldSchemaVersion in if (oldSchemaVersion &lt; 1) &#123; // enumerateObjects(ofType:_:) 方法遍历了存储在 Realm 文件中的每一个“Person”对象 migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in // 将名字进行合并，存放在 fullName 域中 let firstName = oldObject![\"firstName\"] as! String let lastName = oldObject![\"lastName\"] as! String newObject![\"fullName\"] = \"\\(firstName) \\(lastName)\" &#125; &#125; &#125;) 属性的重命名 在迁移过程中对类中某个属性进行重命名操作，比起拷贝值和保留关系来说要更为高效。 要在迁移过程中对某个属性就进行重命名的话，请确保您的新模型当中的这个属性是一个全新的名字，它的名字不能和原有模型当中的名字重合。 如果新的属性拥有不同的可空性或者索引设置的话，这些配置会在重命名操作期间生效。 1234567891011// 在 application(application:didFinishLaunchingWithOptions:) 当中使用Realm.Configuration.defaultConfiguration = Realm.Configuration( schemaVersion: 1, migrationBlock: &#123; migration, oldSchemaVersion in // 我们目前还没有迁移任何东西，因此 oldSchemaVersion == 0 if (oldSchemaVersion &lt; 1) &#123; // 重命名操作应该在调用 `enumerateObjects(ofType: _:)` 之外完成 migration.renameProperty(onType: Person.className(), from: \"yearsSinceBirth\", to: \"age\") &#125; &#125;) 多个版本的控制 123456789101112131415161718192021Realm.Configuration.defaultConfiguration = Realm.Configuration( schemaVersion: 2, migrationBlock: &#123; migration, oldSchemaVersion in // enumerateObjects:block: 遍历了存储在 Realm 文件中的每一个“Person”对象 migration.enumerateObjects(ofType: Person.className()) &#123; oldObject, newObject in // 只有当 Realm 数据库的架构版本为 0 的时候，才添加 “fullName” 属性 if oldSchemaVersion &lt; 1 &#123; let firstName = oldObject![\"firstName\"] as! String let lastName = oldObject![\"lastName\"] as! String newObject![\"fullName\"] = \"\\(firstName) \\(lastName)\" &#125; // 只有当 Realm 数据库的架构版本为 0 或者 1 的时候，才添加“email”属性 if oldSchemaVersion &lt; 2 &#123; newObject![\"email\"] = \"\" &#125; &#125; &#125;)// Realm 数据库会自动执行此数据迁移，然后成功进行访问let realm = try! Realm() 数据库加密 Realm 支持在创建 Realm 数据库时采用64位的密钥对数据库文件进行 AES-256+SHA2 加密。 12345678910111213141516// 产生随机密钥var key = Data(count: 64)_ = key.withUnsafeMutableBytes &#123; bytes in SecRandomCopyBytes(kSecRandomDefault, 64, bytes)&#125;// 打开加密文件let config = Realm.Configuration(encryptionKey: key)do &#123; let realm = try Realm(configuration: config) // 和往常一样使用 Realm 即可 let dogs = realm.objects(Dog).filter(\"name contains 'Fido'\")&#125; catch let error as NSError &#123; // 如果密钥错误，`error` 会提示数据库不可访问 fatalError(\"Error opening realm: \\(error)\")&#125; 这样硬盘上的数据都能都采用AES-256来进行加密和解密，并用 SHA-2 HMAC 来进行验证。 每次您要获取一个 Realm 实例时，您都需要提供一次相同的密钥。 密钥并将其安全地存放到钥匙串当中，然后用其加密 Realm。 1234567891011121314151617181920212223242526272829303132333435363738import Securityfunc getKey() -&gt; NSData &#123; // 标识符 let keychainIdentifier = \"io.Realm.EncryptionExampleKey\" let keychainIdentifierData = keychainIdentifier.data(using: String.Encoding.utf8, allowLossyConversion: false)! // 检测是否存在钥匙串 var query: [NSString: AnyObject] = [ kSecClass: kSecClassKey, kSecAttrApplicationTag: keychainIdentifierData as AnyObject, kSecAttrKeySizeInBits: 512 as AnyObject, kSecReturnData: true as AnyObject ] var dataTypeRef: AnyObject? var status = withUnsafeMutablePointer(to: &amp;dataTypeRef) &#123; SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0)) &#125; if status == errSecSuccess &#123; // 找到就返回 return dataTypeRef as! NSData &#125; // 没有找到就新建一个 let keyData = NSMutableData(length: 64)! let result = SecRandomCopyBytes(kSecRandomDefault, 64, keyData.mutableBytes.bindMemory(to: UInt8.self, capacity: 64)) assert(result == 0, \"Failed to get random bytes\") // 存储钥匙串 query = [ kSecClass: kSecClassKey, kSecAttrApplicationTag: keychainIdentifierData as AnyObject, kSecAttrKeySizeInBits: 512 as AnyObject, kSecValueData: keyData ] status = SecItemAdd(query as CFDictionary, nil) assert(status == errSecSuccess, \"Failed to insert the new key in the keychain\") return keyData &#125; 使用 12345678910111213141516171819202122// 添加autoreleasepool &#123; let configuration = Realm.Configuration(encryptionKey: getKey() as Data) let realm = try! Realm(configuration: configuration) // Add an object try! realm.write &#123; let dog = Dog() dog.name = \"xxxx\" realm.add(dog) &#125;&#125;// 查询autoreleasepool &#123; let configuration = Realm.Configuration(encryptionKey: getKey() as Data) let realm = try! Realm(configuration: configuration) if let dogName = realm.objects(Dog.self).first?.name &#123; print(dogName) &#125; &#125; 加密过的 Realm 只会带来很少的额外资源占用（通常最多只会比平常慢10%）。 Realm 的加密 API 目前支持 iOS、OS X 以及 WatchKit 平台，但 不支持 watchOS 平台，因为 Realm 加密机制使用的 以及 API 被标记为__WATCHOS_PROHIBITED` 了。 版本限制 Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如： （1）类名称的长度最大只能存储 57 个 UTF8 字符。 （2）属性名称的长度最大只能支持 63 个 UTF8 字符。 （3）NSData 以及 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。 （4）对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://github.com/icoderRo/tags/数据库/"}]},{"title":"Xcode8新特性","slug":"Xcode8新特性","date":"2016-10-03T03:26:31.000Z","updated":"2017-08-17T15:01:37.000Z","comments":true,"path":"2016/10/03/Xcode8新特性/","link":"","permalink":"https://github.com/icoderRo/2016/10/03/Xcode8新特性/","excerpt":"简介9月14日开发者们已经可以下载并使用正式版Xcode8, 借着国庆休息期间,本人也下载并使用了Xcode8, 发现里面的坑点不少.下面就总结在使用过程中遇见的一些问题. 新特性GeneralXcode8中通过Automatically manage signing, 让苹果为我们管理整数和配置文件.想要设置安装后显示在手机上的APP的名字, 可以直接修改Display Name, 这个修改和Info.plist修改是同步的. 手动管理证书和描述文件, 去掉Automatically manage signing的勾即可. ATS问题在iOS9中,我们可以通过设置NSAllowsArbitraryLoads为YES, 来使用HTTP网络; iOS10从2017年1月1日开始, 苹果不允许我们通过这个方法跳过ATS, 强制使用HTTPS.我们可以用过NSExceptionDomains对特定的域名开放HTTP.","text":"简介9月14日开发者们已经可以下载并使用正式版Xcode8, 借着国庆休息期间,本人也下载并使用了Xcode8, 发现里面的坑点不少.下面就总结在使用过程中遇见的一些问题. 新特性GeneralXcode8中通过Automatically manage signing, 让苹果为我们管理整数和配置文件.想要设置安装后显示在手机上的APP的名字, 可以直接修改Display Name, 这个修改和Info.plist修改是同步的. 手动管理证书和描述文件, 去掉Automatically manage signing的勾即可. ATS问题在iOS9中,我们可以通过设置NSAllowsArbitraryLoads为YES, 来使用HTTP网络; iOS10从2017年1月1日开始, 苹果不允许我们通过这个方法跳过ATS, 强制使用HTTPS.我们可以用过NSExceptionDomains对特定的域名开放HTTP. 隐私权限的设置iOS10 对隐私权限更加严格, 如果不设置, 会直接崩溃.根据错误提示: 我们可以在info.plist文件中 添加对应的键值就可以了. 麦克风权限：Privacy - Microphone Usage Description 是否允许此App使用你的麦克风？ 相机权限： Privacy - Camera Usage Description 是否允许此App使用你的相机？ 相册权限： Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库？ 通讯录权限： Privacy - Contacts Usage Description 是否允许此App访问你的通讯录？ 蓝牙权限：Privacy - Bluetooth Peripheral Usage Description 是否许允此App使用蓝牙？ 语音转文字权限：Privacy - Speech Recognition Usage Description 是否允许此App使用语音识别？ 日历权限：Privacy - Calendars Usage Description 是否允许此App使用日历？ 定位权限：Privacy - Location When In Use Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 定位权限: Privacy - Location Always Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据 Interface BuilderXcode8之前的 Size ClassXcode8之后的就不叫Size Class, 就是一个预览当前当前XIB或SB在不同屏幕尺寸下的图形界面. Xcode8打开之前的旧项目的XIB或SB文件时, 会弹出一个选择初始化设置视图的窗口, 一般选择Choose Device. 如果Xcode8打开过当前的XIB文件, 并选择Choose Device后, 低于Xcode8版本的编译器将无法打开这个XIB文件, 并会报一下错误: The document “ViewController.xib” requires Xcode 8.0 or later. This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later. 有两种方法解决:1.删除XIB或SB文件中的 xml中的代码. 打开方式右键 -&gt; Open as -&gt; Source Code &lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt; 2.大家一起升级到Xcode8. 禁用系统logXcode 8在调试和运行过程中, 会打印很多不认识的log.这些是系统打印的.解决办法是:在Target -&gt; Edit Scheme -&gt; Run -&gt; Arguments中，添加OS_ACTIVITY_MODE字段，并设置为Disable即可。 插件问题苹果为了避免类似 Xcode Ghost: 事件的再次发生,Xcode8 禁用了插件机制,而开放了另一种形式： Source Editor extensions 但是这种形式局限性太大.这里有一边文章介绍, 让你的Xcode8继续使用插件:Xcode8继续使用插件 如果出现command＋／注释代码失效, 可以执行sudo /usr/libexec/xpccachectl后重启电脑. VVDocumenter-Xcode已经在Xcode8中集成了注释插件, 使用方法不是以前的///, 而是option＋command＋／. APIUIColor新增方法123+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0); 据苹果官方建议使用sRGB, 理由是性能好, 色彩更丰富. 字体123456789NS_CLASS_AVAILABLE_IOS(10_0) @protocol UIContentSizeCategoryAdjusting &lt;NSObject&gt;/* Indicates whether the corresponding element should automatically update its font when the device’s UIContentSizeCategory is changed. For this property to take effect, the element’s font must be a font vended using +preferredFontForTextStyle: or +preferredFontForTextStyle:compatibleWithTraitCollection: with a valid UIFontTextStyle. */@property (nonatomic) BOOL adjustsFontForContentSizeCategory;@end adjustsFontForContentSizeCategory 字体是否随着手机系统字体的变化而变化. refreshControliOS10以前:1NS_CLASS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED @interface UIRefreshControl : UIControl iOS10以后: 1@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(10_0) __TVOS_PROHIBITED; iOS10 以后只要是集成与UIScrollView, 即可获得此属性. systemVersion判断系统版本号建议用法:Objc [[UIDevice currentDevice] systemVersion] UICollectionViewiOS10 对UICollectionView进一步的优化, 详情可参考UICollectionView新特性 NotificationiOS10所有的通知都属于UserNotifications.framework增加了撤回单条通知,更新已展示通知,中途修改通知内容,在通知中展示图片视频,自定义通知 UI 等一系列新功能,非常强大.详情可以参考:活久见的重构 - iOS 10 UserNotifications 框架解析UserNotifications","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"新特性","slug":"新特性","permalink":"https://github.com/icoderRo/tags/新特性/"}]},{"title":"编译ijkplayerDemo","slug":"编译ijkplayerDemo","date":"2016-08-26T16:00:00.000Z","updated":"2017-08-27T10:22:37.000Z","comments":true,"path":"2016/08/27/编译ijkplayerDemo/","link":"","permalink":"https://github.com/icoderRo/2016/08/27/编译ijkplayerDemo/","excerpt":"编译ijkplayerDemo下载 编译 ijkplayer下载回来后会发现 ffmpeg - lib 里面的.a文件缺失 显示为红色","text":"编译ijkplayerDemo下载 编译 ijkplayer下载回来后会发现 ffmpeg - lib 里面的.a文件缺失 显示为红色 接着编译 ffmpeg打开终端, cd 到ijkplayer文件夹中 cd ijkplayer 如下图: 下载ffmpeg ./init-ios.sh cd到iOS目录 编译 ffmpeg./compile-ffmpeg.sh clean./compile-ffmpeg.sh all等待编译完成即可 运行IJKMediaDemo 制作framework打开IJKMediaPlayer目录 运行IJKMediaPlayer.xcodeproj 选择release模式,编译真机和模拟器的IJKMediaPlayer.xcodeproj, 打开相应目录 会得到两个文件夹 一个是真机的 Release-iphoneos 一个是模拟器的Release-iphonesimulator 将真机framework和模拟器的framework合并成一个打开终端输入 lipo -create “真机IJKMediaFramework路径” “模拟器IJKMediaFramework路径” -output “合并后的文件路径和名称(LastPathComponent会默认为文件名字)” 打开相应路劲 得到合并后的framework 将生成的合并后的framework 替换掉 Release-iphoneos 和Release-iphonesimulator 里面的framework","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"framework","slug":"framework","permalink":"https://github.com/icoderRo/tags/framework/"}]},{"title":"记IM聊天界面卡顿分析","slug":"记IM聊天界面卡顿分析","date":"2016-08-06T12:26:31.000Z","updated":"2017-08-17T15:02:28.000Z","comments":true,"path":"2016/08/06/记IM聊天界面卡顿分析/","link":"","permalink":"https://github.com/icoderRo/2016/08/06/记IM聊天界面卡顿分析/","excerpt":"开始测试快速滚动视图 开启GPU Driver检测 图中可以看出当前的帧率非常的低, 保持在 40~50 FPS, 明显可以感觉到卡顿.","text":"开始测试快速滚动视图 开启GPU Driver检测 图中可以看出当前的帧率非常的低, 保持在 40~50 FPS, 明显可以感觉到卡顿. 卡顿产生的原因 图像显示原理:简单来说, CPU计算好显示的内容提交到GPU, GPU渲染完成后将渲染的结果放入帧缓冲区, 视频控制器会逐行读取帧缓冲区的数据, 进过一些转换(数模转换)传递给显示器显示. iOS设备目前使用的是双缓存+垂直同步, 安卓系统是三缓存+垂直同步, 感兴趣的看官, 可自行搜索. 结论:从流程图可以看出, CPU和GPU不论哪个阻碍了图像显示流程, 均会造成掉帧, 产生屏幕卡顿的现象. CPU: 一般处理视图的创建、布局计算、图片解码、文本的绘制、图像绘制等等. GPU: 对CPU提交的内容(纹理、顶点)进行应用变换、混合、渲染. 例如:纹理的渲染、视图的混合、图形的生成. 下面对GPU和CPU分别进行检测. 检测GPU Renderer Utilization 如果Renderer Utilization的百分比超过了50%, 有可能是因为离屏渲染或者是重绘导致 Tiler Utilization 如果Tiler Utilization的百分比超过了50%, 很有可能是屏幕上有太多的图层覆盖 可以判断, GPU并不是影响性能的罪魁恶首 检测CPU 勾上Separate by Thread 和 Hide System Libraties : 分离线程, 方便查看各条线程和隐藏系统库. 明显看见CPU占用率特别高,首当其冲的是分别是占- cellForRowAtIndexPath和- heightForRowAtIndexPath的两句代码. 1.检测cellForRowAtIndexPath代码 点开小箭头, 发现里面emotionStringWithWH:消耗了大量CPU的性能.双击进去查看代码, 可以看到消耗性能的代码是在cell模型赋值的方法._msgLabel.attributedText =[session.fullText emotionStringWithWH:23]; 猜想:tableView每次滚动, cell的set方法都会调用emotionStringWithWH:,为了避免每次给富文本赋值都调用此方法, 新增一个属性NSAttributedString *text. 当前代码修改成:_msgLabel.attributedText = session.text; 因此, 我们需要给text在合适的地方赋值, 本demo在点击发送文本的方法中添加session.text = [session.fullText emotionStringWithWH:23]; 重新运行项目, 再次检测 可以看出帧率提升了一小部分 保持在45~55 FPS, 快速滑动CPU的使用率在40%左右. 2.检测heightForRowAtIndexPath代码从图中红色箭头所示, 可以看出, 计算高度的方法:cellHeight占用了比较多的开销.查看当前的代码发现,每次滑动都会重复计算高度:self.baseChatCellTool.session = self.dataSource[indexPath.row];return self.baseChatCellTool.cellHeight; 因此, 第一感觉就是应该将计算过的高度给缓存起来,于是乎将代码修改为: LCSession *session = self.dataSource[indexPath.row]; if (!session.cellHeight) { self.baseChatCellTool.session = session; session.cellHeight = self.baseChatCellTool.cellHeight; dispatch_async(dispatch_get_global_queue(0, 0), ^{ [LCCachesTool addSession:session]; }); } return session.cellHeight; 重新运行项目, 再次检测我们发现cellForRowAtIndexPath依旧占用了比较多的开销,点击查看, 如绿色框所示, 发现, 里面全部都为%0的开销 我们将Hide System Libraties选项取消勾选, 找到与上图中同样的方法setSession, 发现是UILabel设置富文本的时候, 占用了大量的开销, 这个话题, 我们暂且打住.继续看回上图, 我么发现还有一个方法占用了比较大的开销:layoutSubviews, 当我们滚动视图的时候, 就会调用layoutSubviews, 我们查看一下, 在此方法中, 做了什么事情: 123456789101112131415161718192021222324252627[self.headerImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.right.equalTo(self.contentView).offset(-7); make.top.equalTo(self.contentView).offset(7); make.width.height.equalTo(@(46)); &#125;]; [self.nicknameLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.headerImageView).offset(-2); make.right.equalTo(self.headerImageView.mas_left).offset(-15); &#125;]; [self.msgLabel mas_remakeConstraints:^(MASConstraintMaker *make) &#123; if (self.session.messageType == messageTypeImage || self.session.messageType == messageTypeMap) &#123; make.right.equalTo(self.headerImageView.mas_left).offset(-4); &#125; else &#123; make.right.equalTo(self.headerImageView.mas_left).offset(-20); &#125; make.top.equalTo(self.nicknameLabel.mas_bottom).offset(13); &#125;]; [self.backgroundMsgView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.msgLabel).insets(UIEdgeInsetsMake(-8, -10, -10, -15)); &#125;]; ..... 里面都是些布局的代码. 我们知道, 自动布局的消耗是昂贵的, 特别是每次滚动都需要布局. 由此产生第一个优化方案: 现有的自动布局替换为坐标系(frame), 我们也都知道, 利用frame计算是一件非常痛苦的事情. 当然, 最终的方案,利用coreText排版, 肯定是利用frame, 但是是已经提前计算好的frame. 当前基于系统的UILabel, 和为了方便书写布局代码, 我们从这个方向来优化, 首先自动布局是需要的, 其次避免调用layoutSubViews(因为每次滚动视图都会调用), 在init方法中, 布局一次: [self layout]; 重新运行项目, 再次检测:CPU最高使用率为34%,平均在23%左右 帧率提保持在50~55 FPS我们发现cellForRowAtIndexPath依旧占用了比较多的开销,点击查看, 发现, 里面全部都为%0的开销, 由此可见,这些开销基本都属于系统级的开销了. 常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件 那么发现基本也就只有一条路可以走了, 那就是基于coreText对文本进行异步的绘制.基于coreText对文本进行异步的绘制我们后续再说. coreText优点: 占用内存少,可以预先排版对象, 保留对象供绘制使用, 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算. 继续搜罗imageNamed:我们将代码还原,发现多次调用[UIImage imageNamed:]对于内存的开销相对较大, 在创建Image或者CGImageSource对象时,图片数据并不会立即解码,而是等到设置到ImageView或者layer.contents，layer被提交到GPU之前,才解码,并且这些操作都是在主线程进行,是相当耗性能的.因此应该开启子线程把图片绘制到CGBitmapContext,然后从Bitmap直接创建图片, 常见的网络图片库都自带这些功能. 123456789// 简略思路dispatch\\_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;);&#125;); 1234567891011121314151617181920212223例如AFN中对于图片的处理: // 部分代码 CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo); CGColorSpaceRelease(colorSpace); if (!context) &#123; CGImageRelease(imageRef); return image; &#125; CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef); CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context); CGContextRelease(context); UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation]; CGImageRelease(inflatedImageRef); CGImageRelease(imageRef); return inflatedImage; 12345678910111213141516171819202122232425262728293031323334353637例如SD中对于图片的处理: // Workaround for iOS anamorphic image if (partialImageRef) &#123; const size_t partialHeight = CGImageGetHeight(partialImageRef); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst); CGColorSpaceRelease(colorSpace); if (bmContext) &#123; CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef); CGImageRelease(partialImageRef); partialImageRef = CGBitmapContextCreateImage(bmContext); CGContextRelease(bmContext); &#125; else &#123; CGImageRelease(partialImageRef); partialImageRef = nil; &#125; &#125; if (partialImageRef) &#123; UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation]; // 存储key NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL]; UIImage *scaledImage = [self scaledImageForKey:key image:image]; if (self.shouldDecompressImages) &#123; image = [UIImage decodedImageWithImage:scaledImage]; &#125; else &#123; image = scaledImage; &#125; CGImageRelease(partialImageRef); dispatch_main_sync_safe(^&#123; // 回到主线程 if (self.completedBlock) &#123; self.completedBlock(image, nil, nil, NO); &#125; &#125;); &#125; 渲染时机Core Animation 在 RunLoop 中注册了一个 Observer,监听了 BeforeWaiting 和 Exit 事件.当一个触摸事件到来时,RunLoop 被唤醒,App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画;这些操作最终都会被 CALayer 标记,并通过 CATransaction 提交到一个中间状态去.当上面所有操作结束后,RunLoop 即将进入休眠（或者退出）时,关注该事件的 Observer 都会得到通知. 这个回调函数的调用栈大概是这样: 文本计算UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高,用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本.优化点:放到子线程进行以避免阻塞主线程. 总结从上面可知,几个CPU资源消耗的原因: 布局计算 视图的布局计算是常见消耗CPU的资源. 一般在子线程中提前计算好视图的布局、对布局进行缓存, 基本上就没有啥问题了. Autolayout 由于手动计算frame等属性,比较复杂、开发效率相对较低,自动布局很极大的提升开发效率, 复杂的视图使用自动布局会产生严重的性能问题,随着视图的数量增长, CPU的消耗会呈指数级的提升.其最终都会落到对视图的frame/bounds/center 等属性的调整. 文本渲染 常见的系统文本控件(UILabel, UITextView…), 其排版和绘制都是在主线程执行, 当有大量的文本/富文本/图文混排等, 对于CPU的消耗是非常昂贵的, 同时伴有严重的界面卡顿现象.当下的解决方案是基于CoreText对文本进行异步的绘制. 图像解码 图片设置到UIImageView/layer.contents，layer被提交到GPU之前,才解码,并且这些操作都是在主线程进行,是相当耗性能的.因此应该开启子线程把图片绘制到CGBitmapContext,然后从Bitmap直接创建图片.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://github.com/icoderRo/tags/性能优化/"}]},{"title":"基于netty LengthFieldBasedFrameDecoder编解码","slug":"netty-socket编解码","date":"2016-06-11T16:00:00.000Z","updated":"2017-08-17T14:51:22.000Z","comments":true,"path":"2016/06/12/netty-socket编解码/","link":"","permalink":"https://github.com/icoderRo/2016/06/12/netty-socket编解码/","excerpt":"前言1234服务器传输协议协议: 基于netty LengthFieldBasedFrameDecoder(100000000,0,4,0,4) 总长度 = 4byte + 包体内容接收二进制的json字符串 正文思路:1231.在发送数据包前, 拼接4个字节带有包体内容长度的数据.2.在接受数时, 需要考虑 粘包和半包的情况.根据包头长度,判断包 的完整性.将完整的包解析出去,不完整的等待下一次的数据拼接. 设计1231.采用面向协议的方式编码与解码2.自定义编码器和解码器, 遵守协议, 实现协议中的方法3.基于GCDAsyncSocket, 封装需要用到的方法","text":"前言1234服务器传输协议协议: 基于netty LengthFieldBasedFrameDecoder(100000000,0,4,0,4) 总长度 = 4byte + 包体内容接收二进制的json字符串 正文思路:1231.在发送数据包前, 拼接4个字节带有包体内容长度的数据.2.在接受数时, 需要考虑 粘包和半包的情况.根据包头长度,判断包 的完整性.将完整的包解析出去,不完整的等待下一次的数据拼接. 设计1231.采用面向协议的方式编码与解码2.自定义编码器和解码器, 遵守协议, 实现协议中的方法3.基于GCDAsyncSocket, 封装需要用到的方法 文件结构 分块讲解协议 - LCSocketCoderProtocol12341.编码协议:LCSocketEncoderProtocol2.解码协议:LCSocketDecoderProtocol3.编码完成后的输出协议:LCSocketEncoderOutputProtocol4.解码完成后的输出协议:LCSocketDecoderOutputProtocol 编码器 - LCSocketEncoder12341. 遵守编码协议2.实现协议中的方法:- (void)encode:(id)object output (id&lt;LCSocketEncoderOutputProtocol&gt;)output其中, 输出output遵守 编码输出协议 编码器 - LCSocketDecoder12341. 遵守解码协议2.实现协议中的方法:- (void)decode:(id)object output:(id&lt;LCSocketDecoderOutputProtocol&gt;)output其中, 输出output遵守 解码输出协议 套接字 - LCBaseSocket1231. 基于GCDAsyncSocket2.单例化, 提供需要给外界访问的接口,如:\"重连\", \"断开连接\". \"是否正在连接\"等3.设置代理属性 编码器代码详解 - LCSocketEncoder123456789101112131415161718192021222324252627281.判断数据格式是否可解析为json if (![NSJSONSerialization isValidJSONObject:object]) &#123; [output didEndEncode:nil error:[NSError errorWithDomain:@\"数据不能解析为json\" code:-1 userInfo:nil]]; return; &#125;2.将json数据编码为NSData NSError *error = nil; NSData *contentData = [NSJSONSerialization dataWithJSONObject:object options:NSJSONWritingPrettyPrinted error:&amp;error]; NSString *contentStr = [[NSString alloc] initWithData:contentData encoding:NSUTF8StringEncoding]; contentData = [contentStr dataUsingEncoding:NSUTF8StringEncoding];3.判断编码后的数据长度 if (contentData.length &gt; 1000000 - countOfLengthByte) &#123; [output didEndEncode:nil error:[NSError errorWithDomain:@\"encoder的数据太长\" code:-1 userInfo:nil]]; return; &#125;4.将数据长度, 拼接到包头 NSUInteger contentDataLength = contentData.length; NSData *headData = [self dataForLength:contentDataLength byteCount:countOfLengthByte reverse:NO]; NSMutableData *data = [NSMutableData data]; [data appendData:headData]; [data appendData:contentData];5.分发数据 [output didEndEncode:data error:nil]; 解码器代码详解 - LCSocketDecoder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521.判断数据是否为NSData类型if (![object isKindOfClass:[NSData class]]) &#123; [output didEndDecode:nil error:[NSError errorWithDomain:@\"当前数据类型非NSData\" code:-1 userInfo:nil]]; return; &#125;2.初始化, 并截取包头数据 self.needAppend = NO; NSData *packetData = object; [self.tempData appendData:packetData]; packetData = [self.tempData copy]; NSData *headerData = [packetData subdataWithRange:NSMakeRange(0, countOfLengthByte)]; NSUInteger contentLength = [self lengthForData:headerData reverse:YES];3.判断是否粘包while (packetData.length &gt;= contentLength) &#123; &#125; 3.1 判断包的长度 if (contentLength &gt; 1000000 - countOfLengthByte) &#123; // 服务器定的... [output didEndDecode:nil error:[NSError errorWithDomain:@\"数据太长\" code:-1 userInfo:nil]]; return; &#125; 3.2截取包体内容 NSData *contentData = [packetData subdataWithRange:NSMakeRange(countOfLengthByte, contentLength)]; 3.3 输出一个完整的包, 截取剩余的包 [output didEndDecode:contentData error:nil]; packetData = [packetData subdataWithRange:NSMakeRange(contentLength + countOfLengthByte , packetData.length - contentLength - countOfLengthByte)]; 3.4 判断包头长度, 如果小于规定的, 则跳出循环, 等待拼接 if (packetData.length &lt; countOfLengthByte) &#123; if (self.tempData.length != 0) &#123; [self.tempData resetBytesInRange:NSMakeRange(0, self.tempData.length)]; [self.tempData setLength:0]; self.needAppend = YES; &#125; break; &#125; 3.5 截取包头的数据,计算长度 headerData = [packetData subdataWithRange:NSMakeRange(0, countOfLengthByte)]; contentLength = [self lengthForData:headerData reverse:YES]; 3.6.只要执行了while, 将tempData的数据清空, 拼接新的数据 if (self.tempData.length != 0) &#123; [self.tempData resetBytesInRange:NSMakeRange(0, self.tempData.length)]; [self.tempData setLength:0]; &#125; self.needAppend = YES; 一些小细节计算根据NSData包头的长度- lengthForData扫盲1234567891011121314NSData 中的length为NSUInteger类型接下来我们看看 NSUInteger为何物#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64typedef long NSInteger;typedef unsigned long NSUInteger;#elsetypedef int NSInteger;typedef unsigned int NSUInteger;#endif目前一般都为64位操作系统, 所以 NSUInteger 就是 unsigned long 占了8bits1字节(byte) = 8bits,两者换算是1：8的关系。略带:一个汉字占了两个字节 12345678910111213141516171819202122232425262728- (NSUInteger)lengthForData:(NSData *)data&#123; NSUInteger dataLen = data.length; NSUInteger length = 0; int offset = 0; while (offset &lt; dataLen) &#123; NSUInteger tempVal = 0; [data getBytes:&amp;tempVal range:NSMakeRange(offset, 1)]; length += (tempVal &lt;&lt; (8 * offset)); offset++; &#125; return length;&#125;1.将数据的高低位, 更改为低位在前,高位在后,如:&lt;00000045&gt; --&gt; &lt;45000000&gt;数据以16进制的形式展示,验证:利用计算器转换为十进制 等于 69.后附图.2.利用NSData 中的: - (void)getBytes:(void *)buffer range:(NSRange)range方法获取每一个字节3.(注意当前为:低位在前,高位在后)将每一个字节, 根据字节所属的范围,统一往左位移相应的 8 (1字节(byte) = 8bits)的倍数, 也就是说,将后面高位的字节,统一处理为低位的字节, 将统一格式的字节, 相加.利用%zd 输出每一个字节的 十进制的大小.进行检验. 高低位互换-dataWithReverse12345678910111213141516171819202122232425- (NSData *)dataWithReverse:(NSData *)data&#123; NSMutableData *dstData = [[NSMutableData alloc] initWithData:data]; NSUInteger count = data.length / 2; for (NSUInteger i = 0; i &lt; count; i++) &#123; NSRange head = NSMakeRange(i, 1); NSRange end = NSMakeRange(data.length - i - 1, 1); NSData *headData = [data subdataWithRange:head]; NSData *endData = [data subdataWithRange:end]; [dstData replaceBytesInRange:head withBytes:endData.bytes]; [dstData replaceBytesInRange:end withBytes:headData.bytes]; &#125; return dstData;&#125;1.例用NSMutableData 字节互换 的方法- (void)replaceBytesInRange:(NSRange)range withBytes:(const void *)bytes;2.遍历数据从收尾开始,依次将字节互换, 一般包头所占字节都不会太多, 所以只需遍历几次就可以完成,遍历的次数为字节总数减半 将长度转为占固定字节数的NSData - dataForLength1234567891011121314151617181920212223242526 NSMutableData *valData = [NSMutableData data]; NSUInteger templen = length; int offset = 0; while (offset &lt; byteCount) &#123; unsigned char valChar = 0xff &amp; templen; [valData appendBytes:&amp;valChar length:1]; templen = templen &gt;&gt; 8; offset++; &#125; return valData;1.利用:NSMutableData 的方法- (void)appendBytes:(const void *)bytes length:(NSUInteger)length;2.将数据 &amp; 0xff 0xff是十六进制FF的表示方法，因为一个十六进制数字转换成二进制是四位，即F=1111，所以0xff占用一个字节, 8bits&amp;符表示的是按位数进行与（同为1的时候返回1，否则返回0）保留后7位，高位清零,避免符号位扩展：3.while循环的说明:首先, 0xff &amp; templen, 只保留最低的字节, 获取到最低位的字节, 利用appendBytes, 将此字节添加进去, 进而将templen往右移8位, 也就是剔除刚才计算过的字节, 获取第二个字节,将第二个字节添加进去.依次往后直到将所有的包头字节添加完毕","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://github.com/icoderRo/tags/socket/"}]},{"title":"录音与本地播放","slug":"封装录音与播放","date":"2016-03-30T16:00:00.000Z","updated":"2017-08-17T14:53:38.000Z","comments":true,"path":"2016/03/31/封装录音与播放/","link":"","permalink":"https://github.com/icoderRo/2016/03/31/封装录音与播放/","excerpt":"简言近期由于要实现一个本地录音与播放的小功能, 想着把录音与播放集成在一个类中, 提供统一的接口, 方便其他同事调用. AVAudioRecorder 与 AVAudioPlayer都属于音频专用类(Audio-only classes),这些类是该框架中最古老, 也是最常用的几个类. AVAudioSessionAVAudioSession是应用程序和操作系统之间扮演中间人的角色.规定了应用程序(app)与系统音频行为交互的规范, 一个应用程序只有一个AVAudioSession的实例.应用程序通过设置AVAudioSession的属性告诉系统想到达的效果, 系统会综合其他应用程序的AVAudioSession属性来决定硬件输入/输出. AVAudioSession的分类 分类 作用 是否允许混音 音频输入 音频输出 Ambient 游戏、效率应用程序 ☑️ 无 ☑️ SoloAmbient(默认) 游戏、效率应用程序 无 无 ☑️ Playback 音频和视频播放器 可选 无 ☑️ Record 录音机、音频捕捉 无 ☑️ 无 PlayAndRecord VoIP、语音聊天 可选 ☑️ ☑️ AudioProcessing 离线会话和处理 无 无 无 MultiRoute 使用外部硬件的高级A/V应用程序 无 ☑️ ☑️ 上述分类所提供的几种常见的行为可以满足大部分的场景需求, 如果还需要更复杂的功能, 其中的一些分类可以通过options和modes方法进一步自定义. 项目中用到了三种状态: 1234567891011switch (session) &#123; case audioSessionAudioRecord: category = AVAudioSessionCategoryRecord; break; case audioSessionPlay: category = AVAudioSessionCategoryPlayback; break; default: category = AVAudioSessionCategoryAmbient; break; &#125; 初始化状态为:AVAudioSessionCategoryAmbient录音状态为:AVAudioSessionCategoryRecord播放状态为:AVAudioSessionCategoryPlayback","text":"简言近期由于要实现一个本地录音与播放的小功能, 想着把录音与播放集成在一个类中, 提供统一的接口, 方便其他同事调用. AVAudioRecorder 与 AVAudioPlayer都属于音频专用类(Audio-only classes),这些类是该框架中最古老, 也是最常用的几个类. AVAudioSessionAVAudioSession是应用程序和操作系统之间扮演中间人的角色.规定了应用程序(app)与系统音频行为交互的规范, 一个应用程序只有一个AVAudioSession的实例.应用程序通过设置AVAudioSession的属性告诉系统想到达的效果, 系统会综合其他应用程序的AVAudioSession属性来决定硬件输入/输出. AVAudioSession的分类 分类 作用 是否允许混音 音频输入 音频输出 Ambient 游戏、效率应用程序 ☑️ 无 ☑️ SoloAmbient(默认) 游戏、效率应用程序 无 无 ☑️ Playback 音频和视频播放器 可选 无 ☑️ Record 录音机、音频捕捉 无 ☑️ 无 PlayAndRecord VoIP、语音聊天 可选 ☑️ ☑️ AudioProcessing 离线会话和处理 无 无 无 MultiRoute 使用外部硬件的高级A/V应用程序 无 ☑️ ☑️ 上述分类所提供的几种常见的行为可以满足大部分的场景需求, 如果还需要更复杂的功能, 其中的一些分类可以通过options和modes方法进一步自定义. 项目中用到了三种状态: 1234567891011switch (session) &#123; case audioSessionAudioRecord: category = AVAudioSessionCategoryRecord; break; case audioSessionPlay: category = AVAudioSessionCategoryPlayback; break; default: category = AVAudioSessionCategoryAmbient; break; &#125; 初始化状态为:AVAudioSessionCategoryAmbient录音状态为:AVAudioSessionCategoryRecord播放状态为:AVAudioSessionCategoryPlayback AVAudioRecorder AVAudioRecorder构建与Audio Queue Services之上, 是一个功能强大且代码简单易用的OC接口.我们可以在iOS设备上使用这个类来从内置的麦克风录制音频, 也可以从外部音频设备进行录制, 比如耳机, USB麦克风等. 创建AVAudioRecorder123- (nullable instancetype)initWithURL:(NSURL *)url settings:(NSDictionary&lt;NSString *, id&gt; *)settings error:(NSError **)outError; 可见创建AVAudioRecorder实例, 需要三个参数 用于表示音频流写入文件的本地文件URL 包含用于配置录音会话键值信息的NSDictionary 用于捕捉错误的NSError指针 本地文件URL传入一个path, 去除PathExtension(规避), 新增PathExtension 123[NSURL fileURLWithPath:[[recordPath stringByDeletingPathExtension] stringByAppendingPathExtension:@\"wav\"]]; 录音会话键值信息NSDictionary123456789[[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithFloat: 11025.0],AVSampleRateKey, //采样率 [NSNumber numberWithInt: kAudioFormatLinearPCM],AVFormatIDKey,[NSNumber numberWithInt:16],AVLinearPCMBitDepthKey,//采样位数 [NSNumber numberWithInt: 2], AVNumberOfChannelsKey,//通道的数目[NSNumber numberWithInt:AVAudioQualityMax], AVEncoderAudioQualityKey, // 录音质量nil]; 音频格式 AVFormatIDKey键定义了写入内容的音频格式,常用的音频格式所支持的值: kAudioFormatLinearPCM kAudioFormatMPEG4AAC kAudioFormatAppleIMA4 kAudioFormatMPEGLayer3 kAudioFormatAMR …. 指定kAudioFormatLinearPCM 会将未压缩的音频流写入到文件中, 这种格式的保真度最高,相应的文件也是最大.选择AAC(kAudioFormatMPEG4AAC)或者kAudioFormatAppleIMA4的压缩格式会缩小文件, 同时还能保证高质量的音频内容. 录制的音频格式必须和参数定义的文件类型兼容.例如:录制一个aaa.wav的文件, 那么录制的音频必须满足WAVE的格式要求,即LinerPCM. 采样率 AVSampleRateKey用于定义录音器的采样率.输入的模拟音频信号每一秒的采样数,是影响音频质量和音频文件大小,非常重要的一个因素,采样率越小,文件越小,质量越低.标准的采样率有:8000、16000、22050、44100 人类可接收的音频范围为20Hz-20KHz. 音频最佳的采样率为所需采样对象的最高频率的两倍;AM广播类型的采样率为8KHz;CD质量的采样率为44.1KHz. 通道数 AVNumberOfChannelsKey记录音频内容的通道数.默认值为1,即用单声道录制, 设置为2使用立体声录制.一般情况用单声道录音 指定格式的key AVEncoderAudioQualityKey - 录音质量 AVEncoderBitRateKey - 音频比特率 AVEncoderBitRatePerChannelKey - 每条通道的音频比特率 … 监听麦克风是否允许使用1234567891011121314- (BOOL)checkMicrophoneAvailability&#123; __block BOOL open = NO; AVAudioSession *session = [AVAudioSession sharedInstance]; if ([session respondsToSelector:@selector(requestRecordPermission:)]) &#123; [session performSelector:@selector(requestRecordPermission:) withObject:^(BOOL status) &#123; open = status; &#125;]; &#125; else &#123; open = YES; &#125; return open;&#125; AVAudioPlayerAVAudioPlayer构建于CoreAudio中的C-based Audio Queue Services的顶层, 提供了在Audio Queue Services所能找到的核心功能, 例如:播放、循环、音频计量, 使用的是非常友好并简单的OC接口.AVAudioPlayer只能播放本地音频, 从网络流中播放音频使用AVPlayer.这里暂且不讨论AVPlayer. 创建AVAudioPlayer12345- (nullable instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;- (nullable instancetype)initWithData:(NSData *)data error:(NSError **)outError; 我们采用URL的方式创建, 只需要传入一个本地URL URL必须在应用程序沙盒内 12345self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:audioUrl error:&amp;error];[self.player prepareToPlay];[self.player play]; 调用prepareToPlay这个方法是可选的, 当调用play方法时会隐形激活, 不过在创建时调用, 可以降低调用play方法和听到声音输出之间的延时. 处理中断事件当有电话拨打进来或者VoIP电话, 我们应该做出及时的反应,监听AVAudioSessionInterruptionNotification状态 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]]; 如果AVAudioSessionInterruptionType为AVAudioSessionInterruptionTypeBegan则停止当前播放.如果type为AVAudioSessionInterruptionTypeEnded且options为AVAudioSessionInterruptionOptionShouldResume则重新播放. 1234567891011121314- (void)handleInterruption:(NSNotification *)note&#123; NSDictionary *info = note.userInfo; AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue]; if (type == AVAudioSessionInterruptionTypeBegan) &#123; [self stopPlaying];// &#125; else &#123;// AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];// // if (options == AVAudioSessionInterruptionOptionShouldResume) &#123;// // 重新播放// &#125; &#125;&#125; 对线路改变的响应在iOS设备上添加,移除音频输入、输出线路时, 会发生线路的改变, 如:用户插入耳机或断开USB麦克风等.这些事件的发生, 音频就会根据情况改变输入/输出线路.监听AVAudioSessionRouteChangeNotification状态 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]]; 接收通知后先判断线路变更发生的原因, 通过userInfo中的AVAudioSessionRouteChangeReasonKey推断不同的事件, 例如耳机断开这个事件的原因为:AVAudioSessionRouteChangeReasonOldDeviceUnavailable, 接着获取描述前一个线路的信息AVAudioSessionRouteDescription, 从线路的第一个输入接口判断其是否为耳机接口.如果是, 则代码耳机拔出, 停止播放. 1234567891011121314151617- (void)handleRouteChange:(NSNotification *)note&#123; NSDictionary *info = note.userInfo; AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue]; // 耳机断开的事件为例 if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123; AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey]; AVAudioSessionPortDescription *previousOutput = previousRoute.outputs.firstObject; NSString *portType = previousOutput.portType; if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123; [self stopPlaying]; &#125; &#125;&#125; 切换听筒和扬声器当我们将手机贴近耳朵时候, 当前语音播放应该是听筒模式, 当我们拿着手机观看时候, 当前的语音播放应该是扬声器的模式.我们应该获取设备的红外感应setProximityMonitoringEnabled的状态为YES, 并监听状态的更改UIDeviceProximityStateDidChangeNotification 123456789101112- (void)changeProximityMonitorEnableState:(BOOL)enable &#123; [[UIDevice currentDevice] setProximityMonitoringEnabled:YES]; if ([UIDevice currentDevice].proximityMonitoringEnabled == YES) &#123; //监听距离事件，先设置为YES，如果设置完后还是NO，说明当前设备近距离传感器不可用 if (enable) &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sensorStateChange) name:UIDeviceProximityStateDidChangeNotification object:n &#125; else &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceProximityStateDidChangeNotification object:nil]; [[UIDevice currentDevice] setProximityMonitoringEnabled:NO]; &#125; &#125;&#125; 监听状态的改变 sensorStateChange 如果此时手机靠近面部放在耳朵旁，那么声音将通过听筒输出，并将屏幕变暗. 1234567891011121314- (void)sensorStateChange &#123; if ([[UIDevice currentDevice] proximityState] == YES) &#123; //黑屏 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil]; &#125; else &#123; //没黑屏幕 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:nil]; if (![self isPlaying]) &#123; //没有播放了，也没有在黑屏状态下，就可以把距离传感器关了 [[UIDevice currentDevice] setProximityMonitoringEnabled:NO]; &#125; &#125;&#125; Audio MeteringAudio Metering可以让我们获取到音频的平均值分贝和峰值的分贝数据.averagePowerForChannel和peakPowerForChannel这两个方法都会返回一个用于表示声音分贝等级的浮点值. 这个值的范围最大分贝0dB - 最小分贝或静音 -160dB.每次需要读取最新的值, 开启一个定时器,执行定时器的方法,调用updateMeters.根据averagePowerForChannel放回的值进行设置. 1234567891011121314151617181920212223242526272829- (void)timerAction&#123; if (self.status == subTitleStatuesDefault) &#123; if ([LCAudioRecord recorder]) [[LCAudioRecord recorder] updateMeters]; float peakPower = [[LCAudioRecord recorder] averagePowerForChannel:0]; double ALPHA = 0.05; double value = pow(10, (ALPHA * peakPower)); if (value &lt; 0.1 ) &#123; self.bordImageView.image = [UIImage imageNamed:@\"语音中-1\"]; &#125; else if (value &lt; 0.15) &#123; self.bordImageView.image = [UIImage imageNamed:@\"语音中-2\"]; &#125; else if (value &lt; 0.25) &#123; self.bordImageView.image = [UIImage imageNamed:@\"语音中-3\"]; &#125; else if (value &lt; 0.35) &#123; self.bordImageView.image = [UIImage imageNamed:@\"语音中-4\"]; &#125; else if (value &lt; 0.9 ) &#123; self.bordImageView.image = [UIImage imageNamed:@\"语音中-5\"]; &#125; &#125; self.seconds ++; if (self.seconds &gt;= 599.9) &#123; [self.class dismiss]; [[NSNotificationCenter defaultCenter] postNotificationName:@\"recordDUrationToolong\" object:nil]; &#125;&#125; 封装思路: 创建一个AudioManager统一管理audioRecord和audioPlay 先分别实现audioRecord和audioPlay相关的方法 基于audioRecord和audioPlay提供的方法 在AudioManager 统一进行封装接口. 利用block的形式回调 最终接口形式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051+ (instancetype)manager;#pragma mark - LCAudioRecord// 判断麦克风是否可用- (BOOL)checkMicrophoneAvailability; /** * 开始录音 * */- (void)startRecordingWithFileName:(NSString *)fileName completion:(void(^)(NSError *error))completion;/** * 停止录音 * */- (void)stopRecordingWithCompletion:(void(^)(NSString *recordPath, NSInteger aDuration, NSError *error))completion;/** * 取消录音 */- (void)cancelRecording;/** * 当前是否正在录音 * */- (BOOL)isRecording;#pragma mark - LCAudioPlay/** * 播放音频 * */- (void)playingWithRecordPath:(NSString *)recordPath completion:(void(^)(NSError *error))completion;/** * 停止播放 * */- (void)stopPlaying;/** * 当前是否正在播放 * */-(BOOL)isPlaying; 录音指示器的接口: 12345678910typedef NS_ENUM(NSInteger, subTitleStatues) &#123; subTitleStatuesDefault, subTitleStatuesCancel,&#125;;@interface LCMetersRecordingView : UIView// 根据 状态更改 显示的内容+ (void)subTitleLabelStatues:(subTitleStatues)statues;+ (void)show;+ (void)dismiss;@end 如何使用:1234567891011121314151.开始录音// 检测麦克风是否可用[LCAudioManager manager] checkMicrophoneAvailability][[LCAudioManager manager] startRecordingWithFileName:[NSString recordFileName] completion:nil];2.结束录音[[LCAudioManager manager] stopRecordingWithCompletion:^(NSString *recordPath, NSInteger aDuration, NSError *error) &#123; if (aDuration &lt; 1) &#123; [MBProgressHUD showError:@\"录音时间过短\"]; return ; &#125; if (!error) &#123; // 录音成功 // 执行下一步计划 &#125; &#125;];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"AVFoundation","slug":"AVFoundation","permalink":"https://github.com/icoderRo/tags/AVFoundation/"}]},{"title":"TCP/IP网络安全(六)","slug":"网络安全","date":"2016-01-11T16:00:00.000Z","updated":"2017-08-17T15:03:04.000Z","comments":true,"path":"2016/01/12/网络安全/","link":"","permalink":"https://github.com/icoderRo/2016/01/12/网络安全/","excerpt":"###TCP/IP网络安全TCP/IP相关的安全要素如下图所示。 防火墙组织机构内部的网络与互联网相连时, 为了避免内部网络受到非法访问的威胁, 会设置防火墙。 使用NAT的情况下, 由于限定了可以从外部访问的地址, 因此也能起到防火墙的作用。 防火墙有多种种类和形态, 专门过滤特定数据包的包过滤防火墙, 数据到达应用以后由应用处理并拒绝非法访问的应用网关。防火墙可以限制从互联网访问的主机个数; 将安全的主机和可以暴露的主机加以区分, 针对后者集中实施安全防护。 下图中, 对路由器设置了只向其发送特定地址和端口号的包, 也就是设置了一个包过滤防火墙。当从外部过来TCP通信请求时, 只允许对Web服务器的TCP 80端口和邮件服务器的TCP 25端口访问。其他所有类型的包都会被丢弃。此外, 建立TCP连接的请求只允许从内网发起, 不能从外网直接连接内网。","text":"###TCP/IP网络安全TCP/IP相关的安全要素如下图所示。 防火墙组织机构内部的网络与互联网相连时, 为了避免内部网络受到非法访问的威胁, 会设置防火墙。 使用NAT的情况下, 由于限定了可以从外部访问的地址, 因此也能起到防火墙的作用。 防火墙有多种种类和形态, 专门过滤特定数据包的包过滤防火墙, 数据到达应用以后由应用处理并拒绝非法访问的应用网关。防火墙可以限制从互联网访问的主机个数; 将安全的主机和可以暴露的主机加以区分, 针对后者集中实施安全防护。 下图中, 对路由器设置了只向其发送特定地址和端口号的包, 也就是设置了一个包过滤防火墙。当从外部过来TCP通信请求时, 只允许对Web服务器的TCP 80端口和邮件服务器的TCP 25端口访问。其他所有类型的包都会被丢弃。此外, 建立TCP连接的请求只允许从内网发起, 不能从外网直接连接内网。 IDS(入侵检测系统)IDS检测已经侵入内部网络进行非法访问的情况, 并及时通知给网络管理员的系统。IDS根据不同的用途可以提供各种不同的功能。从设置形式上看, 一般在防火墙或DMS等边界设备上进行设置。有了这样的监控、检测边界的功能, 就可以设置在网络内部、全网或个别特殊的服务器上进行监控。从功能上看, IDS有定期采集日志、长期监控、通知异常等功能。可以监控网络上流动的所有数据包, 与防火墙相辅相成。 加密技术加密指的是利用密钥对明文的数据通过一定的算法变换成密文的过程, 逆反过程叫解密。 加密和解密使用相同的密钥叫做对称加密方式, 加密和解密的过程中使用不同的密钥叫做非对称加密。 对称加密对称加密方式包括AES、DES等加密标准, 对称加密的优点在于加解密的效率比较高, 缺点在于如何保证密钥是安全的。 非对称加密非对称加密中, 利用公钥(公开的密钥)加密的数据只能通过私钥解密, 使用私钥加密的数据就需要公钥进行解密。公钥加密方法中常见的加密算法是RSA算法。 HTTPSHTTPS其实就是安全的HTTP, 也就是HTTP的安全升级版本, HTTP属于应用层的协议, HTTP协议之下是传输协议TCP, HTTPS就是在HTTP与TCP中间加多了一层加密层TLS/SSL。 TLS/SSLSSL/TLS协议的基本思路是客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。通俗的讲, SSL是用来加密的, TLS是SSL的升级版本。TLS/SSL协议运行机制 HTTP中应用层直接将数据传输给TCP, 在HTTPS中应用层将数据传输给TLS/SSL加密后, 在传输给TCP进行传输。 HTTPS加密通信简略流程HTTPS中采用对称加密方式, 在发送其公共密钥时采用的是公钥加密方式。 1.浏览器访问网站, 网站将自己的证书给到浏览器 2.浏览器从证书中获取网站的公钥A 3.浏览器生成一个对称密钥B, 并用公钥A加密后, 传送给网站 4.网站通过私钥解密, 拿到对称密钥B 5.之后通信的数据, 都使用密钥B进行加密 辨别伪造的证书 完全伪造的证书 – 对证书进行检查1.证书颁发的机构是伪造的, 浏览器不认识, 直接认为是危险证书2.证书颁发机构确实存在, 根据CA名, 找到内置的CA根证书、CA的公钥, 利用公钥对伪造的证书摘要进行解密, 如果解密失败, 则认为是危险证书。 篡改过的证书 – 假设代理通过某种途径, 拿到XX的证书, 然后将证书的公钥偷偷修改成自己的。1.检查证书, 根据CA名, 找到对应的CA根证书, 以及CA的公钥2.用CA的公钥, 对证书的数字签名进行解密, 得到对应的证书摘要AA3.根据证书签名使用的hash算法, 计算出当前证书的摘要BB4.对比两个摘要, 发现不一致, 则为危险的证书 浅析数字证书 参考: 图解TCP/IP http://www.jianshu.com/nb/3276500 HTTP科普扫盲贴","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"TCP/UDP(五)","slug":"TCP:UDP","date":"2015-12-31T16:00:00.000Z","updated":"2017-08-17T14:51:43.000Z","comments":true,"path":"2016/01/01/TCP:UDP/","link":"","permalink":"https://github.com/icoderRo/2016/01/01/TCP:UDP/","excerpt":"TCP/UDPTCP与UDP是传输层的两个主要协议。TCP提供可靠的通信的传输, 而UDP面向无连接的不可靠的通信传输。 网络层中的IP首部中有一个协议的字段, 用来标识网络层的上一层采用的是哪一种传输层的协议。根据这个字段的协议号, 就可以识别IP传输的数据部分是TCP的内容, 还是UDP的内容。同理,传输层使用端口号识别在传输层的上一层(应用层)中要进行处理的程序。 端口号数据链路和IP地址, 分别对应MAC地址和IP地址。前者用来识别同一链路中不同的计算机, 后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有类似的地址概念, 那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序, 也叫做程序地址。 通信识别仅仅凭目标端口识别某一个通信是远远不够的。如下图: 1和2的通信是在两台计算机上进行的。他们的目标端口号都是80, 需要根据源端口号进行区分。3和1的目标端口号和源端口号完全相同, 但是他们各自的源IP地址不同。另外协议号不同, 也会被认为是两个不同的通信。 综上, TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。分别是: 源IP地址、目标IP地址、协议号、源端口号、目标端口号。只有5个信息一致, 才认为是同一个通信。","text":"TCP/UDPTCP与UDP是传输层的两个主要协议。TCP提供可靠的通信的传输, 而UDP面向无连接的不可靠的通信传输。 网络层中的IP首部中有一个协议的字段, 用来标识网络层的上一层采用的是哪一种传输层的协议。根据这个字段的协议号, 就可以识别IP传输的数据部分是TCP的内容, 还是UDP的内容。同理,传输层使用端口号识别在传输层的上一层(应用层)中要进行处理的程序。 端口号数据链路和IP地址, 分别对应MAC地址和IP地址。前者用来识别同一链路中不同的计算机, 后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有类似的地址概念, 那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序, 也叫做程序地址。 通信识别仅仅凭目标端口识别某一个通信是远远不够的。如下图: 1和2的通信是在两台计算机上进行的。他们的目标端口号都是80, 需要根据源端口号进行区分。3和1的目标端口号和源端口号完全相同, 但是他们各自的源IP地址不同。另外协议号不同, 也会被认为是两个不同的通信。 综上, TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。分别是: 源IP地址、目标IP地址、协议号、源端口号、目标端口号。只有5个信息一致, 才认为是同一个通信。 端口号的确定 标准既定的端口号这种方法也叫静态方法, 指每个应用程序都有其指定的端口号。知名端口号一般由0~1023的数字分配而成, 应用程序需要避免使用知名端口号, 可以使用1024~49151之间的数字作为自定义端口号。 时序分配法这种方法也叫动态方法, 此时服务端有必要确定监听端口号, 但是接受服务的客户端没必要确定端口号。客户端应用程序完全不用自己设置端口号, 全权交给操作系统进行分配。操作系统可以为每个应用程序分配互不冲突的端口号。例如, 每需要一个新的端口号, 就在之前分配号码的基础上加1。动态分配的端口号的取值范围在49152~65535之间。 UDPUDP不提供复杂的控制机制, 利用IP提供面向无连接的通信服务。因此UDP不检查对端是否可以通信, 直接将UDP包发送出去。即使是出现网络拥堵的情况下, UDP也无法进行流量控制等避免网络拥塞的行为。此外, 传输途中出现丢包, UDP也不负责重发等。UDP常用于一下几个方面: 包总量较少的通信(DNS、SNMP等) 视频、音频等多媒体通信 限定于LAN等特定网络中的应用通信 广播/多播通信 UDP首部UDP首部由源端口号, 目标端口号, 包长和校验和组成。 源端口号: 表示发送端口号 目标端口号: 接收端端口号 包长度: 保存UDPs首部和数据长度之和 校验和: 校验和用来判断数据在传输过程中是否损坏 TCPTCP对数据的传输、发送、通信都进行了控制的协议。可以进行丢包时的重发控制, 可以对次序乱掉的分包进行顺序控制, 只有在确认通信对端存在时才会发送数据, 从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。 TCP首部TCP没有包长度和数据长度, 可由IP层获知TCP的包长度, 由包长可知数据的长度。 端口号: 发送端端口号 目标端口号: 接收端端口号 序列号: 发送数据的位置 确认应答号: 下一次应该收到的数据的序列号 数据偏移: 表示TCP传输的数据部分从包的哪个位置开始计算 保留: 为以后扩展使用 控制位: 控制各种状态 窗口大小: 能够接收的数据大小 校验和: 与UDP相似 紧急指针: 与紧急数据相关 选项: 用于提高TCP传输性能, 将数据调整为32位的整数倍 序列号与确认应答在TCP中, 当发送端的数据到达接收端时, 接收端主机会返回一个已收到消息的通知, 这个消息叫做确认应答(ACK), 否定确认应答(NACK)。TCP通过肯定的确认应答(ACK)实现可靠的数据传输。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答, 说明数据已经成功到达对端。反之, 则数据丢失的可能性很大。在一定时间内没有等到确认应答, 发送端就可以认为数据已经丢失, 并进行重发。由此, 即使产生了丢包, 仍然能够保证数据能够到达对端, 实现可靠传输。 未收到确认应答并不意味着数据一定丢失。也可能是数据对方已经收到, 只是确认返回的确认应答在途中丢失。这种情况也会导致发送端因为没有收到确认应答, 从而进行重发数据。 此外, 也有可能因为一些其他原因导致确认应答延迟到达, 在源主机重发数据以后才到达的情况也经常见。此时, 源发送主机只要按照既定机制重发数据即可。但是对于目标主机来说, 它会反复收到相同的数据。而为了对上层应用提供可靠的传输, 必须得放弃重复的数据包。因此需要引入一种机制, 能够识别是否已经接收数据, 判断是否需要接收数据等。序列号可以实现确认应答处理、重发控制以及重复控制等功能; 序列号是按顺序给发送数据的每一个字节都标上号码的编号。 接收端查询接收数据TCP首部中的序列号和数据长度, 将自己下一步应该接收的序号作为确认应答返送回去。通过序列号和确认应答号, TCP可以实现可靠的传输。 连接管理TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作。TCP会在数据通信之前, 通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答, 则认为可以进行数据通信。如果对端的确认应答未能到达, 就不会进行通信。在通信结束的时候回进行断开连接的处理(FIN包), 也就是发送一个FIN包, 确认断开连接。建立一个TCP连接需要发送3个包, 也叫做”三次握手”, 断开TCP连接需要发送4个包, 也叫”四次挥手”。所以一个连接的建立与断开,至少需要来回发送7个包才能完成。 TCP以段位单位发送数据在建立TCP连接的同时, 也可以确定发送数据包的单位(最大消息长度:段 :MSS,)。MSS是在三次握手的时候, 在两端主机之间被计算得出。两端的主机在发出建立连接请求时, 会在TCP首部中写入MSS选项, 告诉对方自己的接口能够适应的MSS的大小。之后, 在此之间选择一个最小的MSS的值。 #####窗口控制TCP以1个段为单位, 每发一个段进行一次确认应答的处理, 这种传输方式有一个缺点, 包的往返时间越长通信性能越低。 为了解决这个问题 TCP引入了窗口的概念, 使在往返时间较长的情况下, 也能控制网络性能的下降。确认应答不再是以每个分段, 而是以更大的单位进行确认, 转发时间将会被大幅度的缩短。窗口大小:指无需等待确认应答而可以继续发送数据段的最大值。这个机制的实现使用了大量的缓冲区。 发送端主机在等到确认应答返回之前, 必须在缓冲区中保留这部分数据。当数据发出后若如期收到确认应答就可以不用再进行重发, 此时数据就可以从缓存区清除。收到确认应答的情况下, 将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。 窗口控制与重发在使用窗口控制中, 处理段丢失的情况。 确认应答未能返回的情况在这种情况下, 数据已经到达对端, 是不需要进行重发的。 某个段丢失的情况接收主机如果收到一个本应该接收的序号以外的数据时, 会针对当前为止收到数据返回确认应答。发送端主机如果连续3次收到同一个确认应答, 就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效, 也称作高速重发控制。 流控制流控制:让发送端根据接收端的实际接收能力控制发送的数据量。接收端主机向发送端主机通知自己可以接收数据的大小, 于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口的大小 。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大, 说明网络的吞吐量越高。接收端的缓冲区一旦面临数据溢出时, 窗口大小的值也会随之被设置为一个更小的值通知给发送端, 从而控制数据发送量。简而言之, 发送端主机会根据接收端主机的提示, 对发送的数据量进行控制。 窗口探测的数据段, 次数据段仅包含一个字节以获取最新的窗口大小信息。 拥塞控制在网络出现拥堵时, 如果突然发送一个较大量的数据, 极有可能会导致整个网络的瘫痪。TCP为了防止该问题得出现, 在通信一开始就会通过一个叫做慢启动的算法得出的数值, 对发送数据量进行控制。 首先为了在发送端调节所要发送的数据的量, 定义了一个叫做”拥塞的窗口”, 在慢启动的时候, 将这个拥塞窗口的大小设置为1个数据段(1MSS)发送数据, 之后每收到一次ACK,就将拥塞窗口的值+1, 在发送数据包时, 将拥塞窗口的大小与接收端主机的窗口大小做比较, 按照两者中较小的值, 发送比这个值还要小的数据量。随着包的每次往返, 拥塞窗口会以1、2、4等指数函数的增长, 拥堵状况激增甚至导致网络拥塞的发生。为了防止这些, 引入了慢启动阀值的概念。只要拥塞窗口的值超过这个阀值, 会按照某种规则控制拥塞窗口的数量。 思考三次握手二次握手:在网络请求中, 客户端向服务器发送了一个SYN包,请求建立连接。由于延迟, 服务端没有及时收到包; 于是客户端重新发送一个SYN包。假设服务端接收了第二个SYN包, 建立了通信, 一段时间后通信结束, 连接被关闭。这时候最初被发送的SYN包刚被服务端接收, 服务端发回ACK后,就会建立连接, 由于是前一次的连接请求, 并没有被使用, 这样就导致服务端建立了一个空的连接。三次握手: 服务端发回ACK后, 客户端会丢弃这个数据包, 不会和服务端进行第三次的握手, 因此可以避免服务端空的连接。 建立ACK确认包丢失TCP协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到 ACK 确认为止。实际上这种做法有可能遭到SYN泛洪攻击。所谓的泛洪攻击，是指发送方伪造多个 IP 地址，模拟三次握手的过程。当服务器返回 ACK 后，攻击方故意不确认，从而使得服务器不断重发 ACK。由于服务器长时间处于半连接状态，最后消耗过多的 CPU 和内存资源导致死机。正确做法:服务端发送RST报文, 进入关闭状态, 这个RST数据包的TCP首部中, 控制位中的RST位被设置为1, 表示连接信息全部被初始化, 原有的TCP通信不能继续; 客户端如果还想重新建立TCP连接, 就必须重新开始第一次握手。 关闭连接的最后一个ACK丢失实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。 TCP与UDP的区别TCP是面向连接的、可靠的流协议, 在使用TCP协议传输数据之前需要确认发送方和接收方的连接是建立的, 建立连接需要三次握手, 关闭连接需要四次挥手。流就是指不间断的数据结构。TCP为提供可靠性传输, 实行”顺序控制”或”重发控制”机制;还具备”流量控制”, “拥塞控制”, 提高网络利用率等众多功能。 UDP是不具有可靠性的数据报协议。UDP可以确保发送消息的大小, 不能保证消息的是否会到达目标主机。因此, 需要在应用自行控制重发等机制。 TCP用于在传输层有需要实现可靠传输的情况。由于它是面向有连接并且具备顺序控制、重发控制等机制的, 所以它可以为应用提供可靠的传输, 由此决定了TCP需要制定很多复杂的规范, 所以传输效率不如UDP协议, 不适合实时的音视频传输。在另一方面, UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。 参考: http://www.jianshu.com/nb/3276500 图解TCP/IP","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"IP相关的协议(四)","slug":"IP相关的协议","date":"2015-12-23T16:00:00.000Z","updated":"2017-08-17T14:50:53.000Z","comments":true,"path":"2015/12/24/IP相关的协议/","link":"","permalink":"https://github.com/icoderRo/2015/12/24/IP相关的协议/","excerpt":"IP相关的协议IP的目的是让最终目标主机收到数据包, 但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能, 以及数据包在发送过程中异常情况处理的功能。 DNS我们平常在访问某个网站时, 域名(域名是指为了识别主机名称和组织机构名称的一种具有分层的名称。比如在域名 bnu.edu.cn中，neu是主机名，edu 和 cn 是不同层次下的机构名), 而不是使用IP地址。能够这样做是因为有了DNS。DNS可以将自身具有意义的域名自动转换为具体的IP地址。 在Windows/Unix中查找域名对应的IP地址可以输入nslookup 域名 DNS查询以访问www.ietf.org为例,此时的DNS查询流程如图所示: 解析器为了查询IP地址, 向域名服务器进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回, 如果没有, 则域名服务器再向上一层跟域名服务器进行查询处理。解析器和域名服务器将最新了解到的信息暂时保存在缓存里。这样, 可以减少每次查询时的性能消耗。","text":"IP相关的协议IP的目的是让最终目标主机收到数据包, 但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能, 以及数据包在发送过程中异常情况处理的功能。 DNS我们平常在访问某个网站时, 域名(域名是指为了识别主机名称和组织机构名称的一种具有分层的名称。比如在域名 bnu.edu.cn中，neu是主机名，edu 和 cn 是不同层次下的机构名), 而不是使用IP地址。能够这样做是因为有了DNS。DNS可以将自身具有意义的域名自动转换为具体的IP地址。 在Windows/Unix中查找域名对应的IP地址可以输入nslookup 域名 DNS查询以访问www.ietf.org为例,此时的DNS查询流程如图所示: 解析器为了查询IP地址, 向域名服务器进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回, 如果没有, 则域名服务器再向上一层跟域名服务器进行查询处理。解析器和域名服务器将最新了解到的信息暂时保存在缓存里。这样, 可以减少每次查询时的性能消耗。 ARP在网络层, 只要确定了IP地址, 就可以向这个目标地址发送IP数据报。在数据链路层, 进行通信时需要了解每个IP地址多对应的MAC地址。ARP是一种解决地址问题得协议,根据目标IP地址为线索,用来定位下一个接收数据分包的网络设备对应的MAC地址。 ARP工作机制ARP借助ARP请求与ARP响应两种类型的包确定MAC地址。 主机A为了获取主机B的MAC地址, 起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。也就是书, ARP请求包中已经包含了主机B的IP地址。由于广播的包可以被同一个链路上所有的主机或路由器接收, 因此ARP请求包也就会被同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标IP地址与自己的IP地址一致, 那么这个节点就将自己的MAC地址塞入ARP响应包, 返回给主机A。主机A将获取到的MAC地址缓存一段时间, 以减少ARP包的发送与流量的浪费。 RARP是将ARP反过来, 从MAC地址定位IP地址的一种协议。代理ARP, 通常ARP包会被路由器隔离, 但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此, 两个以上网段的节点之间可以像在同一个网段中一样进行通信。 ICMPICMP的主要功能: 确认IP包是否成功送达目标地址, 通知发送过程当中IP包被废弃的具体原因, 改善网络设置等。因此可以监听网络是否正常、设置是否有误以及设备有何异常等信息。 ICMP的消息大致可以分为两类: 一类是通知出错原因的错误消息, 另一类是用于诊断的查询消息。 ICMP的主要消息 ICMP目标不可达消息(类型3)IP路由器无法将IP数据报发送给目标地址时, 会给发送端主机返回一个目标不可达的ICMP消息, 并在这个消息中显示不可达的具体原因。 ICMP重定向消息(类型5)如果路由器发现发送端主机使用了次优的路径发送数据, 那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。多数情况下由于这种重定向消息成为引发问题的原因, 所以一般不进行这种设置。 ICMP超时消息(类型11)IP包中有一个字段叫做TTL, 它的值会随着每经过一次路由器就会减1, 减到0该IP包就会被丢弃。此时, IP路由器将会发送一个ICMP超时的消息给发送端主机, 并通知该包已被丢弃。设置IP包生存周期的主要目的, 是为了在路由控制发生循环状况时,避免IP包无休止的在网络上被转发; 此外可以利用TTL控制包的到达范围。 ICMP回送消息(类型0、8)用于所发送的数据包是否已经成功到达对端的一种消息。可以向对端主机发送回送请求的消息, 也可以接收对端主机发回来的回送应答消息。ping就是利用这个消息实现的。 DHCPDHCP实现了自动设置IP地址、统一管理IP地址的分配,也就是说,DHCP实现了即插即用。 DHCP工作机制 NATNAT是用于在本地网络中使用私有地址, 在连接到互联网时转而使用全局IP地址的技术。除了可以转换IP地址外, 还可以转换TCP、UDP端口号的NAPT技术, 由此可以实现用一个全局IP地址与多个主机的通信。 NAT工作机制在NAT(NAPT)的路由器内部, 有一张自动生成的用来转换地址的表。当私有网络内的多台机器同时与外部进行通信, 仅仅转换IP地址, 全局IP地址可能会出现不够用的情况, 这时采用和端口号一起转换的方式(NAPT)可以解决这个问题。 NAPT工作机制转换表在NAT路由器上自动生成, 以TCP为例, 在建立TCP连接的首次握手时的SYN包一经发出, 就会生成这个表。而后收到关闭连接时发出的FIN包的确认应答后就从表中被删除。 NAT-PTNAT-PT是将IPv6的首部转换为IPv4的首部的一种技术。让那些只有IPv6地址的主机也能够与IPv4地址的其他主机进行通信。 NAT的潜在问题 无法从NAT的外部向内部服务建立连接 转换表的生成与转换操作都会产生一定开销 通信过程中一旦NAT遇到异常需要重新启动, 所有的TCP连接都会被重置。 解决NAT的潜在问题 1.改用IPv6 2.”NAT穿越” IP隧道IP隧道中可以将IPv6的包合成为一个数据, 再追加一个IPv4的首部后, 让IPv4的网络识别。这种在网络层的首部后面继续追加网络层首部的通信方式就叫做”IP隧道”。 显示拥塞通知(ECN)ECN为实现拥塞通知的功能, 将IP首部的TOS字段置换为ENC字段, 并在TCP首部的保留位中追加拥塞窗口减少(CWR)和ECE表示。 ECN的机制概括起来就是在发送包的IP首部中记录路由器是否遇到拥塞, 并在返回包的TCP首部中通知是否发生过拥塞。拥塞检查在网络层(IP)进行, 而拥塞通知则在传输层(TCP)进行。 参考: 图解TCP/IP","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"IP协议(三)","slug":"IP协议","date":"2015-12-17T16:00:00.000Z","updated":"2017-08-17T14:51:07.000Z","comments":true,"path":"2015/12/18/IP协议/","link":"","permalink":"https://github.com/icoderRo/2015/12/18/IP协议/","excerpt":"IP协议IP(IPv4、IPv6)相当于参考模型中的第三层–网络层。 网络层的主要作用是: 实现终端节点之间的通信; 也叫做点对点通信。 主机: 配置有IP地址, 不进行路由控制路由器: 既配有IP地址, 又具有路由控制能力节点: 主机和路由器的统称 数据链路层的主要作用是在互连同一种数据链路的节点之间进行包的传递。而一旦跨越多种数据链路, 就需要借助网络层。网络层可以跨越不同的数据链路, 在不同的数据链路上也能实现两端节点之间的数据包传输。 ###IP地址数据链路层的MAC地址是用来标识同一个链路中不同计算机的一种识别码。作为网络层的IP, 也有这种地址信息, 叫做IP地址。IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址, 在TCP/IP通信中所有的主机/路由器都必须设定自己的IP地址, 用IP地址识别主机和路由器。 不论主机与哪种数据链路连接, 其IP地址的形式都保持不变, 在网桥/交换机集线器等物理层或数据链路层的数据包转发设备中, 不需要设置IP地址, 因为这些设备只负责将IP包转化为0、1的比特流转发或者数据链路帧的数据部分进行转发, 因而不需要对应IP协议。","text":"IP协议IP(IPv4、IPv6)相当于参考模型中的第三层–网络层。 网络层的主要作用是: 实现终端节点之间的通信; 也叫做点对点通信。 主机: 配置有IP地址, 不进行路由控制路由器: 既配有IP地址, 又具有路由控制能力节点: 主机和路由器的统称 数据链路层的主要作用是在互连同一种数据链路的节点之间进行包的传递。而一旦跨越多种数据链路, 就需要借助网络层。网络层可以跨越不同的数据链路, 在不同的数据链路上也能实现两端节点之间的数据包传输。 ###IP地址数据链路层的MAC地址是用来标识同一个链路中不同计算机的一种识别码。作为网络层的IP, 也有这种地址信息, 叫做IP地址。IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址, 在TCP/IP通信中所有的主机/路由器都必须设定自己的IP地址, 用IP地址识别主机和路由器。 不论主机与哪种数据链路连接, 其IP地址的形式都保持不变, 在网桥/交换机集线器等物理层或数据链路层的数据包转发设备中, 不需要设置IP地址, 因为这些设备只负责将IP包转化为0、1的比特流转发或者数据链路帧的数据部分进行转发, 因而不需要对应IP协议。 IP地址的定义IPv4地址由32位正整数来表示, IP地址在计算机内部以二进制的方式被处理, 为了方便管理, 将32位的IP地址以每8位一组, 分成4组,每组以.隔开, 再将每组数转换为十进制数。 将表示成IP地址的数字整体计算, 会得出大约43亿台计算机允许连接到网络。实际上, IP地址不是根据主机台数来配置的, 而是每一台主机上的每一块网卡都得设置IP地址, 通常一块网卡只设置一个IP地址, 一块网卡也可以配置多个IP地址。一台路由器通常都会配置两个以上的网卡, 因此可以设置两个以上的IP地址。 IP地址的组成IP地址由网络标识(网络地址)和主机标识(主机地址)两部分组成。 网络标识在数据链路的每个段配置不同的值。网络标识必须保证互相连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一个网段内重复出现。因此, 可以通过设置网络地址和主机地址, 在相互连接的整个网络中保证每台主机的IP地址都不会相互重叠, 即IP地址具有了唯一性。 如何区分网络标识和主机标识, 有两种类型, 一种是分类, 另一种是也是现在主流的方式子网掩码(网络前缀) IP地址分类IP地址分为四个级别, 根据IP地址中的第1位~第4位的比特位对其网络标识和主机标识进行区分, 共分为A、B、C、D四类。 A类地址是首位以”0”开头的地址。从第1位~第8位是网络标识, 后24位是主机标识。 B类地址是前两位以”10”开头的地址。从第1位~第16位是网络标识, 后16位是主机标识。 C类地址是前三位以”110”开头的地址。从第1位~第24位是网络标识, 后8位是主机标识。 D类地址是前四位以”1110”开头的地址。从第1位~第32位是网络标识, 没有主机标识, 常用于多播。 全部为0的主机地址: 代表网络/IP地址不可获知。全部为1的主机地址: 通常用于广播地址。在分配主机地址, 应该去掉这两种情况, 因此C类地址的每个网段最多只能有256-2个主机地址。 子网掩码分类造成浪费? 例如, 在架构B类型的IP网络时, 可以使用的主机标识大约有6万多个, 也就意味着, 一个链路内允许6万多台计算机连接; 实际网络架构中, 不会再同一个链路上连接6万多台计算机, 所以A/B类地址会造成浪费。 通过子网掩码细分出比A、B、C、D分类更细粒度的网络。就是将原来分类中的主机地址部分用作子网地址, 网络地址分为多个物理网络的一种机制。 引入子网以后, 一个IP地址就有了两种识别码, 一种是原来的IP地址本身, 另一个是表示网络部分的子网掩码。 子网掩码用二进制表示的话, 也是一个32位的数字。它对应的IP地址网络标识部分的位全部为”1”, 对应IP地址主机标识的部分则全部为”0”。由此一个IP地址可以不再受限于自己的类别, 而是可以用这样的子网掩码自由地定位自己的网络标识长度。子网掩码必须是IP地址的首页开始连续为”1”。 子网掩码有两种表示方式, 一种是将IP地址与子网掩码地址分别用两行来表示; 另外一种是在IP地址的后面追加网络地址的位数, 用”/“隔开。 地址表示 十进制 IP地址 172.20.100.52 子网掩码 255.255.255.192 地址表示 十进制 位数 IP地址 172.20.100.52 /26 172.20.0.0/26 与172.20/26是同一个意思, 可以省略后面的”0”CIDR: 采用任意长度分割IP地址的网络标识和主机标识, 也叫无类型域间选路。在CIDR被应用到互联网的初期, 网络内部采用固定长度的子网掩码机制, 采用统一的标注, 就难以架构一个高效的网络结构, 为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。VLSM: 可变长度子网掩码, 可以将网络地址分为主机数500个时子网掩码长度位/23, 主机数位50个时子网掩码长度位/26, 有了CIDR和VLSM技术, 相对缓解了全局IP地址不够用的问题, 但无法改变IPv4的地址绝对数是有限的问题。 全局地址与私有地址随着互联网的迅速普及, IP地址不足的问题日趋显著, 如果一直按照现行的方法采用唯一地址的话(每一台主机/路由器必须配有一个唯一的IP地址), 会有IP地址耗尽的危险。于是出现了一种新的技术。它不要求为每一台主机/路由器分配一个固定的IP地址, 而是在必要的时候为相应数量的设备分配唯一的IP地址。对于那些没有连接网络的独立网络中的主机, 只要保证在这个网络内地址唯一, 可以不用考虑互联网即可配置相应的IP地址。不过让每个独立的网络各自随意配置IP地址也会出现问题(冲突)。于是乎出现了私有的网络IP地址: 包含在这个范围内的IP地址都属于私有IP, 在此之外的IP地址称为全局IP。 私有IP最早没有计划连接互联网, 只用于互联网之外的独立网络。随着NAT/NAPT(能够互换私有IP和全局IP)技术的诞生, 配有私有地址的主机与配有全局地址的互联网主机实现了通信。 企业内部基本在每个终端上设置私有IP, 在路由器(宽带路由器)/服务器上设置全局IP, 配有私有IP地址的主机通过联网时, 通过NAT进行通信。私有IP地址结合NAT技术已成为现在解决IP地址分配问题的主流方案。 IPv4首部通过IP进行通信时, 需要在数据的前面加入IP首部的信息。IP首部中包含着用于IP协议进行发包控制时所有的必要信息。 版本(Version)由4比特构成, 表示标识IP首部的版本号, IPv4的版本号即为4, 因此在这个字段上的值也是”4”。 首部长度(IHL: Internet Header Length)由4比特构成, 表明IP首部的大小, 单位为4字节(32比特), 对于没有可选项的IP包, 首部长度则设置为”5”。 区分服务(TOS: Type Of Service)由8比特构成, 用来表明服务质量, 由于实现TOS控制极其复杂, TOS基本没有被投入使用。 总长度(Total Length)表示IP首部与数据部分合起来的总字节数。该字段长16比特。因此IP包的最大长度为65535字节。 标识(ID: Identification)由16比特构成, 用于分片重组。同一个分片的标识值相同, 不同分片的标识值不同。每发送一个IP包, 它的值也逐渐递增。如果ID相同, 但是目标地址、源地址或协议不同的话, 也会被认为是不同的分片。 标志(Flags)由3比特构成, 表示包被分片的相关信息。 比特 含义 0 未使用。目前必须为0 1 指示是否进行分片, 0:可以分片, 1:不能分片 2 包被分片的情况下, 表示是否为最后一个包, 0:最后一个分片的包, 1:分片中段的包 片偏移(FO: Fragment Offset)由13比特构成, 用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0。 生存时间(TTL: Time To Live)由8比特构成, 指可以中转多少个路由器的意思, 每经过一个路由器, TTL会减少1, 知道变成0则丢弃该包。为了避免IP包在网络内无限传递。 协议(Protocol)由8比特构成, 表示IP首部的下一个首部属于哪个协议。 首部和校验(Header Checksum)由16比特构成, 也叫IP首部校验和,主要用来确保IP数据报不被破坏。该字段只校验数据报的首页, 不校验数据部分。校验和的计算过程, 首先要将该校验和的所有位置设置为0, 然后以16比特为单位划分IP首部, 并用1补数计算所有16位字的和。最后将所得到这个和的1补数赋给首部校验和字段。 源地址(Source Address)由32比特构成, 表示发送端IP地址。 目标地址(Destination Address)由32比特构成, 表示接收端IP地址。 可选项(Options)长度可变, 通常只在进行实验或诊断时使用。该字段包含如下几点信息: 安全级别, 源路径, 路径记录, 时间戳。 填充(Padding)也叫填补物, 在有可选项的情况下, 首部长度可能不是32比特的整数倍。为此, 通过向字段填充为0, 调整首部长度为32比特的整数倍。 数据(Data)存入数据。将IP上层协议的首部也作为数据进行处理。 路由控制发送数据包时使用的地址就是网络层的地址, 也就是IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址, 在发送过程中还需要类似”指明路由器或主机”的信息, 以便发往目标地址。保存这种信息的就是路由控制表。实现IP通信的主机和路由器都必须持有一张这样的表。路由控制表的形成方式有两种: 静态路由控制:管理员手动设置。 动态路由控制: 路由器与其他路由器相互交换信息时自动刷新。 IP地址与路由控制IP地址的网络地址部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址, 在发送IP包时, 首先要确定IP首部中的目标地址, 再从路由控制表中找到与该地址具有相同网络地址的记录, 根据该记录将IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同的网路地址记录, 就选择一个相同位数最多的地址。 默认路由如果一张路由表中包含所有的网络及其子网的信息, 将会造成浪费。这时, 默认路由是不错的选择, 默认路由指路由表中任何一个地址都能与之匹配。默认路由一般标记为0.0.0.0/0或default, 这里的0.0.0.0/0并不是指IP地址是0.0.0.0, 而是后的”/0”, 所以并没有标识IP地址。它只是为了避免人们误认为0.0.0.0是IP地址。有时默认路由也被标记为default, 在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。 主机路由“IP地址/32”也被称为主机路由。例如: 192.168.153.15/32就是一种主机路由。它的意思是整个IP地址的所有位都将会参与路由; 进行主机路由, 意味着要基于主机上网卡配置的IP地址本身(网络地址+ 主机地址), 而不是基于该地址的网络地址部分进行路由。 环回地址环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址局具有相同意义的是一个叫做localhost的主机名。使用这个IP或主机名时, 数据包不会流向网络。 路由控制表的聚合利用网络地址的比特分布可以有效地进行分层配置。对内可以有多个子网掩码, 对外呈现的也是同一个网络的地址。通过路由信息的聚合可以有效的减少路由表的条目。 能够缩小路由表的大小是它的最大优势。路由表越大, 管理它所需要的内存和CPU也就越多, 并且查找路由表的时间也会越长, 导致转发IP数据包的性能下降, 构建大规模、高性能网络需要尽可能消减路由表的大小。 路由聚合可以将已知的路由信息传送给周围其他的路由器, 以达到控制路由信息的目的。 IP分割/构成处理数据链路与MTU每种数据链路的最大传输单元(MTU)都不尽相同, IP属于数据链路的上一层, 必须不受限与不同的数据链路的MTU大小。 IP报文的分片与重组任何一台主机都有必要对IP分片进行相应的处理。分片往往在网络上遇见比较大的报文无法一下子发送出去的时候才会进行处理。 由于以太网的默认MTU是1500字节, 因此4342字节的IP数据报无法再一个帧当中发送完成。因此, 路由器将IP数据报划分成了3个分片进行发送。经过分片之后的IP数据报在被重组的时候, 只能有目标主机进行, 路由器只做分片, 但不会进行重组。 路径MTU发现分片机制有它的不足。首先, 路由器的处理负荷加重。随着时代的变迁, 计算机网络的物理传输速度不断上升。这些高速的链路, 对路由器和计算机网络提出了更高的要求。另一方面, 随着人们对网络安全的要求提高, 路由器需要做的其他处理也越来越多, 因此, 只要允许, 是不希望由路由器进行IP数据包的分片处理。 路径MTU: 指的是从发送端主机到接收端主机之间不需要分片时的最大MTU大小。也就是, 路径中存在的所有数据链路中最小的传输单元。 路径MTU发现: 从发送端主机按照MTU的大小, 提前将数据报分片后进行发送。进行路径MTU发现, 就可以避免在路由器上进行分片处理。也可以在TCP中发送更大的包。很多操作系统都已经实现了路径MTU发现的功能。 路径MTU发现的工作原理: 首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1。根据这个标志位, 途中的路由器即使遇到需要分片才能处理的大包, 也不会去分片, 而是将包丢弃。随后, 通过ICMP的不可达消息将数据链路上的MTU的值给发送端主机。获得ICMP通知的MTU值后, 发送端主机将它设置为当前MTU。发送端主机根据当前新设置的MTU对数据报进行分片处理。如此反复, 直到数据报被发送到目标主机后, 没有在收到任何ICMP的回馈, 这样就认为最后一次ICMP通知的MTU值是一个合适的MTU值。MTU值最少可以缓存10分钟, 在这10分钟内使用刚刚得到的MTU, 超过10分钟以后则重新根据链路上的MTU做一次路径MTU发现。 UDP TCP 参考: 图解TCP/IP","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"数据链路层(二)","slug":"数据链路层","date":"2015-12-12T16:00:00.000Z","updated":"2017-08-17T15:03:44.000Z","comments":true,"path":"2015/12/13/数据链路层/","link":"","permalink":"https://github.com/icoderRo/2015/12/13/数据链路层/","excerpt":"数据链路层数据链路, 指OSI参考模型中的数据链路层, 有时也指以太网、无线局域网等通信手段。 数据链路层的协议定义了通过通信媒介互连的设备之间的传输规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外, 各个设备之间有时也会通过交换机、网桥中继器等中转数据。 OSI参考模型中数据链路层的相关技术包括MAC寻址(物理寻址)、介质共享、环路检测、虚拟局域网(VLAN)等。数据链路的传输方式有 以太网、无线局域网(WLAN), 点对点协议(PPP)。 MAC地址MAC地址用于识别数据链路中互连的节点, 以太网或FDDI(光纤分布式数据接口)、无线LAN、蓝牙等设备根据相关规范使用MAC地址。 MAC地址长48比特, 在使用网卡的情况下, MAC地址一般都是会烧入ROM中。因此, 任何一个网卡的MAC地址都是唯一的。","text":"数据链路层数据链路, 指OSI参考模型中的数据链路层, 有时也指以太网、无线局域网等通信手段。 数据链路层的协议定义了通过通信媒介互连的设备之间的传输规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外, 各个设备之间有时也会通过交换机、网桥中继器等中转数据。 OSI参考模型中数据链路层的相关技术包括MAC寻址(物理寻址)、介质共享、环路检测、虚拟局域网(VLAN)等。数据链路的传输方式有 以太网、无线局域网(WLAN), 点对点协议(PPP)。 MAC地址MAC地址用于识别数据链路中互连的节点, 以太网或FDDI(光纤分布式数据接口)、无线LAN、蓝牙等设备根据相关规范使用MAC地址。 MAC地址长48比特, 在使用网卡的情况下, MAC地址一般都是会烧入ROM中。因此, 任何一个网卡的MAC地址都是唯一的。 MAC地址中3~24位表示厂商识别码, 每个NIC厂商都有特定唯一的识别数字, 25~48位是厂商内部为识别每个网卡二用, 可以保证全世界不会有相同的MAC地址的网卡IEEE802.3制定MAC地址规范时没有限定数据链路的类型, 即不论哪种数据链路的网络(以太网、FDDI、ATM、无线LAN、蓝牙等), 都不会有相同的MAC地址出现。 例如一台主机是启动多个虚拟机, 由虚拟软件自己设定MAC地址给多个虚拟网卡, 这就很难保证所生成的MAC地址是唯一的。实际上, 即使MAC地址相同, 只要不是同属于一个数据链路就不会出现问题。 根据MAC地址转发在使用同轴电缆的以太网等介质共享网络中, 同一时间只能有一台主机发送数据, 当连网的主机数量增加时, 通信性能会明显下降。若将集线器/集中器等设备以星型连接, 就出现了一款新的网络设备–交换集线器, 这是一种将非介质共享型网络中所使用的交换机用在以太网中的技术, 交换集线器也叫做以太网交换机。 以太网交换机就是持有多个端口的网桥。根据数据链路层中每个帧的目标MAC地址, 决定从哪个网络接口发送数据。所参考的, 用以记录发送接口的表叫做转发表。 转发表的内容不需要使用者在每个终端或交换机上手工设置, 而是可以自动生成。数据链路层的每个通过点在接到包时, 会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系一一记录到转发表。以某个MAC地址作为源地址的包由某一接口接收, 实质上可以理解为该MAC地址就是该接口的目标。因此也可以说, 以该MAC地址作为目标地址的包, 经由改接口送出即可。这一过程也叫自学过程。 由于MAC地址没有层次性, 转发表中的入口个数与整个数据链路中所有网络设备的数量有关。当设备数量增加时, 转发表也会随之变大, 检索转发表所用的时间也就越来越长。当连接多个终端时, 有必要将网络分成多个数据链路 交换机转发方式有两种, 一种叫存储转发, 另一种叫直通转发。 存储转发方式检查以太网数据帧末尾的FCS位后在进行转发, 可以避免发送被破坏的帧或噪声导致的错误帧。 直通转发方式中不需要将整个帧全部接收下来以后再进行转发, 只需要得知目标地址即可开始转发。所以, 具有延迟较短的优势, 但是缺少了校验, 所以会导致有可能发送错误的帧。 环路检测技术通过网桥连接网络时, 一旦出现环路该如何处理? 这与网络的拓扑结构(总线型、环型、星型、混合型)和所使用的网桥种类有直接关系。最坏的情况下, 数据帧会在环路中被一而再再而三地持续转发, 而一旦这种数据帧越积越多将会导致网络瘫痪。 解决网络中的环路问题。具体有生成树与源路由两种方式。 生成树每个网桥必须在1~10秒内互相交换BPDU包, 从而判断哪些端口使用, 哪些端口没有被使用, 以便消除环路。一旦发生故障, 则自动切换通信线路, 利用那些没有被使用的端口继续进行传输。 生成树方法有一个弊端, 就是在发生故障切换网络时需要几十秒的时间。为了解决这个问题, 可以利用RSTP的方法, 将发生问题时的恢复时间缩短到几秒以内。 源路由法源路由法最早由IBM提出, 已解决令牌环网络的问题, 该方式可以判断发送数据的源地址是通过哪个网桥实现传输的, 并将帧写入RIF, 网桥则根据这个RIF信息发送帧给目标地址。因此, 及时网桥中出现了环路, 数据帧也不会被反复转发。 VLAN在进行网络管理时候, 经常会遇到分散网络负载、变换部署网络设备的位置的情况; 因此, 有时候不得不修改网络的拓扑结构, 这也就意味着必须进行硬件线路的改造。然而, 如果采用带有VLAN技术的网桥, 就不用实际修改网络布线, 只需要修改网络的结构即可。VLAN技术附加到网桥/2层交换机上, 就可以切断所有VLAN之间的通信。相比于一般的网桥/2层交换机, VLAN可以过滤多余的包, 提高网络的承载效率。 数据链路 数据链路名称 介质传输速率 用途 以太网 10 Mbps~1000Gbps LAN、MAN 蓝牙 5.5Mbps~150Mbps LAN 光纤通道 133Mbps~4Gbps SAN FDDI 100Mbps LAN、MAN IEEE1394 100Mbps~800Mbps 面向家庭 HtPPI 800Mbps、1.6Gbps 两台计算机之间的连接 令牌环 4Mbps、16Mbps LAN ATM 25Mbps、155Mbps、622Mbps、2.4GHz LAN ~WAN 参考: 图解TCP/IP","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"TCP/IP协议分层模型(一)","slug":"TCP:IP协议分层模型","date":"2015-11-27T16:00:00.000Z","updated":"2017-08-17T15:04:13.000Z","comments":true,"path":"2015/11/28/TCP:IP协议分层模型/","link":"","permalink":"https://github.com/icoderRo/2015/11/28/TCP:IP协议分层模型/","excerpt":"TCP/IP协议分层模型TCP/IP是目前计算机网络中使用最为广泛的协议;下面介绍一下TCP/IP协议分层模型。 1.TCP/IP与OSI参考模型 物理层(硬件)物理层: 负责0、1比特流与电压的高低、灯的闪灭之间的呼唤。对应TCP/IP分层模型中的硬件层;这种硬件相当于以太网或电话线路等物理设备。 数据链路层(网卡层)网络接口层利用以太网中的数据链路层进行通信, 属于接口层。也就是说, 把它当做是让网卡(NIC)起作用的驱动程序; 驱动程序是在操作系统与硬件之间起桥梁作用的软件,也就是说, 想要使用这些硬件, 需要安装对应的驱动软件。 现在很多计算机的操作系统中已经内置安装好了对应的网卡驱动程序, 可以实现即插即拔。","text":"TCP/IP协议分层模型TCP/IP是目前计算机网络中使用最为广泛的协议;下面介绍一下TCP/IP协议分层模型。 1.TCP/IP与OSI参考模型 物理层(硬件)物理层: 负责0、1比特流与电压的高低、灯的闪灭之间的呼唤。对应TCP/IP分层模型中的硬件层;这种硬件相当于以太网或电话线路等物理设备。 数据链路层(网卡层)网络接口层利用以太网中的数据链路层进行通信, 属于接口层。也就是说, 把它当做是让网卡(NIC)起作用的驱动程序; 驱动程序是在操作系统与硬件之间起桥梁作用的软件,也就是说, 想要使用这些硬件, 需要安装对应的驱动软件。 现在很多计算机的操作系统中已经内置安装好了对应的网卡驱动程序, 可以实现即插即拔。 网络层(互联网层)网络层使用IP协议, IP协议基于IP地址转发分包数据。就是将分组数据包发送到目的主机, 通过互联网层, 可以抽象甚至忽略网络结构的细节(忽略更底层的网络结构)。连接互联网的所有主机跟路由器都必须实现IP的功能; 网桥、中继器、集线器不一定要实现TCP/TP功能。 IP是跨越网络来传送数据包, 使整个互联网都能收到数据的协议; IP协议使用IP地址作为主机的标识。通过IP, 相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信, 它不具备重发的机制(TCP控制重发), 属于非可靠性传输协议。 ICMP协议规定：目的主机必须返回ICMP回送应答消息(ACK)给发送主机。如果源主机在一定时间内收到应答，则认为主机可达。(ping 用的就是ICMP协议)。 ARP 从分组数据包中的IP地址中解析出MAC地址的一种协议。 传输层传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部通常运行着多个程序, 基于端口号区分哪些程序与哪些程序在进行通信,传输侧有两个代表性的协议TCP/UPD。 TCP 是一种面向有连接的可靠的传输层的协议。它可以保证两端主机的通信可达。TCP能够正确处理在传输过程中的丢包、传输顺序乱掉的异常的情况, 还能够有效的利用带宽, 缓解网络的拥堵。 UDP 是一种面向无连接的不可靠的传输层协议。UDP不会关注对端是否接收到了数据, 常用于多播、广播通信以及视频通信等多媒体领域(UDP + RTP/RTCP/RTMP) 应用层(会话层以上的分层)TCP/IP分层中, 将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。文件传输(FTP), 远程登录(TENNET/SSH), 网络管理(SNMP) 2.网络构成要素 网卡任一计算机联网时, 都必须要使用网卡(NIC)/LAN卡/网络适配器。很多计算机都内置了LAN端口, 说明计算机在出厂设置中就具备了以太网的端口。 中继器中继器(Repeater)是在物理层面上延长网络的设备。由电缆传过来的电信号/光信号经由中继器的波形调整和放大再传给另一个电缆。 通过中继器而进行的网络延长, 其距离也并非可以无限扩大; 例如一个10Mbps的以太网最多可以用4个中继器分段连接, 而一个100Mbps的以太网则对多只能连接两个中继器。 有些中继器可以提供多个端口服务, 这种中继器被称为中继集线器/集线器/Hub。因此, 集线器也可以看作是多个中继器, 每个端口都可以成为一个中继器。 网桥/2层交换机网桥能够识别数据链路中的数据帧, 并将这些数据帧临时存储于内存, 再重新生成信号作为一个全新的帧转发给相连的另一个网段, 由于能够存储这些数据帧, 网桥能够连接传输速率完全不同的数据链路, 并且不限制连接网段的个数。数据链路的数据帧中有一个数据位叫做FCS, 用以校验数据是否正确送到目的地。网桥通过检查这个域中的值, 将那些损坏的数据丢弃, 从而避免发送给其他网段。 以太网中使用的交换集线器, 基本也属于网桥的一种, 交换集线器中连接电缆的每个端口都能提供类似网桥的功能。 路由器/3层交换机路由器是在网络层面上连接两个网络、并对分组数据报文进行转发的设备。网桥是根据MAC地址进行处理, 而路由器/3层交换机则是根据IP地址进行处理的。因此, TCP/IP中网络层的地址就成为了IP地址。 路由器可以连接不同的数据链路。例如连接两个以太网, 或者连接一个以太网与一个FDDI。家/办公室使用的宽带路由器也是路由器的一种。路由器还有分担网络负责的作用, 甚至具有网络安全的功能。 4~7层交换机4~7层交换机负责处理从传输层到应用层的数据。以TCP等协议的传输层及其上面的应用层为基础, 分析收发数据, 并对其进行特定的处理。4~7层交换机的可以进行带宽控制, 优先处理对实时性要求较高的通信请求, 放缓处理像邮件或数据转发等稍有延迟也并无大碍的通信请求。负载均衡器、广域网加速器、防火墙等都是是4~7层交换机的一中。 网关网关负责处理传输层到应用层的数据进行转换和转发的设备。与4~7层交换机一样都是处理传输层及以上的数据, 但是网关不仅转发数据还负责对数据进行转换,通常会使用一个表示层或应用层网关, 在两个不能直接进行通信的协议之间进行翻译, 实现两端的通信。 代理服务器可以控制网络流量和安全, 属于网关的一种 参考: 图解TCP/IP","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/icoderRo/tags/网络/"}]},{"title":"谁动了我的奶酪","slug":"谁动了我的奶酪","date":"2015-11-22T16:00:00.000Z","updated":"2017-08-17T15:04:37.000Z","comments":true,"path":"2015/11/23/谁动了我的奶酪/","link":"","permalink":"https://github.com/icoderRo/2015/11/23/谁动了我的奶酪/","excerpt":"简言临出发,想起老大赠送的一本书,《谁动了我的奶酪》, 于是乎悄然翻起了这本书…","text":"简言临出发,想起老大赠送的一本书,《谁动了我的奶酪》, 于是乎悄然翻起了这本书… 简述《谁动了我的奶酪》写的是个可爱的寓言故事,每页都配有主人翁滑稽可爱个性鲜明的漫画形象。书中主要讲述4个“人物”：两只小老鼠“嗅嗅”、“匆匆”和两个小矮人“哼哼”、“唧唧”。他们生活在一个迷宫里,奶酪是他们要追寻的东西。有一天,他们同时发现了一个储量丰富的奶酪仓库,便在其周围构筑起自己的幸福生活。很久之后的某天,奶酪突然不见了！这个突如其来的变化使他们的心态暴露无疑：嗅嗅,匆匆随变化而动,立刻穿上始终挂在脖子上的鞋子,开始出去再寻找,并很快就找到了更新鲜更丰富的奶酪；两个小矮人哼哼和唧唧面对变化却犹豫不决,烦恼丛生,始终无法接受奶酪已经消失的残酷现实.经过激烈的思想斗争,唧唧终于冲破了思想的束缚,穿上久置不用的跑鞋,重新进入漆黑的迷宫,并最终找到了更多更好的奶酪,而哼哼却仍在对苍天的追问中郁郁寡欢…… 留言墙在这本书中，有很多的至理名言，也有很多发人深思的地方，把他们摘抄下来，时常警醒懒惰的自己： 如果不改变，就会被淘汰 经常闻闻你的奶酪，你就会知道它什么时候开始变质 当你客服了自己的恐惧时，你就会感到轻松自在 在发现奶酪之前，想象正在享受奶酪，会帮自己找到新的奶酪 越早放弃旧的奶酪，就越早发现新的奶酪 在迷宫中搜索比停留在没有奶酪的地方更安全 抛弃旧的观念, 才能找到新的奶酪 只要相信自己能够找到并且享用新的奶酪,你就会改变自己的行为 及早注意细小的变化，这会有助于你适应即将来临的大变化 小悟当我们在为自己的事业,生活做出选择时,必须充分地热爱自己喜欢干的事,热爱才会努力去钻研,努力钻研必会有作为;选择自己有能力干的事,选择一经确定,就要弃而不舍地去奋斗,从一点一滴做起,从最小的事做起,努力做到最好,在这个过程中增长才干,树立信心。久而久之,必定会有所作为,有所发展,有所创造！ 我们要记住：别人仍会不断地拿走你的“奶酪”，所以我们要做好迅速改变的准备，不断地去适应变化、享受变化。 《谁动了我的奶酪》告诉我一个最简单的应对方法,那就是把跑鞋挂在脖子上,时刻准备穿上它,在千变万化的世界里奔跑追寻,去追寻其他更新鲜的奶酪……","categories":[{"name":"阅读","slug":"阅读","permalink":"https://github.com/icoderRo/categories/阅读/"}],"tags":[{"name":"寓言故事","slug":"寓言故事","permalink":"https://github.com/icoderRo/tags/寓言故事/"}]},{"title":"3D轮播图","slug":"3D轮播图","date":"2015-09-23T16:00:00.000Z","updated":"2017-08-17T14:52:17.000Z","comments":true,"path":"2015/09/24/3D轮播图/","link":"","permalink":"https://github.com/icoderRo/2015/09/24/3D轮播图/","excerpt":"简介在开发一些项目的首页,或者需要信息展示类界面的时候,往往需要用到轮播图效果. 常见的轮播图都是以2D的形式, 平面展示, 对于3D旋转的的轮播图, 又应该如何实现. 思路 2D轮播图 一种是利用collectionView实现无限滚动,因为collectionView本身存在着复用的问题,所以不用担心内存的消耗问题. 另外一种就是基于scrollView来实现, 比如我们现在有5张图片.最简单的就是我们直接创建5+2个，也就是7个imageView.而我们的存放顺序为，图片5，图片1、图片2、图片3、图片4、图片5、图片1。默认显示第2张（图片1,一直向右滑动到第6张（图片5),再向右滑动显示第7张（图片1）显示完成后,将UIScrollView的contentOffset设置到第2个imageView上（图片1,这时候便可继续向右滑动实现循环的效果;同理，向左滑动时,滑动到第1张（图片5）后,将UIScrollView的contentOffset设置到第6个imageView上（图片5),这样便可以继续向左滑动实现循环效果. 3D轮播图 首先, 3D翻转效果, 我们会想到可能会与动画相关, 这种轮播图的切换有点类似转场动画(CATransition), 我们去查一下CATransition相关资料, 发现其type有一个cube属性有3D翻滚的效果.接下来, 直接上代码看看.","text":"简介在开发一些项目的首页,或者需要信息展示类界面的时候,往往需要用到轮播图效果. 常见的轮播图都是以2D的形式, 平面展示, 对于3D旋转的的轮播图, 又应该如何实现. 思路 2D轮播图 一种是利用collectionView实现无限滚动,因为collectionView本身存在着复用的问题,所以不用担心内存的消耗问题. 另外一种就是基于scrollView来实现, 比如我们现在有5张图片.最简单的就是我们直接创建5+2个，也就是7个imageView.而我们的存放顺序为，图片5，图片1、图片2、图片3、图片4、图片5、图片1。默认显示第2张（图片1,一直向右滑动到第6张（图片5),再向右滑动显示第7张（图片1）显示完成后,将UIScrollView的contentOffset设置到第2个imageView上（图片1,这时候便可继续向右滑动实现循环的效果;同理，向左滑动时,滑动到第1张（图片5）后,将UIScrollView的contentOffset设置到第6个imageView上（图片5),这样便可以继续向左滑动实现循环效果. 3D轮播图 首先, 3D翻转效果, 我们会想到可能会与动画相关, 这种轮播图的切换有点类似转场动画(CATransition), 我们去查一下CATransition相关资料, 发现其type有一个cube属性有3D翻滚的效果.接下来, 直接上代码看看. 上代码 创建一个imageView, 用来装载图片, 实现图片的3D翻转, 就是给当前这个imageView添加3D动画后.在将里面的image给替换. 123456789101112- (UIImageView *)imageV&#123; if (!_imageV) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, Width, Height)]; imageView.backgroundColor = [UIColor lightGrayColor]; imageView.userInteractionEnabled = YES; _imageV = imageView; [self addSubview:_imageV]; &#125; return _imageV;&#125; 设置imageView的默认图片为第一张图, 并给当前视图添加向左和向右轻扫的手势. 12345678910self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; UISwipeGestureRecognizer *rightRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromRight)];[rightRe setDirection:UISwipeGestureRecognizerDirectionLeft]; UISwipeGestureRecognizer *leftRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromLeft)];[leftRe setDirection:UISwipeGestureRecognizerDirectionRight]; [self.imageV addGestureRecognizer:rightRe];[self.imageV addGestureRecognizer:leftRe]; 添加pageControl, 用以显示当前图片的index 12345678910111213141516- (UIPageControl *)pageControl&#123; if (!_pageControl) &#123; UIPageControl *pageControl = [[UIPageControl alloc] init]; pageControl.numberOfPages = self.imagArr.count; CGSize size = [pageControl sizeForNumberOfPages:self.imagArr.count]; pageControl.frame = CGRectMake(0, 0, size.width, size.height); pageControl.center = CGPointMake(self.center.x, Height-10); pageControl.currentPageIndicatorTintColor = [UIColor whiteColor]; pageControl.pageIndicatorTintColor = [UIColor grayColor]; _pageControl = pageControl; [self addSubview:_pageControl]; &#125; return _pageControl;&#125; 添加定时器, 让imageView按照一定的节奏, 自动轮播. 123456789- (NSTimer *)timer&#123; if (!_timer) &#123; _timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(swipFromRight) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes]; &#125; return _timer;&#125; NSRunLoopCommonModes: 不受当前线程的影响. 实现监听方法 1234567891011121314151617181920212223242526272829303132- (void)swipFromRight&#123; self.currentPage++; if (self.currentPage &gt;= self.imagArr.count) self.currentPage = 0; self.pageControl.currentPage = self.currentPage; self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; CATransition *transition = [[CATransition alloc] init]; transition.type = @&quot;cube&quot;; transition.subtype = kCATransitionFromRight; transition.duration = 1.5; transition.delegate = self; [self.imageV.layer addAnimation:transition forKey:nil]; &#125;- (void)swipFromLeft&#123; self.currentPage--; if (self.currentPage &lt; 0) self.currentPage = self.imagArr.count -1; self.pageControl.currentPage = self.currentPage; self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; CATransition *transition2 = [[CATransition alloc] init]; transition2.type = @&quot;cube&quot;; transition2.subtype = kCATransitionFromLeft; transition2.duration = 1.5; transition2.delegate = self; [self.imageV.layer addAnimation:transition2 forKey:nil];&#125; 核心动画, 都是添加到视图的layer上. 这样之后, 还会有问题, 例如:3秒切换一张图片, 当2.9秒的时候, 手动切换了新的图片, 在0.1秒后, 定时器又会帮我们自动切换一张新的图片. 我们想做到, 当手动切换图片后, 仍然需要等待3秒, 定时器才会自动切换下一张图片.我们监听CAAnimationDelegate方法:animationDidStart: 和animationDidStop: CAAnimation在分类中定义了代理方法,是给NSObject添加的分类,所以任何对象,成为CAAnimation的代理,都可以。 动画开始时候调用animationDidStart:, 禁用交互 123456789- (void)animationDidStart:(CAAnimation *)anim&#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; &#125; self.imageV.userInteractionEnabled = NO;&#125; 动画停止的时候调用animationDidStop:, 开启交互, 重置timer 1234567891011- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; [self timer]; &#125; self.imageV.userInteractionEnabled = YES;&#125; 从外部传入需要浏览的图片数组, 设置frame即可. 12LCBannerView *banerV = [[LCBannerView alloc] initWithFrame:CGRectMake(0, 64, self.view.bounds.size.width, 180) imageArray:@[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]];[self.view addSubview:banerV]; 源码12345#import &lt;UIKit/UIKit.h&gt;@interface LCBannerView : UIView- (instancetype)initWithFrame:(CGRect)frame imageArray:(NSArray *)imageArray;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#import &quot;LCBannerView.h&quot;#define Width self.frame.size.width#define Height self.frame.size.height@interface LCBannerView ()@property (nonatomic, weak) UIImageView *imageV;@property (nonatomic, strong) NSArray *imagArr;@property (nonatomic, weak) UIPageControl *pageControl;@property (nonatomic, assign) NSInteger currentPage;@property (nonatomic, strong) NSTimer *timer;@end@implementation LCBannerView#pragma mark -lazy- (UIImageView *)imageV&#123; if (!_imageV) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, Width, Height)]; imageView.backgroundColor = [UIColor lightGrayColor]; imageView.userInteractionEnabled = YES; _imageV = imageView; [self addSubview:_imageV]; &#125; return _imageV;&#125;- (NSTimer *)timer&#123; if (!_timer) &#123; _timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(swipFromRight) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes]; &#125; return _timer;&#125;- (UIPageControl *)pageControl&#123; if (!_pageControl) &#123; UIPageControl *pageControl = [[UIPageControl alloc] init]; pageControl.numberOfPages = self.imagArr.count; CGSize size = [pageControl sizeForNumberOfPages:self.imagArr.count]; pageControl.frame = CGRectMake(0, 0, size.width, size.height); pageControl.center = CGPointMake(self.center.x, Height-10); pageControl.currentPageIndicatorTintColor = [UIColor whiteColor]; pageControl.pageIndicatorTintColor = [UIColor grayColor]; _pageControl = pageControl; [self addSubview:_pageControl]; &#125; return _pageControl;&#125;#pragma mark -lifeCycle- (instancetype)initWithFrame:(CGRect)frame imageArray:(NSArray *)imageArray&#123; if (self = [super initWithFrame:frame]) &#123; self.currentPage = 0; self.imagArr = imageArray; self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; UISwipeGestureRecognizer *rightRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromRight)]; [rightRe setDirection:UISwipeGestureRecognizerDirectionLeft]; UISwipeGestureRecognizer *leftRe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipFromLeft)]; [leftRe setDirection:UISwipeGestureRecognizerDirectionRight]; [self.imageV addGestureRecognizer:rightRe]; [self.imageV addGestureRecognizer:leftRe]; [self timer]; [self pageControl]; &#125; return self;&#125;- (void)swipFromRight&#123; self.currentPage++; if (self.currentPage &gt;= self.imagArr.count) self.currentPage = 0; self.pageControl.currentPage = self.currentPage; self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; CATransition *transition = [[CATransition alloc] init]; transition.type = @&quot;cube&quot;; transition.subtype = kCATransitionFromRight; transition.duration = 1.5; transition.delegate = self; [self.imageV.layer addAnimation:transition forKey:nil]; &#125;- (void)swipFromLeft&#123; self.currentPage--; if (self.currentPage &lt; 0) self.currentPage = self.imagArr.count -1; self.pageControl.currentPage = self.currentPage; self.imageV.image = [UIImage imageNamed:self.imagArr[self.currentPage]]; CATransition *transition2 = [[CATransition alloc] init]; transition2.type = @&quot;cube&quot;; transition2.subtype = kCATransitionFromLeft; transition2.duration = 1.5; transition2.delegate = self; [self.imageV.layer addAnimation:transition2 forKey:nil];&#125;#pragma mark -CAAnimationDelegate- (void)animationDidStart:(CAAnimation *)anim&#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; &#125; self.imageV.userInteractionEnabled = NO;&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; [self timer]; &#125; self.imageV.userInteractionEnabled = YES;&#125;@end 可以提供更多的属性和方式,例如:利用KVC可以设置currentPageIndicatorTintColor为图片等. 可以提供网络图片,和监听imageView的点击.可以将”cube”替换成”fade”效果等等,有需要的看官可以自行封装.代码不多, demo就不发了.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"animation","slug":"animation","permalink":"https://github.com/icoderRo/tags/animation/"}]},{"title":"封装 tabBar","slug":"封装tabBar","date":"2015-07-09T16:00:00.000Z","updated":"2017-08-17T14:54:03.000Z","comments":true,"path":"2015/07/10/封装tabBar/","link":"","permalink":"https://github.com/icoderRo/2015/07/10/封装tabBar/","excerpt":"自定义TabBarController123自定义继承于UITabBarController利用KVC 替换系统的tabBar利用appearance 全局统一设置UITabBarItem 1[self setValue:[[LCTabBar alloc] init] forKeyPath:@\"tabBar\"]; 123456789NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary]; normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor]; normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:12]; NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary]; selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor]; UITabBarItem *item = [UITabBarItem appearance]; [item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal]; [item setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];","text":"自定义TabBarController123自定义继承于UITabBarController利用KVC 替换系统的tabBar利用appearance 全局统一设置UITabBarItem 1[self setValue:[[LCTabBar alloc] init] forKeyPath:@\"tabBar\"]; 123456789NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary]; normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor]; normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:12]; NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary]; selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor]; UITabBarItem *item = [UITabBarItem appearance]; [item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal]; [item setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected]; 自定义tabBar123自定义继承于UITabBar初始化布局 中间有线条的tabBar 解决方案: 布局子控件地方, 将中间按钮 bringSubviewToFront 123456789101112131415161718192021222324252627282930313233- (void)layoutSubviews&#123; [super layoutSubviews]; CGFloat width = self.width; CGFloat height = self.height; self.plusButton.center = CGPointMake(width * 0.5, height * 0.5); self.plusButton.y = -20; int index = 0; CGFloat tabBarButtonW = width / 5; CGFloat tabBarButtonH = height; CGFloat tabBarButtonY = 0; for (UIView *tabBarButton in self.subviews) &#123; if (![NSStringFromClass(tabBarButton.class) isEqualToString:@\"UITabBarButton\"]) continue; CGFloat tabBarButtonX = index * tabBarButtonW; if (index &gt;= 2) &#123; tabBarButtonX += tabBarButtonW; &#125; tabBarButton.frame = CGRectMake(tabBarButtonX, tabBarButtonY, tabBarButtonW, tabBarButtonH); index++; &#125; [self bringSubviewToFront:self.plusButton];&#125; 中间按钮 超出tabBar的范围不能响应点击事件 解决方案: 重写系统的hitTest方法, 不了解的看官可以去查查事件传递和响应者链条 1234567891011121314151617- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; if (self.isHidden == NO) &#123; // 当前界面 tabBar显示 CGPoint newPoint = [self convertPoint:point toView:self.plusButton]; if ( [self.plusButton pointInside:newPoint withEvent:event]) &#123; // 点 属于按钮范围 return self.plusButton; &#125;else&#123; return [super hitTest:point withEvent:event]; &#125; &#125; else &#123; return [super hitTest:point withEvent:event]; &#125;&#125; 当然也可以去除tabBar上的线条 , 设置ShadowImage属性, 导航栏同理[self.tabBarController.tabBar setBackgroundImage:[UIImage new]];[self.tabBarController.tabBar setShadowImage:[UIImage new]];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[]},{"title":"runloop理论","slug":"runloop浅说","date":"2015-05-04T16:00:00.000Z","updated":"2017-08-17T15:05:14.000Z","comments":true,"path":"2015/05/05/runloop浅说/","link":"","permalink":"https://github.com/icoderRo/2015/05/05/runloop浅说/","excerpt":"RunLoop基本概念概念:程序的运行循环,通俗的来说就是跑圈. 基本作用（作用重大） 保持程序的持续运行(ios程序为什么能一直活着不会死) 处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 节省CPU资源，提高程序性能，有事情就做事情，没事情就休息 重要说明 如果没有Runloop,那么程序一启动就会退出，什么事情都做不了。 如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行 main函数中的Runloop 在UIApplication函数内部就启动了一个Runloop,该函数返回一个int类型的值 这个默认启动的Runloop是跟主线程相关联的 Runloop对象 在iOS开发中有两套api来访问Runloop 第一种:foundation框架【NSRunloop】 第二种:core foundation框架【CFRunloopRef】 NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面） Runloop与线程 Runloop和线程的关系：一个Runloop对应着一条唯一的线程 如何让子线程不死 给这条子线程开启一个Runloop Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 Runloop的生命周期：在第一次获取时创建，在线程结束时销毁 拿到当前应用程序的主Runloop（主线程对应的Runloop） 方法一: NSRunloop NSRunLoop * runloop1 = [NSRunLoop mainRunLoop]; 方法二: CFRunLoopRef1CFRunLoopRef runloop2 = CFRunLoopGetMain(); 注意：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。","text":"RunLoop基本概念概念:程序的运行循环,通俗的来说就是跑圈. 基本作用（作用重大） 保持程序的持续运行(ios程序为什么能一直活着不会死) 处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 节省CPU资源，提高程序性能，有事情就做事情，没事情就休息 重要说明 如果没有Runloop,那么程序一启动就会退出，什么事情都做不了。 如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行 main函数中的Runloop 在UIApplication函数内部就启动了一个Runloop,该函数返回一个int类型的值 这个默认启动的Runloop是跟主线程相关联的 Runloop对象 在iOS开发中有两套api来访问Runloop 第一种:foundation框架【NSRunloop】 第二种:core foundation框架【CFRunloopRef】 NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面） Runloop与线程 Runloop和线程的关系：一个Runloop对应着一条唯一的线程 如何让子线程不死 给这条子线程开启一个Runloop Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 Runloop的生命周期：在第一次获取时创建，在线程结束时销毁 拿到当前应用程序的主Runloop（主线程对应的Runloop） 方法一: NSRunloop NSRunLoop * runloop1 = [NSRunLoop mainRunLoop]; 方法二: CFRunLoopRef1CFRunLoopRef runloop2 = CFRunLoopGetMain(); 注意：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。 Runloop运行原理 苹果官方的运行原理图 Runloop和相关类之间的关系图 RunLoop五个相关的类 CFRunloopRef CFRunloopModeRef【Runloop的运行模式】 CFRunloopSourceRef【Runloop要处理的事件源】 CFRunloopTimerRef【Timer事件】 CFRunloopObserverRef【Runloop的观察者（监听者）】 CFRunloopRef CFRunloopModeRef代表着Runloop的运行模式 一个Runloop中可以有多个mode,一个mode里面又可以有多个 source/observer/timer等等 每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode 如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入 这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响 系统默认注册了5个mode 第一种模式: kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 第二种模式: UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 第三种模式: UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 第四种模式: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 第五种模式: kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode CFRunloopTimerRef runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就不会参与。一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。 它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer . NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，和runloop的运行模式kCFRunLoopDefaultMode有时候需要修改模式,达到类似在后台持续运行的效果,不受外界的影响 12NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; CFRunloopSourceRef 事件源也就是输入源，有两种分类模式； 一种是按照苹果官方文档进行划分的 另一种是基于函数的调用栈来进行划分的（source0和source1）。 苹果官方文档 Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources 函数的调用栈 Source0：非基于Port的 Source1：基于Port的 CFRunLoopObserverRef CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 12345//创建一个runloop监听者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; NSLog(@”监听runloop状态改变—%zd”,activity); &#125;); //为runloop添加一个监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); 监听的状态 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Runloop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Sources kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloop kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变 &#125;; RunLoop运行逻辑 一个线程对应一个runLoop,主线程的runloop是程序一启动,默认就创建一个runloop,创建好了之后就会给它添加一些默认的模式,每个模式里面会有很多的 source /timer/observer ,添加好这些模式后,observer就会监听主线程的runloop,进入runloop后,就开始处理事件,先处理timer,再处理source0,source0处理完之后再处理source1,当把这些所有的事件反复的处理完之后,如果没有事件了,那么runloop就会进入睡眠状态,当用户又触发了新的事件,就会唤醒runloop,唤醒runloop后回到第二步,重新处理新的timer,新的source0,新的source1,处理完后就睡眠,一直反复,当我们把程序关闭或者强退,这个时候observer就会监听都runloop退出了. observer是监听runloop的状态. timer / source/CFRunLoopRef创建一个timer必须添加到runloop 才会执行,添加的时候要指定模式 default模式 ,不对程序做任何操作 timer就会后台运行 ,当我进行操作的时候runloop模式就会从默认模式切换到其他模式,假如说我操作scrollerView 它就会从default模式切换到tracking模式而roonloop 同一时刻只能执行一种模式.当在创建timer时指定 Comment 仅仅是个标记,默认和追踪,那么timer就会随着触发的模式不同进行 默认和追踪模式的选择 Sourcesource一般是不会去操作的,第一种是基于自定义的,第二种是基于端口的,第三种是基于Performselect的通过函数调用栈来对source分类:分为source0 source1 :(1)source0是非基于端口的,是用户自己手动触发的操作,比如触摸滑动等操作.(2)Source1是系统内部的一些端口触发的事件(3)子线程的runloop需要手动创建,需要手动开启 自动释放池第一次创建:是在runloop进入的时候创建 对应的状态 = KCFRunLoopEntry最后一个退出,是在runloop退出的时候 对应的状态 = KCFRunLoopExit 其他的创建和释放即将进入睡眠的时候,先释放上一次创建的自动释放池,然后再创建一个新的释放池","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"runloop","slug":"runloop","permalink":"https://github.com/icoderRo/tags/runloop/"}]},{"title":"转场动画 - UIPresentationController","slug":"转场动画1","date":"2015-03-19T16:00:00.000Z","updated":"2017-08-17T14:55:51.000Z","comments":true,"path":"2015/03/20/转场动画1/","link":"","permalink":"https://github.com/icoderRo/2015/03/20/转场动画1/","excerpt":"简介一些设计良好的转场动画, 不仅仅能起到炫酷美观的作用还能极大的引导用户.在iOS8中, 苹果给我们带来了一个新的类UIPresentationController, 里面的代码不多, 提供了4个方法参与转场, 从而实现对转场过程的细致控制: 1234567891011//在prsent转场即将开始的时候被调用的- (void)presentationTransitionWillBegin;//在prsent转场结束时被调用的- (void)presentationTransitionDidEnd:(BOOL)completed;//在dismiss转场即将开始的时候被调用的- (void)dismissalTransitionWillBegin;//在dismiss转场结束时被调用的- (void)dismissalTransitionDidEnd:(BOOL)completed; 简述协议UIViewControllerTransitioningDelegate自定义转场的第一步便是提供转场代理,告诉系统使用我们提供的代理而不是系统的默认代理来执行转场.暂时不使用手势相关的操作.算下来,就只有三个方法了. presentationControllerForPresentedViewController:.. 此方法提供一个UIPresentationController, 这个控制器我们可以参考UIPopoverPresentationController的方式, 自定义一个继承于UIPresentationController的控制器. animationControllerForPresentedController: 提供在presenting时候的转场动画 animationControllerForDismissedController: 提供在dismiss时候的转场动画","text":"简介一些设计良好的转场动画, 不仅仅能起到炫酷美观的作用还能极大的引导用户.在iOS8中, 苹果给我们带来了一个新的类UIPresentationController, 里面的代码不多, 提供了4个方法参与转场, 从而实现对转场过程的细致控制: 1234567891011//在prsent转场即将开始的时候被调用的- (void)presentationTransitionWillBegin;//在prsent转场结束时被调用的- (void)presentationTransitionDidEnd:(BOOL)completed;//在dismiss转场即将开始的时候被调用的- (void)dismissalTransitionWillBegin;//在dismiss转场结束时被调用的- (void)dismissalTransitionDidEnd:(BOOL)completed; 简述协议UIViewControllerTransitioningDelegate自定义转场的第一步便是提供转场代理,告诉系统使用我们提供的代理而不是系统的默认代理来执行转场.暂时不使用手势相关的操作.算下来,就只有三个方法了. presentationControllerForPresentedViewController:.. 此方法提供一个UIPresentationController, 这个控制器我们可以参考UIPopoverPresentationController的方式, 自定义一个继承于UIPresentationController的控制器. animationControllerForPresentedController: 提供在presenting时候的转场动画 animationControllerForDismissedController: 提供在dismiss时候的转场动画 UIViewControllerAnimatedTransitioning两个必须实现的方法, 和一个可选方法 transitionDuration: 转场动画时间 animateTransition: 转场时, 相对应的view做何变化. animationEnded: 动画结束时, 调用 UIViewControllerContextTransitioning提供转场中需要的数据,遵守协议,\b 可以获取presentedView和presentingView, containerView等等。 几个常用的属性 viewControllerForKey: 和 viewForKey: 获取相应的控制器和view finalFrameForViewController: 和 initialFrameForViewController: 获取对应视图的frame transitionDuration: 获取转场动画时间 UIViewControllerTransitionCoordinator在转场动画发生的时,并行执行其他自定义的动画,起到协调和辅助的作用,主要在 Modal 转场和交互转场取消时使用,遵守协议. animateAlongsideTransition:completion: 与动画控制器中的转场动画同步，执行其他动画 animateAlongsideTransitionInView:animation:completion: 与动画控制器中的转场动画同步，在指定的视图内执行动画 demo演示创建fromVC和toVCtoVC需要设置modalPresentationStyle为自定义模式UIModalPresentationCustom,为代理UIViewControllerTransitioningDelegate, 实现代理中的方法: 12345678910111213141516#pragma mark - UIViewControllerTransitioningDelegate- (UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source&#123; return [[LCPresentationController alloc] initWithPresentedViewController:presented presentingViewController:presenting];&#125;- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source&#123; return [LCPresentAnimation new];&#125;- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed&#123; return [LCDismissAnimation new];&#125; 根据代理方法中的提示, 创建对应的控制器. 创建UIPresentationController可以参考UIPopoverPresentationController的方式, 自定义一个继承于UIPresentationController的控制器.并实现对应的方法: present转场即将开始转场即将开始的时候, 我们给containerView添加一个背景图.并设置透明度为0;利用animateAlongsideTransition:completion:并行处理 12345678910- (void)presentationTransitionWillBegin&#123; self.bgView.alpha = 0.0; self.transitionCoordinator = self.presentingViewController.transitionCoordinator; [self.transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; self.bgView.alpha = 0.7; self.presentingViewController.view.transform = CGAffineTransformScale(self.presentingViewController.view.transform, 0.9, 0.9); self.presentingViewController.view.layer.cornerRadius = 8.0; &#125; completion:nil];&#125; prsent转场结束 转场停止的时候,如果未完成转场, 则将背景视图从父控件移除 123456- (void)presentationTransitionDidEnd:(BOOL)completed&#123; if (!completed) &#123; [self.bgView removeFromSuperview]; &#125;&#125; dismiss转场即将开始同理利用animateAlongsideTransition:completion:并行处理, 将视图复原 123456789- (void)dismissalTransitionWillBegin&#123; self.transitionCoordinator = self.presentingViewController.transitionCoordinator; [self.transitionCoordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; context) &#123; self.bgView.alpha = 0; self.presentingViewController.view.transform = CGAffineTransformIdentity; self.presentingViewController.view.layer.cornerRadius = 1.0; &#125; completion:nil];&#125; dismiss转场结束如果dismiss转场成功, 则将背景视图移除. 123456- (void)dismissalTransitionDidEnd:(BOOL)completed&#123; if (completed) &#123; [self.bgView removeFromSuperview]; &#125;&#125; frameOfPresentedViewInContainerView 返回presentedView的frame 创建presetAnimation创建一个类, 遵守UIViewControllerAnimatedTransitioning, 实现方法即可 12345678910111213141516171819202122232425262728- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; return 0.7f;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; CGRect finalFrame = [transitionContext finalFrameForViewController:toVC]; toView.frame = CGRectOffset(finalFrame, 0, finalFrame.size.height); UIView *containerView = [transitionContext containerView]; [containerView addSubview:toVC.view]; NSTimeInterval duration = [self transitionDuration:transitionContext]; [UIView animateWithDuration:duration delay:0.0f usingSpringWithDamping:0.7f initialSpringVelocity:0.0 options:UIViewAnimationOptionCurveLinear animations:^&#123; toView.frame = finalFrame; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; &#125; &#125;];&#125; 不外乎就是, 获取控制器和视图, 初始化frame,执行动画修改frame; 创建dismissAnimation同理创建一个类, 遵守UIViewControllerAnimatedTransitioning, 实现方法 12345678910111213141516171819202122- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; return 0.3f;&#125;- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; CGRect initFrame = [transitionContext initialFrameForViewController:fromVC]; CGRect finalFrame = CGRectOffset(initFrame, 0, initFrame.size.height); [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 options:UIViewAnimationOptionCurveLinear animations:^&#123; fromVC.view.frame = finalFrame; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; &#125; &#125;];&#125; 坑点: 在modal模式下, containerView不需要addSubview:, 如果add了, 会出现黑屏. 效果图 比较简单, 需要demo的可以加QQ群: 475814382","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"animation","slug":"animation","permalink":"https://github.com/icoderRo/tags/animation/"}]},{"title":"property属性","slug":"property参数","date":"2014-05-12T16:00:00.000Z","updated":"2017-08-17T14:56:31.000Z","comments":true,"path":"2014/05/13/property参数/","link":"","permalink":"https://github.com/icoderRo/2014/05/13/property参数/","excerpt":"@property故事Objective-C特有的一个关键字@Property，它属于编译器一个特性，编译器编译@property时，会自动生成成员变量的set和get方法. Xcode4.5之前，@property会将其转换为成员变量set、get方法的声明，@synthesize会实现成员变量的set、get方法，所以XCode4.5之前，@property与@synthesize是配对使用。 在Xcode4.5以后，@property关键字，将自动生成成员变量的声明、相应set、get方法的声明与实现。 @property用法我们假设创建一个人类Person, 在不使用@property关键字的情况下, 看看是如何书写的. 123456789101112131415161718192021@interface Person : NSObject &#123; NSString *_name; &#125; - (void) setName:(NSString *)name; - (NSString *) name; @end @implementation Person -(void)setName:(NSString *)name &#123; _name = name; &#125; -(NSString *)name &#123; return _name; &#125; @end @property关键字,在Xcode4.5之前的写法: 1234567891011@interface Person :NSObject @property NSString *name; @end @implementation Person @synthesize name = _name; @end @synthesize name = _name, 如果省略, 编译器会自动帮你加上getter 和 setter 方法的实现，并且默认会去访问_name这个成员变量，如果找不到_name这个成员变量，会自动生成一个叫做 _name的私有成员变量（其他类不可访问（包括子类））。","text":"@property故事Objective-C特有的一个关键字@Property，它属于编译器一个特性，编译器编译@property时，会自动生成成员变量的set和get方法. Xcode4.5之前，@property会将其转换为成员变量set、get方法的声明，@synthesize会实现成员变量的set、get方法，所以XCode4.5之前，@property与@synthesize是配对使用。 在Xcode4.5以后，@property关键字，将自动生成成员变量的声明、相应set、get方法的声明与实现。 @property用法我们假设创建一个人类Person, 在不使用@property关键字的情况下, 看看是如何书写的. 123456789101112131415161718192021@interface Person : NSObject &#123; NSString *_name; &#125; - (void) setName:(NSString *)name; - (NSString *) name; @end @implementation Person -(void)setName:(NSString *)name &#123; _name = name; &#125; -(NSString *)name &#123; return _name; &#125; @end @property关键字,在Xcode4.5之前的写法: 1234567891011@interface Person :NSObject @property NSString *name; @end @implementation Person @synthesize name = _name; @end @synthesize name = _name, 如果省略, 编译器会自动帮你加上getter 和 setter 方法的实现，并且默认会去访问_name这个成员变量，如果找不到_name这个成员变量，会自动生成一个叫做 _name的私有成员变量（其他类不可访问（包括子类））。12345678910111213141516171819 @property NSString *name;代表生成了_name成员变量和set/get方法的声明等价于下面的代码; &#123; NSString *_name; &#125; - (void) setName:(NSString *)name; - (NSString *) name; @synthesize name = _name;则等价于实现了set/get方法, 等价于下面的代码; -(void)setName:(NSString *)name &#123; _name = name; &#125; -(NSString *)name &#123; return _name; &#125; - @property关键字,在Xcode4.5之后的写法: 123456789@interface Person : NSObject @property NSString *name; @end @implementation Person @end 省略@synthesize, 系统自动会帮我们生成_name的setter和getter方法 @property参数 第一组：retain assign copy strong weak unsafe_unretained autoreleasing 第二组：readwrite readonly 第三组：nonatomic atomic 第四组：setter getter 第一组用于：set方法内存管理 assign（默认参数）：生成直接赋值的set方法（不考虑内存管理），适用于非OC对象（基本数据类型、复合数据类型） retain：生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量 copy：生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。 Strong：强引用，决定了对象的存亡（一个对象如果没有强指针指向（引用计数器为0）时，对象将被销毁，释放内存），其指向一个对象，相当于该对象做了一次retain操作。适用于OC对象 weak：弱引用，其存在与否无所谓（弱指针指向对象与否（对象引用计算器不变）），适用于OC对象 unsafe_unretained：是unretained,与weak有点类似，但是它是unsafe的 weak与Strong一般在开启ARC机制下使用 Strong：强引用，决定了对象的存亡（一个对象如果没有强指针指向（引用计数器为0）时，对象将被销毁，释放内存），其指向一个对象，相当于该对象做了一次retain操作。 非ARC的retain，相当于ARC的strong，弱引用相当于assign 使用copy参数与使用retain参数产生的set方法一致（将生成set方法中的retain改为copy即可） 第二组（readwrite readonly）用于：是否要生成set方法 readwrite（默认参数）：同时生成set、get方法的声明与实现 readonly：只生成get方法的声明与实现（不生成set的方法的声明与实现） 第三组（nonatomic atomic）用于：多线程管理 atomic（默认参数）：原子性，性能低（一般开发OC中的APP不推荐使用，做金融等高安全的时候使用） nonatomic：非原子性，性能高（强烈推荐使用，性能高） atomic：（原子性操作）就是一个操作执行过程不能被中断, 要不就执行完, 要不就不执行（一个操作不可以被中途cpu暂停然后调度）。如果一个操作是原子性的, 那么在多线程环境下, 就不会出现变量被修改等奇怪的问题（保证数据同步）。原子操作就是不可再分的操作，在多线程程序中原子操作是一个非常重要的概念，它常常用来实现一些同步机制，同时也是一些常见的多线程Bug的源头。 nonatomic：（非原子性操作）操作是直接从内存中取数值（不考虑其是否被占用），因为它是从内存中取得数据，它并没有一个加锁的保护来用于cpu中的寄存器计算Value，它只是单纯的从内存地址中，当前的内存存储的数据结果来进行使用。在多线程环境下可提高性能，但无法保证数据同步。 第四组（setter getter）用于：set、get方法重命名（常用于BOOL类型的成员变量的get方法,BOOL方法常以is开头） setter：给成员变量的set方法重命名，set方法默认命名：- （void） set成员变量名（成员变量名首字母大写）：（成员变量数据类型）成员变量名 getter：给成员变量的set方法重命名，get方法默认命名：- （成员变量数据类型） 成员变量名","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/icoderRo/tags/Objective-C/"}]},{"title":"集合操作","slug":" 集合操作","date":"2014-03-21T16:00:00.000Z","updated":"2017-08-17T14:51:54.000Z","comments":true,"path":"2014/03/22/ 集合操作/","link":"","permalink":"https://github.com/icoderRo/2014/03/22/ 集合操作/","excerpt":"NSArray创建NSArray常规创建 123NSArray *arr = [[NSArray alloc] init];NSArray *arr = [NSArray arrayWithObject:@&quot;lc&quot;];NSArray *arr = [NSArray arrayWithObjects:@&quot;lc&quot;, 数组中的nil是结束符 数组简写 12NSArray *arr = [NSArray arrayWithObjects:@&quot;lcc&quot;, @&quot;lc&quot;, @&quot;cccc&quot;, nil];NSArray *arr = @[@&quot;lcc&quot;, @&quot;lc&quot;, @&quot;c&quot;]; 语法糖 NSArray的遍历for-i传统遍历 123for (int i = 0; i &lt; arr.count; ++i) &#123; NSLog(@&quot;arr[%i] = %@&quot;, i, arr[i]); &#125; for-in 123for (NSString *obj in arr) &#123; NSLog(@&quot;obj = %@&quot;, obj); &#125; 不可在遍历的时候, 修改里面的数据 迭代器遍历 123456[arr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; if (idx == 1) &#123; *stop = YES; &#125; NSLog(@&quot;obj = %@, idx = %lu&quot;, obj, idx); &#125;]; 数组所有元素调用统一的方法 123[arr makeObjectsPerformSelector:@selector(say)];[arr makeObjectsPerformSelector:@selector(sayWithName:) withObject:@&quot;aa&quot;]; 数组中统一调用方法","text":"NSArray创建NSArray常规创建 123NSArray *arr = [[NSArray alloc] init];NSArray *arr = [NSArray arrayWithObject:@&quot;lc&quot;];NSArray *arr = [NSArray arrayWithObjects:@&quot;lc&quot;, 数组中的nil是结束符 数组简写 12NSArray *arr = [NSArray arrayWithObjects:@&quot;lcc&quot;, @&quot;lc&quot;, @&quot;cccc&quot;, nil];NSArray *arr = @[@&quot;lcc&quot;, @&quot;lc&quot;, @&quot;c&quot;]; 语法糖 NSArray的遍历for-i传统遍历 123for (int i = 0; i &lt; arr.count; ++i) &#123; NSLog(@&quot;arr[%i] = %@&quot;, i, arr[i]); &#125; for-in 123for (NSString *obj in arr) &#123; NSLog(@&quot;obj = %@&quot;, obj); &#125; 不可在遍历的时候, 修改里面的数据 迭代器遍历 123456[arr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; if (idx == 1) &#123; *stop = YES; &#125; NSLog(@&quot;obj = %@, idx = %lu&quot;, obj, idx); &#125;]; 数组所有元素调用统一的方法 123[arr makeObjectsPerformSelector:@selector(say)];[arr makeObjectsPerformSelector:@selector(sayWithName:) withObject:@&quot;aa&quot;]; 数组中统一调用方法 NSArray的排序 Foundation框架中的对象 12NSArray *arr = @[@10, @20, @5, @7, @15];NSArray *newArr = [arr sortedArrayUsingSelector:@selector(compare:)]; 使用compare方法对数组中的元素进行排序,那么数组中的元素不能是自定义对象 自定义对象 1234567891011121314151617181920212223242526Person *p1 = [Person new];p1.age = 10;Person *p2 = [Person new];p2.age = 20;Person *p3 = [Person new];p3.age = 5;Person *p4 = [Person new];p4.age = 7;NSArray *arr = @[p1, p2, p3, p4];NSArray *newArr = [arr sortedArrayWithOptions:NSSortStable usingComparator:^NSComparisonResult(Person *obj1, Person *obj2) &#123; return obj1.age &gt; obj2.age; if (obj1.age &gt; obj2.age) &#123; return NSOrderedDescending; &#125;else if(obj1.age &lt; obj2.age)&#123; return NSOrderedAscending; &#125;else&#123; return NSOrderedSame; &#125; &#125;]; 默认会按照升序排序不能使用compare:方法对自定义对象进行排序 NSArray-&gt;NSString转换将数组中的所有元素拼接 12345678910// 用-将所有的元素连接起来生成一个字符串NSArray *arr = @[@&quot;aa&quot;, @&quot;bb&quot;, @&quot;cc&quot;];NSMutableString *strM = [NSMutableString string];for (NSString *str in arr) &#123; [strM appendString:str]; [strM appendString:@&quot;-&quot;]; &#125; [strM deleteCharactersInRange:NSMakeRange(strM.length - 1, 1)]; 等价于 NSString *str = [arr componentsJoinedByString:@”-“]; 字符串切割 12NSString *str1 = @&quot;lc-lcc-ccc&quot;;NSArray *arr1 = [str1 componentsSeparatedByString:@&quot;-&quot;]; NSArray文件读写将数组写入到文件中 12NSArray *arr = @[@&quot;aa&quot;, @&quot;bb&quot;, @&quot;cc&quot;];BOOL flag = [arr writeToFile:@&quot;/Users/lc/Desktop/abc.plist&quot; atomically:YES]; 将一个数组写入到文件中之后, 本质是写入了一个XML文件,一般情况下将XML文件的扩展名保存为plist 从文件中读取一个数组 1NSArray *newArray = [NSArray arrayWithContentsOfFile:@&quot;/Users/lc/Desktop/abc.plist&quot;]; NSMutableArray创建1NSMutableArray *arrM = [NSMutableArray array]; 添加12[arrM addObject:@&quot;lcc&quot;];[arrM addObjectsFromArray:@[@&quot;lcc&quot;, @&quot;lll&quot;]]; [arrM addObject:@[@”lcc”, @”ccc”]];将整个数组作为一个元素添加 插入12345[arrM insertObject:@&quot;ccc&quot; atIndex:1];NSRange range = NSMakeRange(2, 2);NSIndexSet *set = [NSIndexSet indexSetWithIndexesInRange:range];[arrM insertObjects:@[@&quot;A&quot;, @&quot;B&quot;] atIndexes:set]; 插入一组数据, 指定数组需要插入的位置, 和插入多少个 删除123[arrM removeObjectAtIndex:0];[arrM removeLastObject];[arrM removeObject:@&quot;A&quot;]; 替换123[arrM replaceObjectAtIndex:1 withObject:@&quot;K&quot;];arrM[0] = @&quot;K&quot;; 获取1[arrM objectAtIndex:0] NSDictionary创建123456NSDictionary *dict = [NSDictionary dictionaryWithObject:@&quot;lcc&quot; forKey:@&quot;name&quot;];NSDictionary *dict = [NSDictionary dictionaryWithObjects:@[@&quot;lcc&quot;, @&quot;30&quot;, @&quot;1.75&quot;] forKeys:@[@&quot;name&quot;, @&quot;age&quot;, @&quot;height&quot;]];NSDictionary *dict = @&#123;@&quot;name&quot;: @&quot;lcc&quot;&#125;;NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;lcc&quot;, @&quot;age&quot;:@&quot;30&quot;, @&quot;height&quot;:@&quot;1.75&quot;&#125;; 开发中常利用语法糖的方式 遍历12345678910111213141516NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;lcc&quot;, @&quot;age&quot;:@&quot;30&quot;, @&quot;height&quot;:@&quot;1.75&quot;&#125;; for (int i = 0; i &lt; dict.count; ++i) &#123; NSArray *keys = [dict allKeys]; NSString *key = keys[i]; NSString *value = dict[key]; &#125; for (NSString *key in dict) &#123; NSString *value = dict[key]; NSLog(@&quot;key = %@, value = %@&quot;, key, value); &#125; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSLog(@&quot;key = %@, value = %@&quot;, key, obj); &#125;]; 文件读写123456// 写NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;lcc&quot;, @&quot;age&quot;:@&quot;30&quot;, @&quot;height&quot;:@&quot;1.75&quot;&#125;;[dict writeToFile:@&quot;/Users/lc/Desktop/11.plist&quot; atomically:YES];// 读NSDictionary *newDict = [NSDictionary dictionaryWithContentsOfFile:@&quot;/Users/lc/Desktop/11.plist&quot;]; 字典和数组不同, 字典中保存的数据是无序的 NSMutableDictionary创建1NSMutableDictionary *dictM = [NSMutableDictionary dictionary]; 添加123[dictM setObject:@&quot;lcc&quot; forKey:@&quot;name&quot;];[dictM setValuesForKeysWithDictionary:@&#123;@&quot;age&quot;:@&quot;30&quot;, @&quot;height&quot;:@&quot;1.75&quot;&#125;]; 获取1dictM[@&quot;name&quot;] 删除123[dictM removeObjectForKey:@&quot;name&quot;];[dictM removeObjectsForKeys:@[@&quot;age&quot;, @&quot;height&quot;]]; 修改12[dictM setObject:@&quot;88&quot; forKey:@&quot;age&quot;];dictM[@&quot;age&quot;] = @&quot;88&quot;; 利用setObject方法给同名的key赋值, 那么新值会覆盖旧值 题外话不可变数组和可变数组,转换12NSMutableArray *arr = @[].mutableCopy;NSArray *arr1 = arr.copy; 字典也是同理 12NSMutableDictionary *mutDic = @&#123;&#125;.mutableCopy;NSDictionary *dict = mutDic.copy;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/icoderRo/tags/Objective-C/"}]},{"title":"字符串操作","slug":"字符串操作","date":"2014-03-05T16:00:00.000Z","updated":"2017-08-17T14:56:17.000Z","comments":true,"path":"2014/03/06/字符串操作/","link":"","permalink":"https://github.com/icoderRo/2014/03/06/字符串操作/","excerpt":"NSString创建NSString 直接创建 1NSString *str1 = @&quot;lc&quot; 通过@””创建字符串, 那么会将字符串放到常量区中,字符串常量, 只要内容相同, 不会重复创建 alloc或者类方法创建 1234NSString *str2 = [[NSString alloc] initWithString:@&quot;lc&quot;];NSString *str3 = [NSString stringWithFormat:@&quot;lcc&quot;];NSString *str3 = [[NSString alloc] initWithString:@&quot;lcc&quot;];NSString *str3 = [NSString stringWithFormat:@&quot;age is %i&quot;, 10]; 通过alloc或者类工厂方法创建, 那么会将字符串放到堆区中 字符串文件读写 从文件中读取字符串 123NSString *path = @&quot;/Users/lc/Desktop/lc.txt&quot;;NSError *error = nil;NSString *str = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error]; encoding: 编码英文 iOS-5988-1 中文 GBK GBK2312,UTF-8;…..OfFile(全路径) 将字符串写入到文件中 1234567NSString *str = @&quot;iOS&quot;;NSString *path2 = @&quot;/Users/lc/Desktop/lc.txt&quot;;BOOL flag = [str writeToFile:path2 atomically:YES encoding:NSUTF8StringEncoding error:nil];NSString *str = @&quot;abcdef&quot;;NSURL *url = [NSURL fileURLWithPath:@&quot;/Users/lc/Desktop/123.txt&quot;];[str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil]; atomically 如果传入YES, 字符串写入文件的过程中如果没有写完, 那么不会生成文件 如果传入NO, 字符串写入文件的过程中如果没有写完, 会生成文件 NSString -&gt; NSURL 123NSString *path = @&quot;file://本机IP/Users/lc/Desktop/123.txt&quot;;path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:path]; 如果访问本机的文件, 可以省略主机地址 NSString *path = @”file:///Users/lc/Desktop/123.txt”; NSURL -&gt; NSString 123456NSURL *url = [NSURL fileURLWithPath:@&quot;/Users/lc/Desktop/123.txt&quot;];NSError *error = nil;NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];","text":"NSString创建NSString 直接创建 1NSString *str1 = @&quot;lc&quot; 通过@””创建字符串, 那么会将字符串放到常量区中,字符串常量, 只要内容相同, 不会重复创建 alloc或者类方法创建 1234NSString *str2 = [[NSString alloc] initWithString:@&quot;lc&quot;];NSString *str3 = [NSString stringWithFormat:@&quot;lcc&quot;];NSString *str3 = [[NSString alloc] initWithString:@&quot;lcc&quot;];NSString *str3 = [NSString stringWithFormat:@&quot;age is %i&quot;, 10]; 通过alloc或者类工厂方法创建, 那么会将字符串放到堆区中 字符串文件读写 从文件中读取字符串 123NSString *path = @&quot;/Users/lc/Desktop/lc.txt&quot;;NSError *error = nil;NSString *str = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error]; encoding: 编码英文 iOS-5988-1 中文 GBK GBK2312,UTF-8;…..OfFile(全路径) 将字符串写入到文件中 1234567NSString *str = @&quot;iOS&quot;;NSString *path2 = @&quot;/Users/lc/Desktop/lc.txt&quot;;BOOL flag = [str writeToFile:path2 atomically:YES encoding:NSUTF8StringEncoding error:nil];NSString *str = @&quot;abcdef&quot;;NSURL *url = [NSURL fileURLWithPath:@&quot;/Users/lc/Desktop/123.txt&quot;];[str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil]; atomically 如果传入YES, 字符串写入文件的过程中如果没有写完, 那么不会生成文件 如果传入NO, 字符串写入文件的过程中如果没有写完, 会生成文件 NSString -&gt; NSURL 123NSString *path = @&quot;file://本机IP/Users/lc/Desktop/123.txt&quot;;path = [path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:path]; 如果访问本机的文件, 可以省略主机地址 NSString *path = @”file:///Users/lc/Desktop/123.txt”; NSURL -&gt; NSString 123456NSURL *url = [NSURL fileURLWithPath:@&quot;/Users/lc/Desktop/123.txt&quot;];NSError *error = nil;NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];NSString *str = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil]; 字符串比较 比较字符串内容是否相同 1BOOL flag = [str1 isEqualToString:str2]; flag = (str1 == str2);比较的是两个字符串的”地址”是否相同 比较字符串的大小 12345678910111213switch ([str1 compare:str2]) &#123; case NSOrderedAscending: NSLog(@&quot;str1小于str2&quot;); break; case NSOrderedSame: NSLog(@&quot;str1等于str2&quot;); break; case NSOrderedDescending: NSLog(@&quot;str1大于str2&quot;); break; default: break; &#125; * 忽略大小写进行比较 12345678910111213switch ([str1 caseInsensitiveCompare:str2]) &#123; case NSOrderedAscending: NSLog(@&quot;str1小于str2&quot;); break; case NSOrderedSame: NSLog(@&quot;str1等于str2&quot;); break; case NSOrderedDescending: NSLog(@&quot;str1大于str2&quot;); break; default: break; &#125; 字符串搜索 判断以什么开头 123456if ([str hasPrefix:@&quot;http://&quot;]) &#123; NSLog(@&quot;是一个URL&quot;); &#125;else &#123; NSLog(@&quot;不是一个URL&quot;); &#125; 本质就是从字符串的第一个字符开始匹配, 只要不匹配就返回NO 判断以什么结尾 12345if ([str hasSuffix:@&quot;.gif&quot;]) &#123; NSLog(@&quot;动态图片&quot;); &#125;else&#123; NSLog(@&quot;不是动态图片&quot;); &#125; 本质就是从字符串的最后一个字符开始匹配, 只要不匹配就返回NO 判断字符串中是否包含XX 123456789 NSString *str = @&quot;abcd&quot;; NSRange range = [str rangeOfString:@&quot;lc&quot;];// if (range.location == NSNotFound) &#123; if (range.length == 0)&#123; NSLog(@&quot;str中没有需要查找的字符串&quot;); &#125;else&#123; NSLog(@&quot;str中有需要查找的字符串&quot;); NSLog(@&quot;location = %lu, length = %lu&quot;, range.location, range.length); &#125; 只要str中包含该字符串, 那么就会返回该字符串在str中的起始位置以及该字符串的长度 location从0开始 , length从1开始 如果str中没有需要查找的字符串, 那么返回的range的length=0, location = NSNotFound 字符串截取NSString *str = @&quot;&lt;head&gt;小西哥&lt;/head&gt;&quot;; 动态获取截取的起始位置 1NSUInteger location = [str rangeOfString:@&quot;&gt;&quot;].location + 1; * 动态获取截取的长度 1234NSUInteger length = [str rangeOfString:@&quot;&lt;&quot; options:NSBackwardsSearch].location - location;NSUInteger length = [str rangeOfString:@&quot;&lt;/&quot;].location - location;NSRange range = NSMakeRange(location, length);NSString *newStr = [str substringWithRange:range]; &gt; options:NSBackwardsSearch:从后往前 1NSString *newStr = [str substringFromIndex:6]; &gt; 从什么地方开始截取, 一直截取到最后 1NSString *newStr = [str substringToIndex:6]; &gt; 从开头开始截取, 一直截取到什么位置 字符串的替换 替换 1[str stringByReplacingOccurrencesOfString:@&quot;&amp;&quot; withString:@&quot;/&quot;] &gt; 将&amp;符号替换为/ * 去空格 1[str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; * 删除字符串头尾空白 12 NSCharacterSet *set = [NSCharacterSet whitespaceCharacterSet];NSString *newStr = [str stringByTrimmingCharactersInSet:set]; * 返回大写字符串 12NSCharacterSet *set = [NSCharacterSet uppercaseLetterCharacterSet]; NSString *newStr = [str stringByTrimmingCharactersInSet:set]; ... 字符串与路径 判断是否是绝对路径 1[str isAbsolutePath] 判断字符串是否以/开头 获取文件路径中的最后一个目录 1[str lastPathComponent]; 获取路径中最后一个/后面的内容 删除文件路径中的最后一个目录 1[str stringByDeletingLastPathComponent]; 删除最后一个/后面的内容, “/“也会被删除 给文件路径添加一个目录 1[str stringByAppendingPathComponent:@&quot;lcc&quot;]; 就是在字符串的末尾加上一个”/“ 和指定的内容 如果路径后面已经有了/, 那么就不会添加了 如果路径后面有多个/, 那么会自动删除多余的/, 只保留一个 获取路径中文件的扩展名 1[str pathExtension]; 从字符串的末尾开始查找., 截取第一个.后面的内容 删除路径中文件的扩展名 1[str stringByDeletingPathExtension]; 从字符串的末尾开始查找.,删除第一个”.”和后面的内容 给文件路径添加一个扩展名 1[str stringByAppendingPathExtension:@&quot;jpg&quot;]; 在字符串的末尾加上一个.和指定的内容 字符串替换 将字符串转换为大写 1[str uppercaseString]; * 将字符串转换为小写 1[str lowercaseString]; * 将字符串的首字符转换为大写 1[str capitalizedString]; * 字符串与基本数据类型的转换 1234NSString *str1 = @&quot;110&quot;; NSString *str2 = @&quot;120&quot;; int value1 = [str1 intValue]; int value2 = [str2 intValue]; * C语言字符串和OC字符串之间的转换 12345char *cStr = &quot;lcc&quot;; NSString *str = [NSString stringWithUTF8String:cStr]; NSString *newStr = @&quot;lccc&quot;; const char *cStr2 = [newStr UTF8String]; NSMutableString创建NSMutableString 创建空字符串,在append 12345 NSMutableString *str = [NSMutableString string]; 或者 NSMutableString *str = [[NSMutableString alloc] init]; [str appendString:@&quot;lcc&quot;]; 直接赋值 123strM = [NSMutableString alloc] initWithFormat:&lt;#(NSString *), ...#&gt;strM = [NSMutableString stringWithFormat:&lt;#(NSString *), ...#&gt;] NSMutableString增删改 添加 12[strM appendString:@&quot;/image&quot;];[strM appendFormat:@&quot;/age is %i&quot;, 10]; 删除字符串 12NSRange range = [strM rangeOfString:@&quot;520&quot;];[strM deleteCharactersInRange:range]; 利用rangeOfString查找出520在字符串中的位置 deleteCharactersInRange方法删除指定的range的字符串 插入字符串 12NSRange range = [strM rangeOfString:@&quot;520&quot;];[strM insertString:@&quot;love&quot; atIndex:range.location]; insertString : 需要插入的字符串 atIndex: 从哪里开始插入 字符串中替换 1[strM replaceOccurrencesOfString:@&quot;520&quot; withString:@&quot;530&quot; options:0 range:NSMakeRange(0, strM.length)]; 如果是调用NSString的字符串替换方法, 不会修改原有字符串, 而是生产一个新的字符串 NSString *newStr =[strM stringByReplacingOccurrencesOfString:@&quot;520&quot; withString:@&quot;530&quot;]; OccurrencesOfString: 需要替换的字符串 withString: 用什么替换 options: 替换时的搜索方式 range: 搜索的范围 返回值: 代表替换了多少个字符串","categories":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/icoderRo/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://github.com/icoderRo/tags/Objective-C/"}]}]}